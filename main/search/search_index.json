{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#viiper-documentation","title":"VIIPER Documentation","text":"<p>Welcome to the VIIPER documentation!</p> <p>VIIPER is a tool to create virtual input devices using USBIP.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>CLI Reference</li> <li>API Reference</li> <li>GitHub Repository</li> </ul>"},{"location":"#what-is-viiper","title":"What is VIIPER?","text":"<p>VIIPER creates virtual USB input devices using the USBIP protocol. These virtual devices appear as real hardware to the operating system and applications, allowing you to emulate controllers, keyboards, and other input devices without physical hardware.</p> <p>VIIPER is a self-contained, standalone binary that uses USBIP to handle the USB protocol layer. Device emulation happens in userspace code instead of kernel drivers, so no kernel programming is required to add new device types. Users need USBIP installed once (built into Linux, usbip-win2 for Windows), after that VIIPER runs without additional dependencies or system-wide installation. The binary is portable and can be bundled with your application.</p> <p>Beyond device emulation, VIIPER can proxy real USB devices for traffic inspection and reverse engineering.</p> <p>All devices can and must be controlled programmatically via an API.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Virtual input device emulation over IP using USBIP<ul> <li>\u2705 Xbox 360 controller emulation (virtual device);  see Devices \u203a Xbox 360 Controller</li> <li>\u2705 HID Keyboard with N-key rollover and LED feedback; see Devices \u203a Keyboard</li> <li>\u2705 HID Mouse with 5 buttons and horizontal/vertical wheel; see Devices \u203a Mouse</li> <li>\ud83d\udea7 Extensible architecture allows for more device types (other gamepads, specialized HID)</li> </ul> </li> <li>\u2705 USBIP server mode: expose virtual devices to remote clients</li> <li>\u2705 Automatic local attachment: automatically controls usbip client on localhost to attach devices (enabled by default)</li> <li>\u2705 Proxy mode: forward real USB devices and inspect/record traffic</li> <li>\u2705 Cross-platform: works on Linux and Windows</li> <li>\u2705 Flexible logging (including raw USB packet logs)</li> <li>\u2705 API server for device/bus management and controlling virtual devices programmatically</li> <li>\u2705 Multiple client SDKs for easy integration; see Client SDKs   MIT Licensed</li> </ul>"},{"location":"mkdocs-readme/","title":"MkDocs Documentation","text":"<p>This directory contains the MkDocs-based documentation for VIIPER.</p>"},{"location":"mkdocs-readme/#setup","title":"Setup","text":"<p>Install MkDocs with Material theme:</p> <pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"mkdocs-readme/#development","title":"Development","text":"<p>Run the documentation server locally:</p> <pre><code>cd doc\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000/ in your browser.</p>"},{"location":"mkdocs-readme/#building","title":"Building","text":"<p>Build the static documentation site:</p> <pre><code>cd doc\nmkdocs build\n</code></pre> <p>The built site will be in the <code>site/</code> directory.</p>"},{"location":"mkdocs-readme/#deployment","title":"Deployment","text":"<p>Deploy to GitHub Pages:</p> <pre><code>cd doc\nmkdocs gh-deploy\n</code></pre>"},{"location":"mkdocs-readme/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - MkDocs configuration</li> <li><code>docs/</code> - Documentation source files (Markdown)<ul> <li><code>index.md</code> - Home page</li> <li><code>getting-started/</code> - Installation and quick start</li> <li><code>cli/</code> - CLI reference</li> <li><code>api/</code> - API reference</li> </ul> </li> </ul>"},{"location":"api/overview/","title":"API Reference","text":"<p>VIIPER ships a lightweight TCP API for managing virtual buses/devices and for device-specific streaming. It's designed to be trivial to drive from any language that can open a TCP socket and send null-byte-terminated commands.</p> <p>Client SDKs Available</p> <p>Generated client libraries are available that abstract away the protocol details described below. For most use cases, you should use one of the provided SDKs rather than implementing the raw protocol yourself:</p> <ul> <li>Go Client: Reference implementation included in the repository</li> <li>Generator Documentation: Information about code generation</li> <li>C SDK: Generated C library with type-safe device streams</li> <li>C# SDK: Generated .NET library with async/await support</li> <li>TypeScript SDK: Generated Node.js library with EventEmitter streams</li> </ul> <p>The documentation below is provided for reference and for implementing clients in languages not yet supported by the generator.</p>"},{"location":"api/overview/#protocol-overview","title":"Protocol overview","text":"<ul> <li>Transport: TCP</li> <li>Default listen address: <code>:3242</code> (configurable via <code>--api.addr</code>)</li> <li>Request format: a single ASCII/UTF\u20118 line terminated by <code>\\0</code> (null byte)</li> <li>Routing: path followed by optional payload separated by whitespace (e.g., <code>bus/list\\0</code> or <code>bus/create 5\\0</code>)</li> <li>Payload: optional string that can be a JSON object, numeric value, or plain string depending on the endpoint. The payload may contain newlines (e.g., pretty-printed JSON) as only the null byte terminates the request.</li> <li>Success response: a single line containing a JSON payload (or an empty line for commands that have no payload), followed by <code>\\n</code>, then connection close</li> <li>Error response: a single line JSON object following RFC 7807 Problem Details format with a <code>status</code> field (HTTP-style status code) and other error details, followed by <code>\\n</code>, then connection close</li> </ul> <p>Tip: You can experiment with <code>nc</code>/<code>ncat</code> or PowerShell\u2019s <code>tcpclient</code> to send lines and read JSON back.</p> <p>Connection timing and auto\u2011cleanup</p> <p>After you add a device with <code>bus/{id}/add</code>, you must connect to its streaming endpoint within the configured <code>DeviceHandlerConnectTimeout</code> (default: 5s). If no stream connection is established in time, the device is automatically removed. Likewise, when a stream disconnects, a reconnection timer with the same timeout starts; if the client doesn\u2019t reconnect before it expires, the device is removed.</p>"},{"location":"api/overview/#commands","title":"Commands","text":"<p>The server registers the following commands and streams:</p> <ul> <li> <p><code>bus/list</code></p> <ul> <li>List all virtual bus IDs.</li> <li>Response: <code>{ \"buses\": [1, 2, ...] }</code></li> </ul> </li> <li> <p><code>bus/create [busId]</code></p> <ul> <li>Create a new bus. If <code>busId</code> (numeric) is provided, VIIPER attempts to create the bus with that id; otherwise it picks the next free id.</li> <li>Payload: Optional numeric bus ID (e.g., <code>5</code>)</li> <li>Response: <code>{ \"busId\": &lt;id&gt; }</code></li> </ul> </li> <li> <p><code>bus/remove &lt;busId&gt;</code></p> <ul> <li>Remove a bus and all devices on it.</li> <li>Payload: Numeric bus ID (e.g., <code>1</code>)</li> <li>Response: <code>{ \"busId\": &lt;id&gt; }</code></li> </ul> </li> <li> <p><code>bus/{id}/list</code></p> <ul> <li>List devices on a bus.</li> <li>Response: <code>{ \"devices\": [{ \"busId\": 1, \"devId\": \"1\", \"vid\": \"0x045e\", \"pid\": \"0x028e\", \"type\": \"xbox360\" }, ...] }</code></li> </ul> </li> <li> <p><code>bus/{id}/add &lt;json_payload&gt;</code></p> <ul> <li>Add a device to a bus.</li> <li>Payload: JSON object with device creation parameters: <code>{\"type\": \"&lt;deviceType&gt;\", \"idVendor\": &lt;optional_vid&gt;, \"idProduct\": &lt;optional_pid&gt;}</code></li> <li>Example: <code>{\"type\": \"xbox360\"}</code> or <code>{\"type\": \"keyboard\", \"idVendor\": 1234, \"idProduct\": 5678}</code></li> <li>Response: JSON device object with fields: <code>{\"busId\": &lt;id&gt;, \"devId\": \"&lt;devId&gt;\", \"vid\": \"0x045e\", \"pid\": \"0x028e\", \"type\": \"xbox360\"}</code></li> <li>Important: After add, the server starts a connect timer (default <code>5s</code>). You must open a device stream (see below) before the timeout expires, otherwise the device is auto-removed.</li> <li>If auto-attach is enabled (default) the server automatically attaches the new device to a local USBIP client on the same host (localhost only). Failures (missing tool, non-zero exit) are logged but do not affect the API response.</li> </ul> </li> <li> <p><code>bus/{id}/remove &lt;deviceId&gt;</code></p> <ul> <li>Remove a device by its device number on that bus.</li> <li>Payload: Numeric device ID (e.g., <code>1</code> for device 1-1 on the bus)</li> <li>Response: <code>{ \"busId\": &lt;id&gt;, \"devId\": \"&lt;dev&gt;\" }</code></li> </ul> </li> </ul>"},{"location":"api/overview/#streaming-endpoint","title":"Streaming endpoint","text":"<ul> <li>Path: <code>bus/{busId}/{deviceid}</code></li> <li>Handshake: Send the path followed by <code>\\0</code> (null byte) (e.g., <code>bus/1/1\\0</code>)</li> <li>Type: long-lived TCP connection</li> <li>Purpose: device-specific, bidirectional stream. The API server hands the socket to the device's registered stream handler.</li> <li>Timeout behavior: When a stream ends, a reconnect timer is started (same <code>DeviceHandlerConnectTimeout</code>).   If the client doesn't reconnect in time, the device is removed.</li> </ul>"},{"location":"api/overview/#xbox-360-controller-stream-device-type-xbox360","title":"Xbox 360 controller stream (device type: <code>xbox360</code>)","text":"<p>Direction: client \u279c server (input state)</p> <ul> <li>Fixed 14-byte packets, little-endian layout:<ul> <li><code>Buttons</code> uint32 (4 bytes)</li> <li><code>LT</code> uint8, <code>RT</code> uint8 (2 bytes)</li> <li><code>LX, LY, RX, RY</code> int16 each (8 bytes)</li> </ul> </li> </ul> <p>Direction: server \u279c client (rumble)</p> <ul> <li>Fixed 2-byte packets:<ul> <li><code>LeftMotor</code> uint8, <code>RightMotor</code> uint8</li> </ul> </li> </ul> <p>See <code>pkg/device/xbox360/protocol.go</code> for full details.</p>"},{"location":"api/overview/#hid-keyboard-stream-device-type-keyboard","title":"HID keyboard stream (device type: <code>keyboard</code>)","text":"<p>Direction: client \u279c server (keys pressed)</p> <ul> <li>Variable-length packets per frame:<ul> <li>Header: Modifiers uint8, KeyCount uint8</li> <li>Body: KeyCount bytes of HID Usage IDs for currently pressed (non-modifier) keys</li> </ul> </li> </ul> <p>Direction: server \u279c client (LED state)</p> <ul> <li>1-byte packets whenever host LED state changes:<ul> <li>Bit 0 NumLock, Bit 1 CapsLock, Bit 2 ScrollLock</li> </ul> </li> </ul> <p>Host-facing HID input report is 34 bytes: [Modifiers (1), Reserved (1), 256-bit key bitmap (32)].</p> <p>See <code>pkg/device/keyboard/</code> for helpers and constants.</p>"},{"location":"api/overview/#hid-mouse-stream-device-type-mouse","title":"HID mouse stream (device type: <code>mouse</code>)","text":"<p>Direction: client \u279c server (motion/buttons)</p> <ul> <li>Fixed 5-byte packets per frame:<ul> <li>Buttons uint8 (bits 0..4)</li> <li>dX int8, dY int8</li> <li>Wheel int8, Pan int8</li> </ul> </li> </ul> <p>Direction: server \u279c client</p> <ul> <li>None (mouse is input-only)</li> </ul> <p>Note: Motion and wheel deltas are consumed after each IN report so movement is relative.</p> <p>Note on protocol compatibility:</p> <ul> <li>The wire format is modeled after the XInput gamepad state (XINPUT_GAMEPAD) but is not byte\u2011for\u2011byte identical. Key differences:<ul> <li>Buttons are encoded as a 32\u2011bit little\u2011endian field (XInput uses a 16\u2011bit bitmask), making the packet 14 bytes instead of 12.</li> <li>No header or framing: packets are fixed\u2011length and back\u2011to\u2011back on the TCP stream.</li> <li>Endianness is little\u2011endian for all multi\u2011byte fields.</li> </ul> </li> </ul>"},{"location":"api/overview/#example-sessions","title":"Example sessions","text":""},{"location":"api/overview/#using-netcat-linuxmacos","title":"Using netcat (Linux/macOS)","text":"<pre><code># List buses\nprintf \"bus/list\\0\" | nc localhost 3242\n\n# Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n# \u2192 {\"busId\":1}\n\n# Create a bus with specific ID\nprintf \"bus/create 5\\0\" | nc localhost 3242\n# \u2192 {\"busId\":5}\n\n# Add a virtual Xbox 360 controller to bus 1\nprintf 'bus/1/add {\"type\":\"xbox360\"}\\0' | nc localhost 3242\n# \u2192 {\"busId\":1,\"devId\":\"1\",\"vid\":\"0x045e\",\"pid\":\"0x028e\",\"type\":\"xbox360\"}\n\n# List devices on bus 1\nprintf \"bus/1/list\\0\" | nc localhost 3242\n</code></pre> <p>Then, open a second TCP connection for streaming to <code>bus/1/1</code> (the API port, not the USBIP port). First send the handshake <code>bus/1/1\\0</code>, then you'll write 14\u2011byte input packets and read 2\u2011byte rumble packets. Any language with raw TCP support works.</p>"},{"location":"api/overview/#windows-powershell","title":"WIndows (PowerShell)","text":"<p>VIIPER includes convenience scripts for quick testing and automation:</p> <pre><code># Source the script to load helper functions\n. .\\scripts\\viiper-api.ps1\n\n# Use the Invoke-ViiperApi function (or 'viiper' alias)\nviiper \"bus/list\"\nviiper \"bus/create\"\nviiper \"bus/1/add {\\\"type\\\":\\\"xbox360\\\"}\" -Port 3242 -Hostname localhost\n</code></pre> <p>The script provides <code>Invoke-ViiperApi</code> (alias: <code>viiper</code>) for sending commands and <code>Connect-ViiperDevice</code> for testing persistent device connections.</p>"},{"location":"api/overview/#go-snippet-raw","title":"Go snippet (raw)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net\"\n)\n\nfunc main() {\n    conn, _ := net.Dial(\"tcp\", \"localhost:3242\")\n    defer conn.Close()\n\n    // Send request with null terminator\n    fmt.Fprint(conn, \"bus/create\\x00\")\n\n    // Read entire response until connection closes\n    resp, _ := io.ReadAll(conn)\n    fmt.Println(string(resp)) // {\"busId\":1}\\n\n}\n</code></pre> <p>For a higher-level experience, see the Go client in <code>pkg/apiclient/</code>.</p>"},{"location":"api/overview/#how-this-relates-to-usbip","title":"How this relates to USBIP","text":"<p>The API controls which virtual devices exist and exposes a device stream for live input/feedback. Separately, the USBIP server (default <code>:3241</code>) makes these devices attachable from clients. Typical flow:</p> <p>1) Create a bus \u279c 2) Add a device \u279c 3) Connect the device stream \u279c 4) Attach using USBIP by <code>busid</code> (see the Server command page for syntax).</p> <p>If auto-attach is enabled step 4 is attempted automatically for the local host; you still must perform step 3 to keep the device alive.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Development Version (main)</li> </ul>"},{"location":"changelog/#released-versions","title":"Released Versions","text":"<ul> <li>Version 0.1.0</li> <li>Version 0.0.4</li> <li>Version 0.0.3</li> <li>Version 0.0.2</li> <li>Version 0.0.1</li> </ul>"},{"location":"changelog/main/","title":"Changelog for Development Version","text":"<p>This page shows unreleased changes in the development version.</p> <p>Changes since v0.1.0:</p>"},{"location":"changelog/main/#new-features","title":"\u2728 New Features","text":"<ul> <li>Add prerequisites Check</li> </ul>"},{"location":"changelog/main/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Breaking Fix missing underscores in C SDK constants</li> </ul>"},{"location":"changelog/main/#miscellaneous","title":"\ud83d\udd27 Miscellaneous","text":"<ul> <li>Breaking Switch to \\0 terminated transport</li> </ul>"},{"location":"cli/codegen/","title":"Code Generation Command","text":"<p>The <code>codegen</code> command generates type-safe client SDKs from Go source code annotations.</p>"},{"location":"cli/codegen/#usage","title":"Usage","text":"<pre><code>viiper codegen [flags]\n</code></pre>"},{"location":"cli/codegen/#description","title":"Description","text":"<p>Scans the VIIPER server codebase to extract:</p> <ul> <li>API routes and response DTOs</li> <li>Device wire formats from <code>viiper:wire</code> comment tags</li> <li>Device constants (keycodes, modifiers, button masks)</li> </ul> <p>Then generates client SDKs with:</p> <ul> <li>Management API clients</li> <li>Device-agnostic stream wrappers</li> <li>Per-device encode/decode functions</li> <li>Typed constants and enums</li> </ul> <p>Sourcecode access is required</p> <p>The codegen command requires access to VIIPER source code. It must be executed from the <code>viiper/</code> module directory within the repository.</p>"},{"location":"cli/codegen/#flags","title":"Flags","text":""},{"location":"cli/codegen/#-output","title":"<code>--output</code>","text":"<p>Output directory for generated SDKs (relative to repository root).</p> <p>Default: <code>../clients</code> Environment Variable: <code>VIIPER_CODEGEN_OUTPUT</code></p> <p>Example:</p> <pre><code>viiper codegen --output=../sdk-output\n</code></pre>"},{"location":"cli/codegen/#-lang","title":"<code>--lang</code>","text":"<p>Target language to generate.</p> <p>Values: <code>c</code>, <code>csharp</code>, <code>typescript</code>, <code>all</code> Default: <code>all</code> Environment Variable: <code>VIIPER_CODEGEN_LANG</code></p> <p>Examples:</p> <pre><code># Generate all SDKs\nviiper codegen --lang=all\n\n# Generate C SDK only\nviiper codegen --lang=c\n\n# Generate C# SDK only\nviiper codegen --lang=csharp\n\n# Generate TypeScript SDK only\nviiper codegen --lang=typescript\n</code></pre>"},{"location":"cli/codegen/#examples","title":"Examples","text":""},{"location":"cli/codegen/#generate-all-sdks","title":"Generate All SDKs","text":"<pre><code>cd viiper\ngo run ./cmd/viiper codegen\n</code></pre>"},{"location":"cli/codegen/#generate-c-sdk-and-rebuild-examples","title":"Generate C SDK and Rebuild Examples","text":"<pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=c\ncd ../examples/c\ncmake --build build --config Release\n</code></pre>"},{"location":"cli/codegen/#when-to-regenerate","title":"When to Regenerate","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>pkg/apitypes/*.go</code>: API response structures</li> <li><code>pkg/device/*/inputstate.go</code>: Wire format annotations</li> <li><code>pkg/device/*/const.go</code>: Exported constants</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li>Generator templates in <code>internal/codegen/generator/</code></li> </ul>"},{"location":"cli/codegen/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: Detailed explanation of tagging system and code generation flow</li> <li>C SDK Documentation: C-specific usage and build instructions</li> <li>Configuration: Global configuration options</li> </ul>"},{"location":"cli/configuration/","title":"Configuration","text":"<p>VIIPER can be configured via:</p> <ul> <li>Command-line flags</li> <li>Environment variables</li> <li>Configuration files (JSON/YAML/TOML)</li> </ul>"},{"location":"cli/configuration/#environment-variables","title":"Environment Variables","text":"<p>All command-line flags have corresponding environment variables for easier deployment and configuration management.</p>"},{"location":"cli/configuration/#global-configuration","title":"Global Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_LOG_LEVEL</code> <code>--log.level</code> <code>info</code> Logging level: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> <code>VIIPER_LOG_FILE</code> <code>--log.file</code> (none) Log file path (logs only to console if not set) <code>VIIPER_LOG_RAW_FILE</code> <code>--log.raw-file</code> (none) Raw packet log file path"},{"location":"cli/configuration/#server-configuration","title":"Server Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_USB_ADDR</code> <code>--usb.addr</code> <code>:3241</code> USBIP server listen address <code>VIIPER_API_ADDR</code> <code>--api.addr</code> <code>:3242</code> API server listen address <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code> <code>--api.device-handler-timeout</code> <code>5s</code> Device handler auto-cleanup timeout <code>VIIPER_API_AUTO_ATTACH_LOCAL_CLIENT</code> <code>--api.auto-attach-local-client</code> <code>true</code> Auto-attach exported devices to local usbip client <code>VIIPER_CONNECTION_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection operation timeout"},{"location":"cli/configuration/#proxy-configuration","title":"Proxy Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_PROXY_ADDR</code> <code>--listen-addr</code> <code>:3241</code> Proxy listen address <code>VIIPER_PROXY_UPSTREAM</code> <code>--upstream</code> (required) Upstream USBIP server address <code>VIIPER_PROXY_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection timeout"},{"location":"cli/configuration/#configuration-files","title":"Configuration Files","text":"<p>VIIPER supports JSON, YAML, and TOML configuration files. Generate a starter file with:</p> <pre><code>viiper config init server --format=json   # or yaml|toml\n</code></pre> <p>If no output path is provided, the file is written to the current working directory (e.g., server.json, proxy.yaml).</p> <p>You can also specify a custom location:</p> <pre><code>viiper config init server --format=json --output ./server.json\n</code></pre> <p>To use a specific configuration file when starting VIIPER, pass the --config flag (or set VIIPER_CONFIG):</p> <pre><code>viiper --config ./server.json server\n</code></pre> <p>If --config is not provided, VIIPER will search for configuration in this order and first-found is used for each format:</p> <ol> <li>Working directory: server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), viiper.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Platform config directory (see above): server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Linux system-wide: /etc/viiper/server.(json|yaml|yml|toml), /etc/viiper/proxy.(json|yaml|yml|toml), /etc/viiper/config.(json|yaml|yml|toml)</li> </ol> <p>Example JSON configurations:</p> <p>Server:</p> <pre><code>{\n  \"api\": {\n    \"addr\": \":3242\",\n    \"device-handler-connect-timeout\": \"5s\",\n    \"auto-attach-local-client\": true\n  },\n  \"usb\": {\n    \"addr\": \":3241\"\n  },\n  \"connection-timeout\": \"30s\"\n}\n</code></pre> <p>Proxy:</p> <pre><code>{\n  \"listen-addr\": \":3241\",\n  \"upstream-addr\": \"127.0.0.1:3242\",\n  \"connection-timeout\": \"30s\"\n}\n</code></pre>"},{"location":"cli/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"cli/configuration/#using-environment-variables","title":"Using Environment Variables","text":"<p>Create a <code>.env</code> file or export variables:</p> <pre><code>export VIIPER_LOG_LEVEL=debug\nexport VIIPER_USB_ADDR=:3241\nexport VIIPER_API_ADDR=:3242\nexport VIIPER_LOG_FILE=/var/log/viiper.log\n</code></pre> <p>Then run:</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/configuration/#systemd-service","title":"Systemd Service","text":"<p>Example systemd service file for running VIIPER as a service:</p> <pre><code>[Unit]\nDescription=VIIPER USBIP Server\nAfter=network.target\n\n[Service]\nType=simple\nUser=viiper\nGroup=viiper\nEnvironment=\"VIIPER_LOG_LEVEL=info\"\nEnvironment=\"VIIPER_LOG_FILE=/var/log/viiper/viiper.log\"\nEnvironment=\"VIIPER_USB_ADDR=:3241\"\nEnvironment=\"VIIPER_API_ADDR=:3242\"\nExecStart=/usr/local/bin/viiper server\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"cli/configuration/#configuration-priority","title":"Configuration Priority","text":"<p>When both CLI flags and environment variables are set, CLI flags take precedence:</p> <ol> <li>CLI flags (highest priority)</li> <li>Environment variables</li> <li>Configuration file values</li> <li>Default values (lowest priority)</li> </ol>"},{"location":"cli/configuration/#see-also","title":"See Also","text":"<ul> <li>Server Command</li> <li>Proxy Command</li> </ul>"},{"location":"cli/overview/","title":"CLI Overview","text":"<p>VIIPER provides a command-line interface for running the USBIP server and proxy.</p>"},{"location":"cli/overview/#commands","title":"Commands","text":"<ul> <li><code>server</code> - Start the VIIPER USBIP server</li> <li><code>proxy</code> - Start the VIIPER USBIP proxy</li> <li><code>codegen</code> - Generate client SDKs from source code annotations</li> </ul>"},{"location":"cli/overview/#global-options","title":"Global Options","text":""},{"location":"cli/overview/#logging","title":"Logging","text":"<p>VIIPER supports flexible logging configuration via global flags or environment variables.</p>"},{"location":"cli/overview/#-loglevel","title":"<code>--log.level</code>","text":"<p>Set the logging level.</p> <p>Values: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> Default: <code>info</code> Environment Variable: <code>VIIPER_LOG_LEVEL</code></p> <p>Example:</p> <pre><code>viiper server --log.level=debug\n</code></pre>"},{"location":"cli/overview/#-logfile","title":"<code>--log.file</code>","text":"<p>Log to a file in addition to console output.</p> <p>Default: (none - logs only to console) Environment Variable: <code>VIIPER_LOG_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/overview/#-lograw-file","title":"<code>--log.raw-file</code>","text":"<p>Log raw USB packet data to a file for debugging and reverse engineering.</p> <p>Default: (none) Environment Variable: <code>VIIPER_LOG_RAW_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre> <p>Automatic Raw Logging</p> <p>When <code>--log.level=trace</code> is set without <code>--log.raw-file</code>, raw packets are logged to stdout.</p>"},{"location":"cli/overview/#getting-help","title":"Getting Help","text":"<p>Display help for any command:</p> <pre><code>viiper --help\nviiper server --help\nviiper proxy --help\n</code></pre>"},{"location":"cli/proxy/","title":"Proxy Command","text":"<p>Start the VIIPER USBIP proxy for traffic inspection and logging.</p>"},{"location":"cli/proxy/#usage","title":"Usage","text":"<pre><code>viiper proxy --upstream=&lt;address&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/proxy/#description","title":"Description","text":"<p>The <code>proxy</code> command starts VIIPER in proxy mode, sitting between a USBIP client and a USBIP server. VIIPER intercepts and logs all USB traffic passing through, without handling the devices directly.</p> <p>This is useful for reverse engineering USB protocols and understanding how devices communicate.</p>"},{"location":"cli/proxy/#options","title":"Options","text":""},{"location":"cli/proxy/#-listen-addr","title":"<code>--listen-addr</code>","text":"<p>Proxy listen address (where clients connect).</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_PROXY_ADDR</code></p> <p>Example:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3240\n</code></pre>"},{"location":"cli/proxy/#-upstream","title":"<code>--upstream</code>","text":"<p>Required. Upstream USBIP server address (where real devices are).</p> <p>Environment Variable: <code>VIIPER_PROXY_UPSTREAM</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240\n</code></pre>"},{"location":"cli/proxy/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection timeout for proxy operations.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_PROXY_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --connection-timeout=60s\n</code></pre>"},{"location":"cli/proxy/#examples","title":"Examples","text":""},{"location":"cli/proxy/#basic-proxy","title":"Basic Proxy","text":"<p>Start proxy between local clients and remote USBIP server:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240\n</code></pre> <p>Clients connect to <code>localhost:3241</code>, traffic is proxied to <code>192.168.1.100:3240</code>.</p>"},{"location":"cli/proxy/#custom-listen-address","title":"Custom Listen Address","text":"<p>Start proxy on a different port:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3240\n</code></pre> <p>Clients connect to <code>localhost:9000</code>, traffic is proxied to <code>192.168.1.100:3240</code>.</p>"},{"location":"cli/proxy/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Capture all USB traffic for reverse engineering:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --log.raw-file=usb-capture.log\n</code></pre> <p>All USB packets will be logged to <code>usb-capture.log</code>.</p>"},{"location":"cli/proxy/#with-debug-logging","title":"With Debug Logging","text":"<p>Enable debug logging to see proxy operations:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --log.level=debug\n</code></pre>"},{"location":"cli/proxy/#use-cases","title":"Use Cases","text":""},{"location":"cli/proxy/#reverse-engineering","title":"Reverse Engineering","text":"<p>Intercept USB traffic between a client and server to understand device protocols:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.raw-file=device-capture.log\n</code></pre>"},{"location":"cli/proxy/#traffic-analysis","title":"Traffic Analysis","text":"<p>Monitor USB communication for debugging:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.level=trace\n</code></pre>"},{"location":"cli/proxy/#network-inspection","title":"Network Inspection","text":"<p>Route USB traffic through VIIPER to inspect and log all operations:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.level=debug --log.raw-file=traffic.log\n</code></pre>"},{"location":"cli/proxy/#proxy-architecture","title":"Proxy Architecture","text":"<pre><code>USBIP Client  \u2192  VIIPER Proxy  \u2192  USBIP Server (real devices)\n                      \u2193\n              Logs/Captures Traffic\n</code></pre> <p>VIIPER sits in the middle, forwarding all traffic while logging packets for inspection.</p>"},{"location":"cli/proxy/#see-also","title":"See Also","text":"<ul> <li>Server Command - Run VIIPER as a USBIP server</li> <li>Configuration - Environment variables and configuration files</li> </ul>"},{"location":"cli/server/","title":"Server Command","text":"<p>Start the VIIPER USBIP server to expose virtual devices.</p>"},{"location":"cli/server/#usage","title":"Usage","text":"<pre><code>viiper server [OPTIONS]\n</code></pre>"},{"location":"cli/server/#description","title":"Description","text":"<p>The <code>server</code> command starts the VIIPER USBIP server, which allows you to create and manage virtual USB devices that appear as real hardware to USBIP clients.</p> <p>The server exposes two interfaces:</p> <ol> <li>USBIP Server - Standard USBIP protocol for device attachment</li> <li>API Server - Management API for device/bus control</li> </ol> <p>Automatic Local Attachment</p> <p>By default, VIIPER automatically attaches newly created devices to the local USBIP client (localhost only). This means when you create a device via the API, it will be immediately available on the same machine without manual <code>usbip attach</code> commands. This behavior can be disabled with <code>--api.auto-attach-local-client=false</code> if you prefer manual control or are running on a remote server.</p>"},{"location":"cli/server/#options","title":"Options","text":""},{"location":"cli/server/#-usbaddr","title":"<code>--usb.addr</code>","text":"<p>USBIP server listen address.</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_USB_ADDR</code></p> <p>Example:</p> <pre><code>viiper server --usb.addr=0.0.0.0:3241\n</code></pre>"},{"location":"cli/server/#-apiaddr","title":"<code>--api.addr</code>","text":"<p>API server listen address.</p> <p>Default: <code>:3242</code> Environment Variable: <code>VIIPER_API_ADDR</code></p> <p>Example:</p> <pre><code># Enable API on custom port\nviiper server --api.addr=:8080\n</code></pre>"},{"location":"cli/server/#-apidevice-handler-timeout","title":"<code>--api.device-handler-timeout</code>","text":"<p>Time before auto-cleanup occurs when a device handler has no active connection.</p> <p>Default: <code>5s</code> Environment Variable: <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --api.device-handler-timeout=10s\n</code></pre>"},{"location":"cli/server/#-apiauto-attach-local-client","title":"<code>--api.auto-attach-local-client</code>","text":"<p>Automatically attach newly added devices to a local USBIP client on the same host (localhost only). This is a convenience feature; attachment failures (tool not found, error exit) are logged but do not abort device creation.</p> <p>VIIPER expects the USBIP command-line tool to be in the PATH (should be by default) (<code>usbip</code> on Linux, <code>usbip.exe</code> on Windows). If it is missing, auto-attach will simply log an error.</p> <p>Default: <code>true</code> Environment Variable: <code>VIIPER_API_AUTO_ATTACH_LOCAL_CLIENT</code></p> <p>Disable example:</p> <pre><code>viiper server --api.auto-attach-local-client=false\n</code></pre>"},{"location":"cli/server/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection operation timeout for both USBIP and API servers.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_CONNECTION_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --connection-timeout=60s\n</code></pre>"},{"location":"cli/server/#examples","title":"Examples","text":""},{"location":"cli/server/#basic-server","title":"Basic Server","text":"<p>Start server with default settings (USBIP on :3241, API on :3242):</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/server/#custom-addresses","title":"Custom Addresses","text":"<p>Start server on custom ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre>"},{"location":"cli/server/#with-logging","title":"With Logging","text":"<p>Start server with debug logging to file:</p> <pre><code>viiper server --log.level=debug --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/server/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Start server with raw USB packet logging (useful for reverse engineering):</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre>"},{"location":"cli/server/#connect-from-a-client-usbip","title":"Connect from a client (USBIP)","text":"<p>After the server is running and a virtual device has been added to a bus (via the API), attach it from a client using USBIP.</p> <p>Notes:</p> <ul> <li>VIIPER's USBIP server listens on <code>:3241</code> by default (configurable via <code>--usb.addr</code>).</li> <li>The BUSID-DEVICEID you need (e.g. <code>1-1</code>) is returned by the API on device add and also visible via <code>usbip list</code>.</li> </ul>"},{"location":"cli/server/#linux","title":"Linux","text":"<pre><code># Load the virtual host controller (only needed once per boot)\nsudo modprobe vhci-hcd\n\n# List exportable devices on the VIIPER host\nusbip list --remote=VIIPER_HOST --tcp-port=3241\n\n# Attach a device by busid (long flags)\nsudo usbip attach --remote=VIIPER_HOST --tcp-port=3241 --busid=BUSID-DEVICEID\n\n# Equivalent short-form flags\nsudo usbip --tcp-port 3241 -r VIIPER_HOST -b BUSID-DEVICEID\n</code></pre> <p>Replace <code>VIIPER_HOST</code> with the server's hostname/IP. If you changed the USBIP port, use that port instead of <code>3241</code>.</p>"},{"location":"cli/server/#windows","title":"Windows","text":"<p>On Windows, use usbip-win2:</p> <ul> <li>GUI: use the client to add a remote host and attach by busid.</li> <li>CLI (similar flags):</li> </ul> <pre><code>usbip.exe list --remote VIIPER_HOST --tcp-port 3241\nusbip.exe attach --remote VIIPER_HOST --tcp-port 3241 --busid BUSID-DEVICEID\n</code></pre> <p>Once attached, the device will appear to the OS/applications as a local USB device.</p>"},{"location":"cli/server/#see-also","title":"See Also","text":"<ul> <li>Configuration - Environment variables and configuration files</li> <li>API Reference - API server documentation</li> </ul>"},{"location":"clients/c/","title":"C SDK Documentation","text":"<p>The VIIPER C SDK provides a lightweight, dependency-free client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/c/#overview","title":"Overview","text":"<p>The C SDK features:</p> <ul> <li>Device-agnostic streaming API: Uniform interface for all device types</li> <li>Zero dependencies: Pure C99, no external libraries required</li> <li>Cross-platform: Windows (MSVC) and POSIX (GCC/Clang)</li> <li>Type-safe: Generated headers with packed structs and constants</li> <li>Thread-safe: Recommended: one <code>viiper_client_t</code> per thread</li> </ul> <p>License</p> <p>The C SDK is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/c/#installation","title":"Installation","text":""},{"location":"clients/c/#building-from-source","title":"Building from Source","text":"<p>The C SDK is generated from the VIIPER server codebase:</p> <pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=c\n</code></pre> <p>Build the SDK:</p> <pre><code>cd ../clients/c\ncmake -B build -G \"Visual Studio 17 2022\"  # Windows\ncmake -B build                              # POSIX\ncmake --build build --config Release\n</code></pre>"},{"location":"clients/c/#linking-to-your-project","title":"Linking to Your Project","text":"<p>CMake:</p> <pre><code># Add viiper SDK\nadd_subdirectory(path/to/clients/c)\ntarget_link_libraries(your_target PRIVATE viiper)\n\n# Copy DLL on Windows (post-build)\nif(WIN32)\n    add_custom_command(TARGET your_target POST_BUILD\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n        $&lt;TARGET_FILE:viiper&gt;\n        $&lt;TARGET_FILE_DIR:your_target&gt;\n    )\nendif()\n</code></pre> <p>Manual:</p> <ul> <li>Include: <code>clients/c/include/viiper/viiper.h</code></li> <li>Link: <code>clients/c/build/Release/viiper.lib</code> (Windows) or <code>libviiper.a</code> (POSIX)</li> <li>Runtime: Copy <code>viiper.dll</code> next to your executable (Windows)</li> </ul>"},{"location":"clients/c/#quick-start","title":"Quick Start","text":"<pre><code>#include &lt;viiper/viiper.h&gt;\n#include &lt;viiper/viiper_keyboard.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Connect to management API\n    viiper_client_t* client = NULL;\n    int err = viiper_client_create(\"127.0.0.1\", 3242, &amp;client);\n    if (err != 0) {\n        fprintf(stderr, \"Failed to connect: %s\\n\", viiper_strerror(err));\n        return 1;\n    }\n\n    // Create or find a bus\n    viiper_bus_list_response_t buses = {0};\n    err = viiper_bus_list(client, &amp;buses);\n    uint32_t bus_id = (buses.BusesCount &gt; 0) ? buses.Buses[0] : 0;\n\n    if (bus_id == 0) {\n        viiper_bus_create_response_t resp = {0};\n        uint32_t desired_id = 1;\n        err = viiper_bus_create(client, &amp;desired_id, &amp;resp); // NULL for auto-assign\n        bus_id = resp.BusID;\n    }\n\n    // Add device and connect (convenience function)\n    const char* device_type = \"keyboard\";\n    viiper_device_create_request_t req = {\n        .Type = &amp;device_type,\n        .IdVendor = NULL,\n        .IdProduct = NULL\n    };\n    viiper_device_info_t dev_info = {0};\n    viiper_device_t* device = NULL;\n    err = viiper_add_device_and_connect(client, bus_id, &amp;req, &amp;dev_info, &amp;device);\n\n    // Send keyboard input\n    viiper_keyboard_input_t input = {\n        .modifiers = 0,\n        .count = 1\n    };\n    uint8_t keys[] = {VIIPER_KEYBOARD_KEY_A};\n    input.keys = keys;\n    input.keys_count = 1;\n\n    err = viiper_device_send(device, &amp;input, sizeof(input.modifiers) + sizeof(input.count) + input.keys_count);\n\n    // Cleanup\n    viiper_device_close(device);\n\n    char bus_id_str[32];\n    snprintf(bus_id_str, sizeof(bus_id_str), \"%u\", bus_id);\n    viiper_device_remove_response_t remove_resp = {0};\n    viiper_bus_device_remove(client, bus_id_str, dev_info.DevId, &amp;remove_resp);\n\n    viiper_client_free(client);\n    return 0;\n}\n</code></pre>"},{"location":"clients/c/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/c/#creating-a-device-stream","title":"Creating a Device Stream","text":"<p>Manual approach (add device, then connect):</p> <pre><code>// Add device first\nconst char* device_type = \"keyboard\";\nviiper_device_create_request_t req = {\n    .Type = &amp;device_type,\n    .IdVendor = NULL,  // Optional: set to specify custom VID\n    .IdProduct = NULL  // Optional: set to specify custom PID\n};\n\nchar bus_id_str[32];\nsnprintf(bus_id_str, sizeof(bus_id_str), \"%u\", bus_id);\n\nviiper_device_info_t dev_info = {0};\nviiper_error_t err = viiper_bus_device_add(client, bus_id_str, &amp;req, &amp;dev_info);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to add device: %s\\n\", viiper_get_error(client));\n}\n\n// Then connect to its stream\nviiper_device_t* device = NULL;\nerr = viiper_open_stream(client, bus_id, dev_info.DevId, &amp;device);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to open device stream: %s\\n\", viiper_get_error(client));\n}\n</code></pre> <p>Convenience approach (add and connect in one call):</p> <pre><code>const char* device_type = \"xbox360\";\nviiper_device_create_request_t req = {\n    .Type = &amp;device_type,\n    .IdVendor = NULL,\n    .IdProduct = NULL\n};\n\nviiper_device_info_t dev_info = {0};\nviiper_device_t* device = NULL;\nviiper_error_t err = viiper_add_device_and_connect(client, bus_id, &amp;req, &amp;dev_info, &amp;device);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to add and connect device: %s\\n\", viiper_get_error(client));\n}\n</code></pre>"},{"location":"clients/c/#sending-input","title":"Sending Input","text":"<pre><code>viiper_mouse_input_t input = {\n    .buttons = VIIPER_MOUSE_BTN_LEFT,\n    .dx = 10,\n    .dy = -5,\n    .wheel = 0,\n    .pan = 0\n};\n\nint err = viiper_device_send(device, &amp;input, sizeof(input));\n</code></pre>"},{"location":"clients/c/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<pre><code>void on_led_update(void* user_data, const void* data, size_t len) {\n    if (len &lt; 1) return;\n    uint8_t leds = ((uint8_t*)data)[0];\n    printf(\"LEDs: NumLock=%d CapsLock=%d ScrollLock=%d\\n\",\n           !!(leds &amp; VIIPER_KEYBOARD_LED_NUM_LOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LED_CAPS_LOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LED_SCROLL_LOCK));\n}\n\nviiper_device_on_output(device, on_led_update, NULL);\n</code></pre>"},{"location":"clients/c/#closing-a-stream","title":"Closing a Stream","text":"<pre><code>viiper_device_close(device);\n</code></pre>"},{"location":"clients/c/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific packet formats, constants, and wire protocols. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The C SDK provides generated structs and constants in device-specific headers (e.g., <code>viiper_keyboard.h</code>, <code>viiper_mouse.h</code>, <code>viiper_xbox360.h</code>).</p>"},{"location":"clients/c/#struct-packing","title":"Struct Packing","text":"<p>All device I/O structs use <code>#pragma pack(1)</code> to ensure wire compatibility (no padding).</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t buttons;\n    int8_t dx;\n    // ...\n} viiper_mouse_input_t;\n#pragma pack(pop)\n</code></pre> <p>Important: Always ensure your compiler respects packing directives. MSVC and GCC/Clang handle this correctly by default.</p>"},{"location":"clients/c/#troubleshooting","title":"Troubleshooting","text":""},{"location":"clients/c/#missing-dll-on-windows","title":"Missing DLL on Windows","text":"<p>Symptom: Application crashes immediately with \"viiper.dll not found\"</p> <p>Solution: Copy <code>viiper.dll</code> to the same directory as your executable:</p> <pre><code>add_custom_command(TARGET your_target POST_BUILD\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    $&lt;TARGET_FILE:viiper&gt;\n    $&lt;TARGET_FILE_DIR:your_target&gt;\n)\n</code></pre>"},{"location":"clients/c/#repeated-keys-not-working","title":"Repeated Keys Not Working","text":"<p>Symptom: Typing \"Hello\" outputs \"Helo\" (missing duplicate letter)</p> <p>Solution: Add sufficient delays between key press, release, and next action:</p> <pre><code>press_and_release(dev, VIIPER_KEYBOARD_KEY_L, 0);\nSleep(100);\npress_and_release(dev, VIIPER_KEYBOARD_KEY_L, 0);\n</code></pre>"},{"location":"clients/c/#struct-padding-issues","title":"Struct Padding Issues","text":"<p>Symptom: Device input is corrupted or \"spazzing\"</p> <p>Solution: Verify <code>#pragma pack(1)</code> is applied to device structs. All generated headers include this by default.</p>"},{"location":"clients/c/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/c/virtual_keyboard/main.c</code></li> <li>Types \"Hello!\" every 5 seconds</li> <li> <p>Reads LED state (NumLock, CapsLock, ScrollLock)</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/c/virtual_x360_pad/main.c</code></p> </li> <li>Simulates button presses and stick movements</li> <li>Receives rumble feedback</li> </ul> <p>Build and run:</p> <pre><code>cd examples/c\ncmake -B build -G \"Visual Studio 17 2022\"\ncmake --build build --config Release\n./build/Release/virtual_keyboard.exe 127.0.0.1:3242\n</code></pre>"},{"location":"clients/c/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How the C SDK is generated</li> <li>Go Client Documentation: Reference implementation</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"clients/csharp/","title":"C# SDK Documentation","text":"<p>The VIIPER C# SDK provides a modern, type-safe .NET client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/csharp/#overview","title":"Overview","text":"<p>The C# SDK features:</p> <ul> <li>Async/await support: Full async API with cancellation token support</li> <li>Type-safe: Generated classes with enums, structs, and helper maps</li> <li>Event-driven: <code>OnOutput</code> event for device feedback (LEDs, rumble)</li> <li>Modern .NET: Targets .NET 8.0 with nullable reference types</li> <li>Zero external dependencies: Uses only built-in .NET libraries</li> </ul> <p>License</p> <p>The C# SDK is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/csharp/#installation","title":"Installation","text":""},{"location":"clients/csharp/#1-using-the-published-nuget-package-recommended","title":"1. Using the Published NuGet Package (Recommended)","text":"<p>Install the stable package:</p> <pre><code>dotnet add package Viiper.Client\n</code></pre> <p>Package page: Viiper.Client on NuGet</p> <p>Pre-release / snapshot builds are not published to NuGet. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p> <p>To use a snapshot <code>.nupkg</code> from a GitHub Release:</p> <pre><code># 1. Download viiper-csharp-sdk-nupkg-Release.nupkg (or Snapshot) to ./packages\nmkdir -p packages\ncp /path/to/downloaded/viiper-csharp-sdk-nupkg.nupkg packages/\n\n# 2. Add a temporary local source and install\ndotnet nuget add source ./packages --name viiper-local || true\ndotnet add package Viiper.Client --source viiper-local\n</code></pre> <p>Or add directly in your <code>.csproj</code> (stable only):</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Viiper.Client\" Version=\"*\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#2-project-reference-for-local-development-against-source","title":"2. Project Reference (For Local Development Against Source)","text":"<p>Use this when modifying the generator or contributing new device types:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;ProjectReference Include=\"..\\..\\clients\\csharp\\Viiper.Client\\Viiper.Client.csproj\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#3-generating-from-source-advanced-contributors","title":"3. Generating from Source (Advanced / Contributors)","text":"<p>Only required when enhancing VIIPER itself:</p> <pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=csharp\ncd ../clients/csharp\ndotnet build -c Release Viiper.Client\n</code></pre>"},{"location":"clients/csharp/#quick-start","title":"Quick Start","text":"<pre><code>using Viiper.Client;\nusing Viiper.Client.Devices.Keyboard;\n\n// Connect to management API\nvar client = new ViiperClient(\"localhost\", 3242);\n\n// Find or create a bus\nvar buses = await client.BusListAsync();\nuint busId;\nif (buses.Buses.Length == 0)\n{\n    var resp = await client.BusCreateAsync(null); // null = auto-assign ID\n    // Or specify ID: await client.BusCreateAsync(5);\n    busId = resp.BusID;\n}\nelse\n{\n    busId = buses.Buses[0];\n}\n\n// Add device and connect\nvar deviceReq = new DeviceCreateRequest { Type = \"keyboard\" };\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n\nConsole.WriteLine($\"Connected to device {deviceResp.BusID}-{deviceResp.DevId}\");\n\n// Send keyboard input\nvar input = new KeyboardInput\n{\n    Modifiers = (byte)Mod.LeftShift,\n    Count = 1,\n    Keys = new[] { (byte)Key.H }\n};\nawait device.SendAsync(input);\n\n// Cleanup\nawait client.BusDeviceRemoveAsync(busId, deviceResp.DevId);\n</code></pre>"},{"location":"clients/csharp/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/csharp/#creating-a-device-stream","title":"Creating a Device Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>var deviceReq = new DeviceCreateRequest { Type = \"xbox360\" };\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n</code></pre> <p>With custom VID/PID:</p> <pre><code>var deviceReq = new DeviceCreateRequest { \n    Type = \"keyboard\", \n    IdVendor = 0x1234, \n    IdProduct = 0x5678 \n};\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>var device = await client.ConnectDeviceAsync(busId, deviceId);\n</code></pre>"},{"location":"clients/csharp/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated structs with async methods:</p> <pre><code>using Viiper.Client.Devices.Xbox360;\n\nvar input = new Xbox360Input\n{\n    Buttons = (uint)Button.A,\n    LeftTrigger = 255,\n    RightTrigger = 0,\n    ThumbLX = -32768,  // Left stick left\n    ThumbLY = 32767,   // Left stick up\n    ThumbRX = 0,\n    ThumbRY = 0\n};\nawait device.SendAsync(input);\n</code></pre>"},{"location":"clients/csharp/#receiving-output-events","title":"Receiving Output (Events)","text":"<p>For devices that send feedback (rumble, LEDs), subscribe to the <code>OnOutput</code> event:</p> <pre><code>using Viiper.Client.Devices.Keyboard;\n\ndevice.OnOutput += data =&gt;\n{\n    if (data.Length &lt; 1) return;\n    byte leds = data[0];\n\n    Console.WriteLine($\"LEDs: \" +\n        $\"Num={(leds &amp; (byte)LED.NumLock) != 0} \" +\n        $\"Caps={(leds &amp; (byte)LED.CapsLock) != 0} \" +\n        $\"Scroll={(leds &amp; (byte)LED.ScrollLock) != 0}\");\n};\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>using Viiper.Client.Devices.Xbox360;\n\ndevice.OnOutput += data =&gt;\n{\n    if (data.Length &lt; 2) return;\n    byte leftMotor = data[0];\n    byte rightMotor = data[1];\n    Console.WriteLine($\"Rumble: Left={leftMotor} Right={rightMotor}\");\n};\n</code></pre>"},{"location":"clients/csharp/#closing-a-device","title":"Closing a Device","text":"<pre><code>device.Dispose();\n// or\nawait using var device = await client.ConnectDeviceAsync(busId, deviceId);\n</code></pre>"},{"location":"clients/csharp/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The C# SDK automatically generates enums and helper maps for each device type.</p>"},{"location":"clients/csharp/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Enum:</p> <pre><code>using Viiper.Client.Devices.Keyboard;\n\nvar key = Key.A;               // 0x04\nvar f1 = Key.F1;               // 0x3A\nvar enter = Key.Enter;         // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>var mods = (byte)(Mod.LeftShift | Mod.LeftCtrl);  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>bool numLock = (leds &amp; (byte)LED.NumLock) != 0;\nbool capsLock = (leds &amp; (byte)LED.CapsLock) != 0;\n</code></pre>"},{"location":"clients/csharp/#helper-maps","title":"Helper Maps","text":"<p>The SDK generates useful lookup maps for working with keyboard input:</p> <p>CharToKey Map - Convert ASCII characters to key codes:</p> <pre><code>if (CharToKey.TryGetValue((byte)'A', out var key))\n{\n    Console.WriteLine($\"'A' maps to {key}\");  // Key.A\n}\n</code></pre> <p>KeyName Map - Get human-readable key names:</p> <pre><code>if (KeyName.TryGetValue((byte)Key.F1, out var name))\n{\n    Console.WriteLine($\"Key name: {name}\");  // \"F1\"\n}\n</code></pre> <p>ShiftChars Map - Check if a character requires shift:</p> <pre><code>bool needsShift = ShiftChars.ContainsKey((byte)'A');  // true for uppercase\n</code></pre>"},{"location":"clients/csharp/#practical-example-typing-text","title":"Practical Example: Typing Text","text":"<p>Using the generated maps to type a string:</p> <pre><code>async Task TypeString(ViiperDevice device, string text)\n{\n    foreach (char c in text)\n    {\n        if (!CharToKey.TryGetValue((byte)c, out var key))\n            continue;\n\n        byte mods = ShiftChars.ContainsKey((byte)c) \n            ? (byte)Mod.LeftShift \n            : (byte)0;\n\n        // Press\n        await device.SendAsync(new KeyboardInput\n        {\n            Modifiers = mods,\n            Count = 1,\n            Keys = new[] { (byte)key }\n        });\n        await Task.Delay(50);\n\n        // Release\n        await device.SendAsync(new KeyboardInput\n        {\n            Modifiers = 0,\n            Count = 0,\n            Keys = Array.Empty&lt;byte&gt;()\n        });\n        await Task.Delay(50);\n    }\n}\n\n// Usage\nawait TypeString(device, \"Hello, World!\");\n</code></pre>"},{"location":"clients/csharp/#device-specific-wire-formats","title":"Device-Specific Wire Formats","text":""},{"location":"clients/csharp/#keyboard-input","title":"Keyboard Input","text":"<pre><code>public struct KeyboardInput\n{\n    public byte Modifiers;    // Modifier flags (Ctrl, Shift, Alt, GUI)\n    public byte Count;        // Number of keys in Keys array\n    public byte[] Keys;       // Key codes (max 6 for HID compliance)\n}\n</code></pre> <p>Wire format: 1 byte modifiers + 1 byte count + N bytes keys (variable-length)</p>"},{"location":"clients/csharp/#keyboard-output-leds","title":"Keyboard Output (LEDs)","text":"<pre><code>// Single byte with LED flags\nbyte leds = data[0];\nbool numLock = (leds &amp; (byte)LED.NumLock) != 0;\n</code></pre>"},{"location":"clients/csharp/#xbox360-input","title":"Xbox360 Input","text":"<pre><code>public struct Xbox360Input\n{\n    public ushort Buttons;     // Button flags\n    public byte LeftTrigger;   // 0-255\n    public byte RightTrigger;  // 0-255\n    public short ThumbLX;      // -32768 to 32767\n    public short ThumbLY;      // -32768 to 32767\n    public short ThumbRX;      // -32768 to 32767\n    public short ThumbRY;      // -32768 to 32767\n}\n</code></pre> <p>Wire format: Fixed 14 bytes, packed structure</p>"},{"location":"clients/csharp/#xbox360-output-rumble","title":"Xbox360 Output (Rumble)","text":"<pre><code>// Two bytes: left motor + right motor (0-255 each)\nbyte leftMotor = data[0];\nbyte rightMotor = data[1];\n</code></pre>"},{"location":"clients/csharp/#mouse-input","title":"Mouse Input","text":"<pre><code>public struct MouseInput\n{\n    public byte Buttons;  // Button flags\n    public sbyte X;       // Relative X movement (-128 to 127)\n    public sbyte Y;       // Relative Y movement (-128 to 127)\n    public sbyte Wheel;   // Vertical scroll\n    public sbyte Pan;     // Horizontal scroll\n}\n</code></pre> <p>Wire format: Fixed 5 bytes, packed structure</p>"},{"location":"clients/csharp/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/csharp/#custom-timeouts","title":"Custom Timeouts","text":"<pre><code>var client = new ViiperClient(\"localhost\", 3242)\n{\n    Timeout = TimeSpan.FromSeconds(10)\n};\n</code></pre> <p>Default timeout is 5 seconds.</p>"},{"location":"clients/csharp/#cancellation-tokens","title":"Cancellation Tokens","text":"<p>All async methods support cancellation:</p> <pre><code>using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));\n\ntry\n{\n    var buses = await client.BusListAsync(cts.Token);\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Request timed out\");\n}\n</code></pre>"},{"location":"clients/csharp/#error-handling","title":"Error Handling","text":"<p>The server returns errors as JSON. The client throws exceptions:</p> <pre><code>try\n{\n    await client.BusCreateAsync(\"invalid-bus-id\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Request failed: {ex.Message}\");\n}\n</code></pre>"},{"location":"clients/csharp/#resource-management","title":"Resource Management","text":"<p><code>ViiperDevice</code> implements <code>IDisposable</code>:</p> <pre><code>await using var device = await client.ConnectDeviceAsync(busId, deviceId);\n// Device automatically closed when scope exits\n</code></pre> <p>Or manual cleanup:</p> <pre><code>try\n{\n    var device = await client.ConnectDeviceAsync(busId, deviceId);\n    // ... use device ...\n}\nfinally\n{\n    device.Dispose();\n}\n</code></pre>"},{"location":"clients/csharp/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/csharp/virtual_keyboard/Program.cs</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/csharp/virtual_mouse/Program.cs</code></p> </li> <li>Moves cursor in a circle pattern</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/csharp/virtual_x360_pad/Program.cs</code></p> </li> <li>Presses buttons and moves sticks</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/csharp/#running-examples","title":"Running Examples","text":"<pre><code>cd examples/csharp/virtual_keyboard\ndotnet run -- localhost\n</code></pre>"},{"location":"clients/csharp/#project-structure","title":"Project Structure","text":"<p>Generated SDK layout:</p> <pre><code>clients/csharp/Viiper.Client/\n\u251c\u2500\u2500 ViiperClient.cs              # Management API client\n\u251c\u2500\u2500 ViiperDevice.cs              # Device stream wrapper\n\u251c\u2500\u2500 Types/\n\u2502   \u251c\u2500\u2500 BusListResponse.cs       # API response types\n\u2502   \u251c\u2500\u2500 BusCreateResponse.cs\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 Devices/\n    \u251c\u2500\u2500 Keyboard/\n    \u2502   \u251c\u2500\u2500 KeyboardInput.cs     # Wire format struct\n    \u2502   \u2514\u2500\u2500 KeyboardConstants.cs # Enums + maps\n    \u251c\u2500\u2500 Mouse/\n    \u2502   \u251c\u2500\u2500 MouseInput.cs\n    \u2502   \u2514\u2500\u2500 MouseConstants.cs\n    \u2514\u2500\u2500 Xbox360/\n        \u251c\u2500\u2500 Xbox360Input.cs\n        \u251c\u2500\u2500 Xbox360Output.cs\n        \u2514\u2500\u2500 Xbox360Constants.cs\n</code></pre>"},{"location":"clients/csharp/#troubleshooting","title":"Troubleshooting","text":"<p>Build Errors:</p> <p>Ensure you have .NET 8.0 SDK installed: <pre><code>dotnet --version  # Should be 8.0 or higher\n</code></pre> Nullable Reference Warnings:</p> <p>The generated code uses nullable annotations. You may see warnings like CS8601/CS8625. These are safe to ignore or suppress in your project file:</p> <pre><code>&lt;PropertyGroup&gt;\n  &lt;NoWarn&gt;$(NoWarn);CS8601;CS8625&lt;/NoWarn&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated SDKs work</li> <li>Go SDK Documentation: Reference implementation patterns</li> <li>C SDK Documentation: Alternative SDK for native integration</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"clients/generator/","title":"VIIPER Client Generator Documentation","text":""},{"location":"clients/generator/#overview","title":"Overview","text":"<p>The VIIPER client generator scans Go source code to extract API routes, device wire formats, and constants; then emits type-safe client SDKs for multiple languages.</p> <p>What it extracts:</p> <ul> <li>API routes and DTOs from management API handlers  </li> <li>Device wire formats from <code>viiper:wire</code> comment tags  </li> <li>All exported constants from device packages (automatic)</li> </ul> <p>Output: Type-safe client SDKs for multiple target languages</p> <p>License</p> <p>All generated client SDKs are licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/generator/#running-the-generator","title":"Running the Generator","text":"<pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=all     # Generate all SDKs\ngo run ./cmd/viiper codegen --lang=c       # Generate C SDK only\ngo run ./cmd/viiper codegen --lang=csharp  # Generate C# SDK only\ngo run ./cmd/viiper codegen --lang=typescript # Generate TypeScript SDK only\n</code></pre> <p>Output directory: <code>clients/</code> (relative to repository root)</p>"},{"location":"clients/generator/#comment-tag-system","title":"Comment Tag System","text":"<p>The generator uses lightweight comment tags placed next to device types and constants.</p>"},{"location":"clients/generator/#viiperwire-device-stream-formats","title":"<code>viiper:wire</code>: Device Stream Formats","text":"<p>Syntax:</p> <pre><code>// viiper:wire &lt;device&gt; &lt;direction&gt; &lt;field1:type&gt; &lt;field2:type&gt; ...\n</code></pre> <p>Directions: </p> <ul> <li><code>c2s</code>: Client to server (input)  </li> <li><code>s2c</code>: Server to client (output, e.g., rumble, LEDs)</li> </ul> <p>Field types: </p> <ul> <li>Fixed: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code> </li> <li>Variable: <code>u8*countField</code> (pointer to count field)</li> </ul> <p>Example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct { ... }\n</code></pre>"},{"location":"clients/generator/#constant-and-map-export","title":"Constant and Map Export","text":"<p>The generator automatically exports all constants and map literals from <code>pkg/device/*/const.go</code> for each device type. No special tags are required. Exported Go constants and maps are emitted with language-appropriate representations:</p> <ul> <li>Constants: Grouped into enums (C#/TS) or <code>#define</code> macros (C) based on common prefixes</li> <li>Maps: Converted to Dictionary/Map/lookup functions with helper methods</li> </ul>"},{"location":"clients/generator/#code-generation-flow","title":"Code Generation Flow","text":"<p>Scan Phase: </p> <ol> <li>Parse API routes from <code>internal/server/api/*.go</code> </li> <li>Reflect response DTOs from <code>pkg/apitypes/*.go</code> </li> <li>Find device types via <code>RegisterDevice()</code> calls  </li> <li>Parse <code>viiper:wire</code> comments for packet layouts  </li> <li>Extract all exported constants and map literals from <code>pkg/device/*/const.go</code> (automatic)</li> </ol> <p>Emit Phase: For each language, generate management client, DTO types, device streams, constants, and build configs.</p> <p>Post-Process: Optional formatting with <code>clang-format</code>, <code>dotnet format</code>, or <code>prettier</code>.</p>"},{"location":"clients/generator/#wire-format-mapping-rules","title":"Wire Format Mapping Rules","text":""},{"location":"clients/generator/#fixed-size-fields","title":"Fixed-Size Fields","text":"<p>Fixed-size fields are mapped to native integer types in each target language:</p> <ul> <li><code>u8</code> / <code>i8</code>: 8-bit unsigned/signed integers</li> <li><code>u16</code> / <code>i16</code>: 16-bit unsigned/signed integers</li> <li><code>u32</code> / <code>i32</code>: 32-bit unsigned/signed integers</li> </ul>"},{"location":"clients/generator/#variable-length-fields","title":"Variable-Length Fields","text":"<p>Variable-length arrays use a pointer + count pattern. The field syntax <code>u8*count</code> references a count field that determines the array length.</p> <p>Wire tag example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\n</code></pre> <p>Each target language emits appropriate types for dynamic arrays (pointers with counts, managed arrays, or typed arrays depending on the language).</p>"},{"location":"clients/generator/#struct-packing","title":"Struct Packing","text":"<p>For wire compatibility, all device I/O structs are tightly packed (no padding).</p> <ul> <li>C: <code>#pragma pack(push, 1)</code> / <code>#pragma pack(pop)</code></li> <li>C#: <code>[StructLayout(LayoutKind.Sequential, Pack = 1)]</code></li> <li>TypeScript: Manual byte-level encoding/decoding</li> </ul>"},{"location":"clients/generator/#example-keyboard-input-variable-length","title":"Example: Keyboard Input (Variable-Length)","text":"<p>Go source with wire tag:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct {\n    Modifiers uint8\n    KeyBitmap [32]uint8  // Internal: 256-bit NKR bitmap\n}\n</code></pre> <p>Emitted C struct:</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t modifiers;\n    uint8_t count;\n    uint8_t* keys;\n    size_t keys_count;\n} viiper_keyboard_input_t;\n#pragma pack(pop)\n</code></pre>"},{"location":"clients/generator/#example-constant-and-map-export","title":"Example: Constant and Map Export","text":"<p>Go source (<code>pkg/device/keyboard/const.go</code>):</p> <pre><code>const (\n    ModLeftCtrl  = 0x01\n    ModLeftShift = 0x02\n    KeyA = 0x04\n    KeyB = 0x05\n    // ...\n)\n\nvar CharToKey = map[byte]byte{\n    'a': KeyA,\n    'b': KeyB,\n    '\\n': KeyEnter,\n    // ...\n}\n</code></pre> <p>Emitted C header (<code>viiper_keyboard.h</code>):</p> <pre><code>#define VIIPER_KEYBOARD_MOD_LEFT_CTRL 0x1\n#define VIIPER_KEYBOARD_MOD_LEFT_SHIFT 0x2\n#define VIIPER_KEYBOARD_KEY_A 0x4\n#define VIIPER_KEYBOARD_KEY_B 0x5\n\n// Map lookup function\nint viiper_keyboard_char_to_key_lookup(uint8_t key, uint8_t* out_value);\n</code></pre> <p>Emitted C# (<code>KeyboardConstants.cs</code>):</p> <pre><code>public enum Mod : uint\n{\n    LeftCtrl = 0x01,\n    LeftShift = 0x02,\n    // ...\n}\n\npublic enum Key : uint\n{\n    A = 0x04,\n    B = 0x05,\n    // ...\n}\n\npublic static class CharToKey\n{\n    private static readonly Dictionary&lt;byte, Key&gt; _map = new()\n    {\n        { (byte)'a', Key.A },\n        { (byte)'b', Key.B },\n        { (byte)'\\n', Key.Enter },\n        // ...\n    };\n\n    public static bool TryGetValue(byte key, out Key value)\n    {\n        return _map.TryGetValue(key, out value);\n    }\n}\n</code></pre>"},{"location":"clients/generator/#regeneration-triggers","title":"Regeneration Triggers","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>pkg/apitypes/*.go</code>: API response structures</li> <li><code>pkg/device/*/inputstate.go</code>: Wire tag annotations</li> <li><code>pkg/device/*/const.go</code>: Exported constants and map literals</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li><code>internal/codegen/generator/**/*.go</code>: Generator templates</li> <li><code>internal/codegen/scanner/**/*.go</code>: Scanner logic (constants, maps, wire tags)</li> </ul>"},{"location":"clients/generator/#language-specific-notes","title":"Language-Specific Notes","text":"<ul> <li>C: <code>#define</code> macros for constants; switch-based lookup functions for maps; manual memory management for variable-length fields; builds with CMake.  </li> <li>C#: Enums for constant groups; <code>Dictionary&lt;K,V&gt;</code> with static helper methods for maps; <code>ViiperDevice</code> class with <code>OnOutput</code> event; async/await for management API; struct packing via attributes.  </li> <li>TypeScript: Enums for constant groups; <code>Record&lt;K, V&gt;</code> objects with <code>Get</code>/<code>Has</code> helper functions for maps; manual byte encoding via <code>BinaryWriter</code>/<code>BinaryReader</code>; <code>ViiperDevice</code> class with EventEmitter for output; <code>addDeviceAndConnect</code> convenience method; builds with <code>tsc</code>.  </li> </ul>"},{"location":"clients/generator/#further-reading","title":"Further Reading","text":"<ul> <li>Design Document: Architectural rationale and detailed generation strategy</li> <li>Go Client Documentation: Go reference client usage</li> <li>C SDK Documentation: C-specific usage, build, and examples</li> <li>C# SDK Documentation: C#-specific usage, async patterns, and map helpers</li> <li>TypeScript SDK Documentation: TypeScript-specific usage, EventEmitter patterns, and examples</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"clients/go/","title":"Go Client Documentation","text":"<p>The Go client is the reference implementation for interacting with VIIPER servers. It's included in the repository under <code>pkg/apiclient</code> and <code>pkg/device</code>.</p>"},{"location":"clients/go/#overview","title":"Overview","text":"<p>The Go client features:</p> <ul> <li>Type-safe API: Structured request/response types with context support</li> <li>Device streams: Bidirectional communication using <code>encoding.BinaryMarshaler</code>/<code>BinaryUnmarshaler</code></li> <li>Built-in: No code generation needed; part of the main repository</li> <li>Flexible timeouts: Configurable connection and I/O timeouts</li> </ul>"},{"location":"clients/go/#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n  \"context\"\n  \"log\"\n  \"time\"\n\n  apiclient \"viiper/pkg/apiclient\"\n  \"viiper/pkg/device\"\n  \"viiper/pkg/device/keyboard\"\n)\n\nfunc main() {\n  // Connect to management API\n  client := apiclient.New(\"127.0.0.1:3242\")\n  ctx := context.Background()\n\n  // Create or find a bus\n  buses, err := client.BusList()\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  var busID uint32\n  if len(buses) &gt; 0 {\n    busID = buses[0]\n  } else {\n    resp, err := client.BusCreate(nil)\n    if err != nil {\n      log.Fatal(err)\n    }\n    busID = resp.BusID\n  }\n\n  // Add device and connect (optional CreateOptions parameter for VID/PID)\n  // Pass nil to use default VID/PID for the device type.\n  stream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"keyboard\", nil)\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer stream.Close()\n\n  log.Printf(\"Connected to device %s\", resp.ID)\n\n  // Send keyboard input\n  input := &amp;keyboard.InputState{\n    Modifiers: keyboard.ModLeftShift,\n  }\n  input.SetKey(keyboard.KeyH, true)\n\n  if err := stream.WriteBinary(input); err != nil {\n    log.Fatal(err)\n  }\n\n  time.Sleep(100 * time.Millisecond)\n\n  // Release\n  input = &amp;keyboard.InputState{}\n  stream.WriteBinary(input)\n}\n</code></pre>"},{"location":"clients/go/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/go/#creating-and-connecting","title":"Creating and Connecting","text":"<p>// The simplest way to add a device and open its stream (nil opts):</p> <pre><code>// Use default VID/PID for the device type\nstream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"xbox360\", nil)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream.Close()\n\nlog.Printf(\"Connected to device %s\", resp.ID)\n</code></pre> <p>// Or specify VID/PID using CreateOptions:</p> <pre><code>opts := &amp;device.CreateOptions{\n  IdVendor:  func() *uint16 { v := uint16(0x1234); return &amp;v }(),\n  IdProduct: func() *uint16 { p := uint16(0x5678); return &amp;p }(),\n}\nstream2, resp2, err := client.AddDeviceAndConnect(ctx, busID, \"keyboard\", opts)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream2.Close()\n\nlog.Printf(\"Connected to device %s (custom VID/PID)\", resp2.ID)\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>stream, err := client.OpenStream(ctx, busID, deviceID)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream.Close()\n</code></pre>"},{"location":"clients/go/#sending-input","title":"Sending Input","text":"<p>Device input is sent using structs that implement <code>encoding.BinaryMarshaler</code>:</p> <pre><code>import \"viiper/pkg/device/xbox360\"\n\ninput := &amp;xbox360.InputState{\n  Buttons: xbox360.ButtonA,\n  LX:      -32768, // Left stick left\n  LY:      32767,  // Left stick up\n}\nif err := stream.WriteBinary(input); err != nil {\n  log.Fatal(err)\n}\n</code></pre>"},{"location":"clients/go/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<p>For devices that send feedback (rumble, LEDs), use <code>StartReading</code> with a decode function:</p> <pre><code>import (\n  \"bufio\"\n  \"encoding\"\n  \"io\"\n  \"viiper/pkg/device/xbox360\"\n)\n\n// Start async reading for rumble commands\nrumbleCh, errCh := stream.StartReading(ctx, 10, func(r *bufio.Reader) (encoding.BinaryUnmarshaler, error) {\n  var b [2]byte\n  if _, err := io.ReadFull(r, b[:]); err != nil { return nil, err }\n  msg := new(xbox360.XRumbleState)\n  if err := msg.UnmarshalBinary(b[:]); err != nil { return nil, err }\n  return msg, nil\n})\n\ngo func() {\n  for {\n    select {\n    case msg := &lt;-rumbleCh:\n      rumble := msg.(*xbox360.XRumbleState)\n      fmt.Printf(\"Rumble: Left=%d Right=%d\\n\", rumble.LeftMotor, rumble.RightMotor)\n    case err := &lt;-errCh:\n      if err != nil { log.Printf(\"Stream error: %v\", err) }\n      return\n    }\n  }\n}()\n</code></pre>"},{"location":"clients/go/#closing-a-stream","title":"Closing a Stream","text":"<pre><code>stream.Close()\n</code></pre>"},{"location":"clients/go/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific wire formats and helper methods. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The Go client provides device packages under <code>pkg/device/</code> with type-safe structs and constants (e.g., <code>keyboard.InputState</code>, <code>keyboard.KeyA</code>, <code>mouse.Btn_Left</code>).</p>"},{"location":"clients/go/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/go/#custom-timeouts","title":"Custom Timeouts","text":"<pre><code>cfg := &amp;apiclient.Config{\n  DialTimeout:  2 * time.Second,\n  ReadTimeout:  3 * time.Second,\n  WriteTimeout: 3 * time.Second,\n}\nclient := apiclient.NewWithConfig(\"127.0.0.1:3242\", cfg)\n</code></pre> <p>Default timeouts are: Dial 3s, Read/Write 5s.</p>"},{"location":"clients/go/#context-aware-calls","title":"Context-Aware Calls","text":"<p>All methods have context-aware variants ending with <code>Ctx</code>:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\nbuses, err := client.BusListCtx(ctx)\n</code></pre>"},{"location":"clients/go/#error-handling","title":"Error Handling","text":"<p>The server returns errors as <code>{ \"error\": \"message\" }</code> JSON. The client wraps these as Go errors:</p> <pre><code>if err != nil {\n  log.Printf(\"request failed: %v\", err)\n}\n</code></pre>"},{"location":"clients/go/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Mouse: <code>examples/virtual_mouse/main.go</code></li> <li>Virtual Keyboard: <code>examples/virtual_keyboard/main.go</code></li> <li>Virtual Xbox360 Controller: <code>examples/virtual_x360_pad/main.go</code></li> </ul>"},{"location":"clients/go/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated SDKs work</li> <li>C SDK Documentation: Generated C SDK usage</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"clients/typescript/","title":"TypeScript SDK Documentation","text":"<p>The VIIPER TypeScript SDK provides a modern, type-safe Node.js client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/typescript/#overview","title":"Overview","text":"<p>The TypeScript SDK features:</p> <ul> <li>Type-safe API: Structured request/response types with proper TypeScript definitions</li> <li>Event-driven: EventEmitter-based output handling for device feedback (LEDs, rumble)</li> <li>Auto-generated: Generated from server code with device-specific Input/Output classes</li> <li>Modern Node.js: Targets Node.js 18+ with ES modules</li> <li>Zero external dependencies: Uses only built-in Node.js libraries</li> </ul> <p>License</p> <p>The TypeScript SDK is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/typescript/#installation","title":"Installation","text":""},{"location":"clients/typescript/#1-using-the-published-npm-package-recommended","title":"1. Using the Published NPM Package (Recommended)","text":"<p>Install the SDK from the public npm registry:</p> <pre><code>npm install viiperclient\n</code></pre> <p>Or with pnpm / yarn:</p> <pre><code>pnpm add viiperclient\n# or\nyarn add viiperclient\n</code></pre> <p>The latest stable version is tagged as <code>latest</code>.</p> <p>Pre-release / snapshot builds are not published to npm. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p> <p>To use a snapshot artifact from GitHub:</p> <ol> <li>Download <code>viiperclient-typescript-sdk-Snapshot.tgz</code> (or a versioned tarball) from the appropriate Release.</li> <li>Install it directly:</li> </ol> <pre><code>npm install ./viiperclient-typescript-sdk-Snapshot.tgz\n</code></pre> <p>Package page: npm: viiperclient</p>"},{"location":"clients/typescript/#2-local-project-reference-for-development-against-source","title":"2. Local Project Reference (For Development Against Source)","text":"<p>If you are actively modifying VIIPER or the code generator, link directly:</p> <pre><code>{\n  \"dependencies\": {\n    \"viiperclient\": \"file:../../clients/typescript\"\n  }\n}\n</code></pre> <p>Then build locally after regeneration:</p> <pre><code>cd clients/typescript\nnpm install\nnpm run build\n</code></pre>"},{"location":"clients/typescript/#3-generating-from-source-advanced-contributors","title":"3. Generating from Source (Advanced / Contributors)","text":"<p>This is only required if you are contributing to VIIPER or adding device types. Normal users should use the npm package.</p> <pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=typescript\ncd ../clients/typescript\nnpm install\nnpm run build\n</code></pre>"},{"location":"clients/typescript/#quick-start","title":"Quick Start","text":"<pre><code>import { ViiperClient, Keyboard } from \"viiperclient\";\n\nconst { KeyboardInput, Key, Mod } = Keyboard;\n\n// Connect to management API\nconst client = new ViiperClient(\"localhost\", 3242);\n\n// Find or create a bus\nconst busesResp = await client.buslist();\nlet busID: number;\nif (busesResp.buses.length === 0) {\n  const resp = await client.buscreate(); // Auto-assign ID\n  // Or specify ID: await client.buscreate(5);\n  busID = resp.busId;\n} else {\n  busID = busesResp.buses[0];\n}\n\n// Add device and connect\nconst deviceReq = { type: \"keyboard\" };\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n\nconsole.log(`Connected to device ${response.busId}-${response.devId}`);\n\n// Send keyboard input\nconst input = new KeyboardInput({\n  Modifiers: Mod.LeftShift,\n  Count: 1,\n  Keys: [Key.H]\n});\nawait device.send(input);\n\n// Cleanup\nawait client.busdeviceremove(busID, response.devId);\n</code></pre>"},{"location":"clients/typescript/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/typescript/#creating-a-device-stream","title":"Creating a Device Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>const deviceReq = { type: \"xbox360\" };\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n</code></pre> <p>With custom VID/PID:</p> <pre><code>const deviceReq = { \n  type: \"keyboard\", \n  idVendor: 0x1234, \n  idProduct: 0x5678 \n};\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n</code></pre> <p>Or manually add and connect:</p> <pre><code>const deviceResp = await client.busdeviceadd(busId, { type: \"keyboard\" });\nconst device = await client.connectDevice(busId, deviceResp.devId);\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>const device = await client.connectDevice(busId, deviceId);\n</code></pre>"},{"location":"clients/typescript/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated classes:</p> <pre><code>import { Xbox360 } from \"viiperclient\";\n\nconst { Xbox360Input, Button } = Xbox360;\n\nconst input = new Xbox360Input({\n  Buttons: Button.A,\n  Lt: 255,\n  Rt: 0,\n  Lx: -32768,  // Left stick left\n  Ly: 32767,   // Left stick up\n  Rx: 0,\n  Ry: 0\n});\nawait device.send(input);\n</code></pre>"},{"location":"clients/typescript/#receiving-output-events","title":"Receiving Output (Events)","text":"<p>For devices that send feedback (rumble, LEDs), subscribe to the <code>output</code> event:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { LED } = Keyboard;\n\ndevice.on(\"output\", (data: Buffer) =&gt; {\n  if (data.length &lt; 1) return;\n  const leds = data.readUInt8(0);\n\n  console.log(`LEDs: ` +\n    `Num=${(leds &amp; LED.NumLock) !== 0} ` +\n    `Caps=${(leds &amp; LED.CapsLock) !== 0} ` +\n    `Scroll=${(leds &amp; LED.ScrollLock) !== 0}`);\n});\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>device.on(\"output\", (data: Buffer) =&gt; {\n  if (data.length &lt; 2) return;\n  const leftMotor = data.readUInt8(0);\n  const rightMotor = data.readUInt8(1);\n  console.log(`Rumble: Left=${leftMotor} Right=${rightMotor}`);\n});\n</code></pre>"},{"location":"clients/typescript/#closing-a-device","title":"Closing a Device","text":"<pre><code>device.close();\n</code></pre>"},{"location":"clients/typescript/#error-handling-and-events","title":"Error Handling and Events","text":"<p>Device streams emit <code>error</code> and <code>end</code> events that should be handled:</p> <pre><code>device.on(\"error\", async (err: Error) =&gt; {\n  console.error(`Stream error: ${err}`);\n  // Handle error and cleanup\n});\n\ndevice.on(\"end\", async () =&gt; {\n  console.log(\"Stream ended by server\");\n  // Handle disconnection and cleanup\n});\n</code></pre> <p>For long-running applications with intervals or timers, stop them before cleanup:</p> <pre><code>let running = true;\nconst interval = setInterval(async () =&gt; {\n  if (!running) return;\n\n  try {\n    await device.send(input);\n  } catch (err) {\n    console.error(`Send error: ${err}`);\n    running = false;\n    clearInterval(interval);\n    // Cleanup...\n  }\n}, 16);\n\n// Handle Ctrl+C gracefully\nprocess.on(\"SIGINT\", async () =&gt; {\n  console.log(\"Stopping...\");\n  running = false;\n  clearInterval(interval);\n  device.close();\n  await client.busdeviceremove(busId, deviceId);\n  process.exit(0);\n});\n</code></pre>"},{"location":"clients/typescript/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The TypeScript SDK automatically generates enums and helper maps for each device type.</p>"},{"location":"clients/typescript/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Enum:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { Key } = Keyboard;\n\nconst key = Key.A;               // 0x04\nconst f1 = Key.F1;               // 0x3A\nconst enter = Key.Enter;         // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { Mod } = Keyboard;\n\nconst mods = Mod.LeftShift | Mod.LeftCtrl;  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { LED } = Keyboard;\n\nconst { LED } = Keyboard;\n\nconst numLock = (leds &amp; LED.NumLock) !== 0;\nconst capsLock = (leds &amp; LED.CapsLock) !== 0;\n</code></pre>"},{"location":"clients/typescript/#helper-maps","title":"Helper Maps","text":"<p>The SDK generates useful lookup maps for working with keyboard input:</p> <p>CharToKey Map - Convert ASCII characters to key codes:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { CharToKeyGet } = Keyboard;\n\nconst key = CharToKeyGet('A'.codePointAt(0)!);\nif (key !== undefined) {\n  console.log(`'A' maps to ${key}`);  // Key.A\n}\n</code></pre> <p>KeyName Map - Get human-readable key names:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { KeyNameGet } = Keyboard;\n\nconst name = KeyNameGet(Key.F1);\nif (name !== undefined) {\n  console.log(`Key name: ${name}`);  // \"F1\"\n}\n</code></pre> <p>ShiftChars Map - Check if a character requires shift:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { ShiftCharsHas } = Keyboard;\n\nconst needsShift = ShiftCharsHas('A'.codePointAt(0)!);  // true for uppercase\n</code></pre>"},{"location":"clients/typescript/#practical-example-typing-text","title":"Practical Example: Typing Text","text":"<p>Using the generated maps to type a string:</p> <pre><code>import { ViiperDevice, Keyboard } from \"viiperclient\";\n\nconst { KeyboardInput, CharToKeyGet, ShiftCharsHas, Mod } = Keyboard;\n\nasync function typeString(device: ViiperDevice, text: string): Promise&lt;void&gt; {\n  for (const ch of text) {\n    const cp = ch.codePointAt(0)!;\n    const key = CharToKeyGet(cp);\n    if (key === undefined) continue;\n\n    const mods = ShiftCharsHas(cp) ? Mod.LeftShift : 0;\n\n    // Press\n    await device.send(new KeyboardInput({\n      Modifiers: mods,\n      Count: 1,\n      Keys: [key]\n    }));\n    await new Promise(r =&gt; setTimeout(r, 50));\n\n    // Release\n    await device.send(new KeyboardInput({\n      Modifiers: 0,\n      Count: 0,\n      Keys: []\n    }));\n    await new Promise(r =&gt; setTimeout(r, 50));\n  }\n}\n\n// Usage\nawait typeString(device, \"Hello, World!\");\n</code></pre>"},{"location":"clients/typescript/#device-specific-wire-formats","title":"Device-Specific Wire Formats","text":""},{"location":"clients/typescript/#keyboard-input","title":"Keyboard Input","text":"<pre><code>interface KeyboardInput {\n  Modifiers: number;    // Modifier flags (Ctrl, Shift, Alt, GUI)\n  Count: number;        // Number of keys in Keys array\n  Keys: number[];       // Key codes (max 6 for HID compliance)\n}\n</code></pre> <p>Wire format: 1 byte modifiers + 1 byte count + N bytes keys (variable-length)</p>"},{"location":"clients/typescript/#keyboard-output-leds","title":"Keyboard Output (LEDs)","text":"<pre><code>// Single byte with LED flags\nconst leds = data.readUInt8(0);\nconst numLock = (leds &amp; LED.NumLock) !== 0;\n</code></pre>"},{"location":"clients/typescript/#xbox360-input","title":"Xbox360 Input","text":"<pre><code>interface Xbox360Input {\n  Buttons: number;     // Button flags\n  Lt: number;          // Left trigger (0-255)\n  Rt: number;          // Right trigger (0-255)\n  Lx: number;          // Left stick X (-32768 to 32767)\n  Ly: number;          // Left stick Y (-32768 to 32767)\n  Rx: number;          // Right stick X (-32768 to 32767)\n  Ry: number;          // Right stick Y (-32768 to 32767)\n}\n</code></pre> <p>Wire format: Fixed 14 bytes, packed structure</p>"},{"location":"clients/typescript/#xbox360-output-rumble","title":"Xbox360 Output (Rumble)","text":"<pre><code>// Two bytes: left motor + right motor (0-255 each)\nconst leftMotor = data.readUInt8(0);\nconst rightMotor = data.readUInt8(1);\n</code></pre>"},{"location":"clients/typescript/#mouse-input","title":"Mouse Input","text":"<pre><code>interface MouseInput {\n  Buttons: number;  // Button flags\n  Dx: number;       // Relative X movement (-128 to 127)\n  Dy: number;       // Relative Y movement (-128 to 127)\n  Wheel: number;    // Vertical scroll (-128 to 127)\n  Pan: number;      // Horizontal scroll (-128 to 127)\n}\n</code></pre> <p>Wire format: Fixed 5 bytes, packed structure</p>"},{"location":"clients/typescript/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/typescript/#custom-port","title":"Custom Port","text":"<pre><code>const client = new ViiperClient(\"localhost\", 3242);\n</code></pre> <p>Default port is 3242 if not specified.</p>"},{"location":"clients/typescript/#error-handling","title":"Error Handling","text":"<p>The server returns errors as JSON. The client throws exceptions:</p> <pre><code>try {\n  await client.buscreate(\"invalid-bus-id\");\n} catch (err) {\n  console.error(`Request failed: ${err}`);\n}\n</code></pre> <p>Stream errors are surfaced through the EventEmitter error event:</p> <pre><code>device.on('error', (err) =&gt; {\n  console.error(`Stream error: ${err}`);\n});\n</code></pre>"},{"location":"clients/typescript/#resource-management","title":"Resource Management","text":"<p>Always close devices when done:</p> <pre><code>try {\n  const device = await client.connectDevice(busId, deviceId);\n  // ... use device ...\n} finally {\n  device.close();\n}\n</code></pre>"},{"location":"clients/typescript/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/typescript/virtual_keyboard.ts</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/typescript/virtual_mouse.ts</code></p> </li> <li>Moves cursor diagonally</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/typescript/virtual_x360_pad.ts</code></p> </li> <li>Runs at 60fps with cycling buttons and animated triggers</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/typescript/#running-examples","title":"Running Examples","text":"<pre><code>cd examples/typescript\nnpm install\nnpm run build\n\nnode dist/virtual_keyboard.js localhost:3242\n</code></pre>"},{"location":"clients/typescript/#troubleshooting","title":"Troubleshooting","text":"<p>Some quick troubleshooting tips for the TypeScript SDK and device streams:</p> <ul> <li>Connection refused / timeout: Verify VIIPER server is running and listening on the expected API port (default 3242). Ensure firewall/ACLs allow TCP connections.</li> <li>Unexpected response or parse errors: The VIIPER API uses null-byte (\\x00) terminated requests. Use the provided SDK helper methods or ensure raw sockets append a null terminator when calling the server.</li> <li>Stream closed unexpectedly: Confirm the device stream was opened (device added and connected) and that the device handler did not time out (default 5s reconnect window). Check server logs for reasons.</li> <li>Device not appearing to OS: Remember you must attach the virtual device via USBIP (USB-IP server default port :3241) AFTER you create the device via the API (or enable auto-attach on local host).</li> <li>Use examples: See the repository examples in <code>examples/typescript/</code> for working end-to-end samples that demonstrate bus creation, device streams, and cleanup.</li> </ul>"},{"location":"clients/typescript/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated SDKs work</li> <li>Go SDK Documentation: Reference implementation patterns</li> <li>C# SDK Documentation: Alternative managed language SDK</li> <li>C SDK Documentation: Alternative SDK for native integration</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"devices/keyboard/","title":"HID Keyboard","text":"<p>A full-featured HID keyboard with N-key rollover using a 256-bit key bitmap, plus LED status feedback (NumLock, CapsLock, ScrollLock) via an OUT report.</p> <ul> <li>USB IDs: VID 0x2E8A (Raspberry Pi), PID 0x0010</li> <li>Interfaces/Endpoints:</li> <li>IN: 0x81 (keyboard input report)</li> <li>OUT: 0x01 (LED output report)</li> <li>Device type id (for API add): <code>keyboard</code></li> </ul>"},{"location":"devices/keyboard/#client-sdk-support","title":"Client SDK Support","text":"<p>The wire protocol is abstracted by client SDKs. The Go client includes built-in types (<code>pkg/device/keyboard</code>), and generated SDKs provide equivalent structures with proper packing. You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: Go Client, Generated SDKs</p>"},{"location":"devices/keyboard/#hid-report-format-host-facing","title":"HID report format (host-facing)","text":"<p>Input (device \u2192 host): 34 bytes</p> <ul> <li>Byte 0: Modifiers bitfield (LeftCtrl, LeftShift, LeftAlt, LeftGUI, RightCtrl, RightShift, RightAlt, RightGUI)</li> <li>Byte 1: Reserved (0)</li> <li>Bytes 2..33: 256-bit key bitmap (least-significant bit = usage ID 0)</li> </ul> <p>Output (host \u2192 device): 1 byte LEDs</p> <ul> <li>Bit 0 NumLock, Bit 1 CapsLock, Bit 2 ScrollLock (remaining bits reserved)</li> </ul> <p>Note: The HID descriptor uses a long-item Report Count (0x96) to encode 256 for the bitmap.</p>"},{"location":"devices/keyboard/#device-stream-protocol-client-facing","title":"Device stream protocol (client-facing)","text":"<p>Wire format from your client into VIIPER:</p> <ul> <li>Variable-length packets</li> <li>Header: [Modifiers (1 byte), KeyCount (1 byte)]</li> <li>Followed by KeyCount bytes of HID Usage IDs for the currently pressed non-modifier keys</li> </ul> <p>VIIPER converts this to the bitmap report for the host, so you don\u2019t need to manage the 256-bit array yourself.</p> <p>Example wire packet to press \u201cA\u201d with LeftShift:</p> <ul> <li>Modifiers = 0x02 (LeftShift)</li> <li>Count = 1</li> <li>Keys = [0x04]  // HID usage for \u201cA\u201d</li> </ul>"},{"location":"devices/keyboard/#leds-feedback","title":"LEDs feedback","text":"<p>The device sends the current LED state (1 byte) back on the same stream whenever the host changes it. You can use this to update indicators in your client.</p>"},{"location":"devices/keyboard/#helpers-and-keycodes","title":"Helpers and keycodes","text":"<p>Convenience helpers and key constants are available in the Go package:</p> <ul> <li><code>pkg/device/keyboard/helpers.go</code>: TypeString, TypeChar, PressKey, Release, etc.</li> <li><code>pkg/device/keyboard/const.go</code>: Modifiers, LED bits, and HID usage IDs, including media keys (Mute, VolumeUp/Down, PlayPause, Stop, Next, Previous)</li> </ul>"},{"location":"devices/keyboard/#adding-the-device","title":"Adding the device","text":"<p>Using the raw API (see API Reference for details):</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n\n# Add keyboard device with JSON payload\nprintf 'bus/1/add {\"type\":\"keyboard\"}\\0' | nc localhost 3242\n</code></pre> <p>Or use one of the client SDKs which handle the protocol automatically.</p>"},{"location":"devices/keyboard/#examples","title":"Examples","text":"<p>A runnable example that types \u201cHello!\u201d followed by Enter every few seconds is provided in <code>examples/virtual_keyboard/</code>.</p>"},{"location":"devices/mouse/","title":"HID Mouse","text":"<p>A standard 5-button mouse with vertical and horizontal scroll wheels. Reports relative motion deltas and supports up to five buttons.</p> <ul> <li>USB IDs: VID 0x2E8A (Raspberry Pi), PID 0x0011</li> <li>Interface/Endpoint: IN 0x81 (mouse input report)</li> <li>Device type id (for API add): <code>mouse</code></li> </ul>"},{"location":"devices/mouse/#client-sdk-support","title":"Client SDK Support","text":"<p>The wire protocol is abstracted by client SDKs. The Go client includes built-in types (<code>pkg/device/mouse</code>), and generated SDKs provide equivalent structures with proper packing. You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: Go Client, Generated SDKs</p>"},{"location":"devices/mouse/#hid-report-format-host-facing","title":"HID report format (host-facing)","text":"<p>Input (device \u2192 host): 5 bytes</p> <ul> <li>Byte 0: Buttons bitfield (bits 0..4 for buttons 1..5)</li> <li>Byte 1: X delta (int8)</li> <li>Byte 2: Y delta (int8)</li> <li>Byte 3: Vertical wheel (int8; positive up)</li> <li>Byte 4: Horizontal wheel/pan (int8; positive right)</li> </ul> <p>Deltas are consumed after each IN report so motion is truly relative and not repeated across host polls.</p>"},{"location":"devices/mouse/#device-stream-protocol-client-facing","title":"Device stream protocol (client-facing)","text":"<p>Wire format from your client into VIIPER:</p> <ul> <li>Fixed 5-byte packets matching the HID report layout:   [Buttons, dX, dY, Wheel, Pan]</li> </ul> <p>Buttons persist until changed; motion/wheel deltas are applied once and reset.</p>"},{"location":"devices/mouse/#adding-the-device","title":"Adding the device","text":"<p>Using the raw API (see API Reference for details):</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n\n# Add mouse device with JSON payload\nprintf 'bus/1/add {\"type\":\"mouse\"}\\0' | nc localhost 3242\n</code></pre> <p>Or use one of the client SDKs which handle the protocol automatically.</p>"},{"location":"devices/mouse/#examples","title":"Examples","text":"<p>A runnable example that periodically moves the mouse a short distance, clicks, and scrolls is provided in <code>examples/virtual_mouse/</code>.</p>"},{"location":"devices/xbox360/","title":"Xbox 360 Controller","text":"<p>The Xbox 360 virtual gamepad emulates an XInput-compatible controller that most operating systems and games understand out of the box.</p> <ul> <li>USB IDs: VID 0x045E (Microsoft), PID 0x028E (Xbox 360 Controller)</li> <li>Interfaces/Endpoints: single HID interface with one IN interrupt endpoint and one OUT interrupt endpoint for rumble</li> <li>Device type id (for API add): <code>xbox360</code></li> </ul>"},{"location":"devices/xbox360/#client-sdk-support","title":"Client SDK Support","text":"<p>The wire protocol is abstracted by client SDKs. The Go client includes built-in types (<code>pkg/device/xbox360</code>), and generated SDKs provide equivalent structures with proper packing. You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: Go Client, Generated SDKs</p>"},{"location":"devices/xbox360/#adding-the-device","title":"Adding the device","text":"<p>Use the API to create a bus and add an Xbox 360 controller. Using the raw API (see API Reference for details):</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n\n# Add xbox360 device with JSON payload\nprintf 'bus/1/add {\"type\":\"xbox360\"}\\0' | nc localhost 3242\n</code></pre> <p>The API returns a Device object with <code>busId</code>, <code>devId</code>, and other details. Attach it from a USB/IP client, then open a stream to drive input and receive rumble.</p> <p>Or use one of the client SDKs which handle the protocol automatically.</p>"},{"location":"devices/xbox360/#streaming-protocol","title":"Streaming protocol","text":"<p>The device stream is a bidirectional, raw TCP connection with fixed-size packets.</p> <p>Direction: client \u2192 server (input state)</p> <ul> <li>14-byte packets, little-endian layout:</li> <li>Buttons: uint32 (4 bytes)</li> <li>LT, RT: uint8, uint8 (2 bytes)</li> <li>LX, LY, RX, RY: int16 each (8 bytes)</li> </ul> <p>Direction: server \u2192 client (rumble feedback)</p> <ul> <li>2-byte packets:</li> <li>LeftMotor: uint8, RightMotor: uint8</li> </ul> <p>See <code>pkg/device/xbox360/inputstate.go</code> for details.</p>"},{"location":"devices/xbox360/#example","title":"Example","text":"<p>A minimal example program that sends input and reads rumble is provided in <code>examples/</code>.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>VIIPER relies on USBIP. You must have USBIP installed on your system.</p>"},{"location":"getting-started/installation/#linux","title":"Linux","text":""},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt install linux-tools-generic\n</code></pre> <p>Ubuntu USBIP Manual</p>"},{"location":"getting-started/installation/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S usbip\n</code></pre> <p>Arch Wiki: USBIP</p>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>usbip-win2 is by far the most complete implementation of USBIP for Windows (comes with a SIGNED kernel mode driver).</p>"},{"location":"getting-started/installation/#linux-kernel-module-setup","title":"Linux Kernel Module Setup","text":"<p>USBIP Client Requirement</p> <p>USBIP requires the <code>vhci-hcd</code> (Virtual Host Controller Interface) kernel module on Linux for client operations. This includes VIIPER's auto-attach feature and manual device attachment.</p> <p>Most Linux distributions include this module but don't load it automatically.</p>"},{"location":"getting-started/installation/#one-time-setup","title":"One-Time Setup","text":"<p>To load the module automatically on boot:</p> <pre><code>echo \"vhci-hcd\" | sudo tee /etc/modules-load.d/vhci-hcd.conf\nsudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/installation/#manual-loading","title":"Manual Loading","text":"<p>To load the module for the current session only:</p> <pre><code>sudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Check if the module is loaded:</p> <pre><code>lsmod | grep vhci_hcd\n</code></pre> <p>If you don't plan to use the auto-attach feature, you can skip this setup and disable it with <code>--api.auto-attach-local-client=false</code>.</p>"},{"location":"getting-started/installation/#installing-viiper","title":"Installing VIIPER","text":""},{"location":"getting-started/installation/#pre-built-binaries-recommended","title":"Pre-built Binaries (Recommended)","text":"<p>Download the latest release from the GitHub Releases page. Pre-built binaries are available for:</p> <ul> <li>Windows (x64, ARM64)</li> <li>Linux (x64, ARM64)</li> </ul>"},{"location":"getting-started/installation/#portable-deployment","title":"Portable Deployment","text":"<p>VIIPER does not require system-wide installation. The <code>viiper</code> executable is completely self-contained (and statically linked) and can be:</p> <ul> <li>Placed in any directory</li> <li>Shipped alongside your application</li> <li>Run directly without installation</li> <li>Bundled with your application's distribution</li> </ul> <p>This makes VIIPER ideal for embedding in applications or distributing as part of a software package.</p> <p>Daemon/Service Conflicts</p> <p>If VIIPER is already running as a system service or daemon on the target machine, be aware of potential port conflicts. Applications should either:</p> <ul> <li>Connect to the existing VIIPER instance (if accessible)</li> <li>Use a custom port via <code>--api.addr</code> flag to run a separate instance</li> <li>Check if VIIPER is already running before starting their own instance</li> </ul>"},{"location":"getting-started/installation/#building-from-source","title":"Building from Source","text":"<p>Building from source is only necessary if you need to modify VIIPER or target an unsupported platform.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or newer</li> <li>USBIP installed</li> <li>(Optional) Make<ul> <li>Linux/macOS: Usually pre-installed</li> <li>Windows: <code>winget install ezwinports.make</code></li> </ul> </li> </ul>"},{"location":"getting-started/installation/#build-steps","title":"Build Steps","text":"<pre><code>git clone https://github.com/Alia5/VIIPER.git\ncd VIIPER\nmake build\n</code></pre> <p>The compiled binary will be in <code>dist/viiper</code> (or <code>dist/viiper.exe</code> on Windows).</p> <p>Additional build targets:</p> <pre><code>make help          # Show all available make targets\nmake test          # Run tests\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide walks you through setting up VIIPER and creating your first virtual device.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ol> <li>USBIP installed on your system (see Installation)</li> <li>VIIPER binary downloaded from GitHub Releases or built from source</li> </ol>"},{"location":"getting-started/quickstart/#starting-the-server","title":"Starting the Server","text":"<p>Start VIIPER with default settings:</p> <pre><code>viiper server\n</code></pre> <p>This starts two services:</p> <ul> <li>USBIP Server on port <code>3241</code> (standard USBIP protocol)</li> <li>API Server on port <code>3242</code> (device management)</li> </ul> <p>Auto-attach Feature</p> <p>By default, VIIPER automatically attaches newly created devices to the local machine. You can disable this with <code>--api.auto-attach-local-client=false</code>.</p>"},{"location":"getting-started/quickstart/#custom-ports","title":"Custom Ports","text":"<p>To use different ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre>"},{"location":"getting-started/quickstart/#creating-your-first-virtual-device","title":"Creating Your First Virtual Device","text":"<p>VIIPER provides multiple ways to interact with the API. Choose the method that works best for you.</p>"},{"location":"getting-started/quickstart/#option-1-using-client-sdks-recommended","title":"Option 1: Using Client SDKs (Recommended)","text":"<p>Client SDKs are available for C, C#, Go, and TypeScript. They handle the protocol details automatically, providing type-safe interfaces and device-specific helpers.</p> <p>For complete SDK documentation and code examples, see:</p> <ul> <li>C SDK Documentation</li> <li>C# SDK Documentation</li> <li>TypeScript SDK Documentation</li> <li>Go Client Documentation</li> </ul> <p>Full working examples for all device types are available in the <code>examples/</code> directory of the repository.</p>"},{"location":"getting-started/quickstart/#option-2-using-raw-tcp-netcat","title":"Option 2: Using Raw TCP (netcat)","text":"<p>For quick testing without SDKs:</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n# Response: {\"busId\":1}\n\n# Add a keyboard device\nprintf 'bus/1/add {\"type\":\"keyboard\"}\\0' | nc localhost 3242\n# Response: {\"busId\":1,\"devId\":\"1\",\"vid\":\"0x2e8a\",\"pid\":\"0x0010\",\"type\":\"keyboard\"}\n\n# List devices on the bus\nprintf \"bus/1/list\\0\" | nc localhost 3242\n</code></pre> <p>Protocol Details</p> <p>The API uses TCP with null-byte (<code>\\0</code>) terminated requests. See API Reference for complete protocol documentation.</p>"},{"location":"getting-started/quickstart/#option-3-using-powershell-helper-script","title":"Option 3: Using PowerShell Helper Script","text":"<p>VIIPER includes a PowerShell helper script for Windows users:</p> <pre><code># Load the helper script\n. .\\scripts\\viiper-api.ps1\n\n# Create a bus\nInvoke-ViiperAPI \"bus/create\"\n\n# Add a device\nInvoke-ViiperAPI 'bus/1/add {\"type\":\"keyboard\"}'\n</code></pre>"},{"location":"getting-started/quickstart/#attaching-devices-usbip","title":"Attaching Devices (USBIP)","text":"<p>After creating a device via the API, attach it using your system's USBIP client.</p> <p>Automatic Attachment</p> <p>If you're running VIIPER on the same machine where you want to use the device, it's likely already attached automatically! Check your device manager or <code>lsusb</code> to confirm.</p>"},{"location":"getting-started/quickstart/#manual-attachment","title":"Manual Attachment","text":"<p>If auto-attach is disabled or you're connecting from a remote machine:</p> LinuxWindows <pre><code># Load kernel module (once per boot)\nsudo modprobe vhci-hcd\n\n# List available devices\nusbip list --remote=localhost --tcp-port=3241\n\n# Attach device (use busid from API response, e.g., \"1-1\")\nsudo usbip attach --remote=localhost --tcp-port=3241 --busid=1-1\n\n# Verify attachment\nlsusb | grep \"Raspberry Pi\"  # For keyboard/mouse\nlsusb | grep \"Microsoft\"     # For Xbox 360 controller\n</code></pre> <p>Using usbip-win2:</p> <pre><code># List available devices\nusbip.exe list --remote localhost --tcp-port 3241\n\n# Attach device\nusbip.exe attach --remote localhost --tcp-port 3241 --busid 1-1\n\n# Check Device Manager to verify attachment\n</code></pre>"},{"location":"getting-started/quickstart/#available-device-types","title":"Available Device Types","text":"<p>VIIPER supports multiple virtual device types including keyboards, mice, and game controllers. Each device type has its own protocol and capabilities.</p> <p>For a complete list of supported devices, their specifications, and wire protocols, see the Devices documentation.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a working setup:</p> <ol> <li>Explore Examples: Check the <code>examples/</code> directory for complete working programs in C, C#, Go, and TypeScript</li> <li>Read API Documentation: Learn about all available API commands</li> <li>Choose an SDK: Pick a client SDK for your preferred language</li> <li>Review Device Specs: Understand device-specific protocols in Devices</li> </ol>"},{"location":"getting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quickstart/#server-wont-start","title":"Server Won't Start","text":"<p>Port already in use:</p> <pre><code># Use custom ports\nviiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre> <p>Permission denied (Linux):</p> <pre><code># Use ports above 1024 or run with sudo\nviiper server --usb.addr=:3241 --api.addr=:3242\n</code></pre>"},{"location":"getting-started/quickstart/#auto-attach-not-working","title":"Auto-Attach Not Working","text":"<p>VIIPER will check prerequisites at startup when auto-attach is enabled and log warnings if requirements are missing.</p> <p>Linux - USBIP tool not found:</p> <pre><code># Ubuntu/Debian\nsudo apt install linux-tools-generic\n\n# Arch Linux\nsudo pacman -S usbip\n</code></pre> <p>Linux - Kernel module not loaded:</p> <pre><code># Load for current session\nsudo modprobe vhci-hcd\n\n# Or configure persistent loading (see Installation guide)\n</code></pre> <p>See Linux Kernel Module Setup for detailed setup instructions.</p> <p>Windows - USBIP tool not found:</p> <p>Download and install usbip-win2 and ensure <code>usbip.exe</code> is in your PATH.</p>"},{"location":"getting-started/quickstart/#device-not-attaching","title":"Device Not Attaching","text":"<p>USBIP tool not found:</p> <p>Make sure USBIP is installed and in your PATH (see Installation requirements).</p> <p>Connection refused:</p> <p>Verify the VIIPER server is running and listening on the expected ports.</p>"},{"location":"getting-started/quickstart/#device-not-working","title":"Device Not Working","text":"<p>No input response:</p> <p>Ensure the device is attached via USBIP AND you've opened a device stream via the API to send input data.</p> <p>Multiple VIIPER instances:</p> <p>If you have VIIPER running as a service, your application's instance may conflict. Either connect to the existing instance or use different ports.</p>"},{"location":"getting-started/quickstart/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command documentation</li> <li>API Reference - Management API protocol</li> <li>Client SDKs - Language-specific client libraries</li> <li>Configuration - Environment variables and config files</li> </ul>"}]}