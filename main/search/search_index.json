{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#viiper","title":"VIIPER \ud83d\udc0d","text":"<p>Virtual Input over IP EmulatoR</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>CLI Reference</li> <li>API Reference</li> <li>GitHub Repository</li> </ul>"},{"location":"#what-is-viiper","title":"What is VIIPER?","text":"<p>VIIPER lets developers create virtual USB input devices (like game controllers, keyboards, and mice) that can be controlled programmatically (even over a network!) (using USBIP under the hood). These virtual devices are indistinguishable from real hardware to the operating system and applications, enabling seamless integration for testing, automation, and remote control scenarios.</p> <ul> <li>VIIPER abstracts away all USB / USBIP details.  </li> <li>Device emulation happens in userspace code instead of kernel drivers, so no kernel programming is required to add new device types.  </li> <li>Users need USBIP installed once (built into Linux, usbip-win2 for Windows), after that VIIPER can run without additional dependencies or system-wide installation.  </li> </ul> <p>VIIPER currently comes in a single flavor:</p> <ul> <li>a self-contained, (no dependencies) portable, standalone executable.   providing a lightweight TCP based API for feeder application development.  </li> <li>There will eventually be a library version (libVIIPER) that you can link against directly from your application. For more information, see FAQ </li> </ul> <p>Beyond device emulation, VIIPER can proxy real USB devices for traffic inspection and reverse engineering.</p>"},{"location":"#feeder-application-development","title":"\ud83e\udd6b Feeder application development","text":"<p>VIIPER currently comes in a single flavor:</p> <ul> <li>a standalone executable that exposes an API over TCP.</li> <li>There will eventually be a shared-library version (libVIIPER) that you can link against directly from your application. For more information, see FAQ </li> </ul>"},{"location":"#api","title":"\ud83d\udd0c API","text":"<p>VIIPER includes a lightweight TCP based API for device and bus management, as well as streaming device control. It's designed to be trivial to drive from any language that can open a TCP socket and send null-byte-terminated commands.  </p> <p>Client Libraries Available</p> <p>Most of the time, you don't need to implement that raw protocol yourself, as client libraries are available. See Client Libraries Available.</p> <ul> <li>The TCP API uses a string-based request/response protocol terminated by null bytes (<code>\\0</code>) for device and bus management.  </li> <li>Requests have a \"path\" and optional payload (sometimes  JSON).     eg. <code>bus/{id}/add {\"type\": \"keyboard\", \"idVendor\": \"0x6969\"}\\0</code> </li> <li>Responses are often JSON as well!</li> <li>Errors are reported using JSON objectes similar to RFC 7807 Problem Details <sup>The use of JSON allows for future extenability without breaking compatibility ;)<sup> <li>For controlling, or feeding, a device a long lived TCP stream is used, with a wire-protocol specific to each device type.   After an initial \"handshake\" (<code>bus/{busId}/{deviceId}\\0</code>) a device-specific binary protocol is used to send input reports and receive output reports (e.g., rumble commands).</li> <p>VIIPER takes care of all USBIP protocol details, so you can focus on implementing the device logic only. On <code>localhost</code> VIIPER also automatically attached the USBIP client, so you don't have to worry about USBIP details at all.</p> <p>See the API documentation for details</p>"},{"location":"#faq","title":"\u2753 FAQ","text":""},{"location":"#what-is-usbip-and-why-does-viiper-use-it","title":"What is USBIP and why does VIIPER use it?","text":"<p>USBIP is a protocol that allows USB devices to be shared over a network. VIIPER uses it because it's already built into Linux and available for Windows, making virtual device emulation possible without writing custom kernel drivers yourself.</p>"},{"location":"#why-is-this-a-standalone-executable-that-i-have-to-interface-via-tcp-and-not-a-shared-object-library-in-itself","title":"Why is this a standalone executable that I have to interface via TCP, and not a (shared-object) library in itself","text":"<ul> <li>Flexibility</li> <li>allows one to use VIIPER as a service on the same host as the USBIP-Client and use the feeder on a different, remote machine.</li> <li>allows for software written utilizing VIIPER to not be licensed under the terms of the GPLv3</li> <li>future versions: Users can enhance VIIPER with device plugins, sharing a common wire-protocol, which can be dynamically incorporated.</li> <li>That said, there will be a libVIIPER  that you can link against, eleminating multi-process and potential firewall issues.   Note that this will require your application to be licensed under the terms of the GPLv3 (or comptible license)</li> </ul>"},{"location":"#can-i-use-viiper-for-gaming","title":"Can I use VIIPER for gaming?","text":"<p>Yes! VIIPER can create virtual controllers (currently only Xbox360) that appear as real hardware to games and applications. This works with Steam, native Windows games, and any other application supporting controllers.</p>"},{"location":"#how-is-viiper-different-from-other-controller-emulators","title":"How is VIIPER different from other controller emulators?","text":"<p>Most controller emulators require custom kernel drivers for each device type. VIIPER uses USBIP to handle the USB protocol layer, allowing device emulation in userspace without kernel drivers. This makes VIIPER portable, easier to extend, and simpler to bundle with applications.</p>"},{"location":"#can-i-add-support-for-other-device-types","title":"Can I add support for other device types?","text":"<p>Yes! VIIPER's architecture is designed to be extensible. In the future there will be a plugin system to load and expose device types dynamically.</p>"},{"location":"#what-about-the-proxy-mode","title":"What about the proxy mode?","text":"<p>Proxy mode sits between a USBIP client and a USBIP server (like a Linux machine sharing real USB devices). VIIPER intercepts and logs all USB traffic passing through, without handling the devices directly. Useful for reverse engineering USB protocols and understanding how devices communicate.</p>"},{"location":"#what-about-tcp-overhead-or-input-latency-performance","title":"What about TCP overhead or input latency performance?","text":"<p>End-to-end input latency for virtual devices created with VIIPER is typically well below 1 millisecond on a modern desktop (e.g. Windows / Ryzen 3900X test machine). Detailed methodology and sample runs can be found in E2E Latency Benchmarks. However, to not stress the CPU excessively, reports get batched and sent every millisecond. So the best you will achive is a 1000Hz update rate, which is more than enough and more than what most real hardware devices provide. Note: Actual device polling rates may be lower depending on the device type and configuration.</p>"},{"location":"mkdocs-readme/","title":"MkDocs Documentation","text":"<p>This directory contains the MkDocs-based documentation for VIIPER.</p>"},{"location":"mkdocs-readme/#setup","title":"Setup","text":"<p>Install MkDocs with Material theme:</p> <pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"mkdocs-readme/#development","title":"Development","text":"<p>Run the documentation server locally:</p> <pre><code>cd doc\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000/ in your browser.</p>"},{"location":"mkdocs-readme/#building","title":"Building","text":"<p>Build the static documentation site:</p> <pre><code>cd doc\nmkdocs build\n</code></pre> <p>The built site will be in the <code>site/</code> directory.</p>"},{"location":"mkdocs-readme/#deployment","title":"Deployment","text":"<p>Deploy to GitHub Pages:</p> <pre><code>cd doc\nmkdocs gh-deploy\n</code></pre>"},{"location":"mkdocs-readme/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - MkDocs configuration</li> <li><code>docs/</code> - Documentation source files (Markdown)<ul> <li><code>index.md</code> - Home page</li> <li><code>getting-started/</code> - Installation and quick start</li> <li><code>cli/</code> - CLI reference</li> <li><code>api/</code> - API reference</li> </ul> </li> </ul>"},{"location":"api/overview/","title":"API Reference","text":"<p>VIIPER ships a lightweight TCP API for managing virtual buses/devices and for device-specific streaming. It's designed to be trivial to drive from any language that can open a TCP socket and send null-byte-terminated commands.</p> <p>Client Libraries Available</p> <p>Generated client libraries are available that abstract away the protocol details described below. For most use cases, you should use one of the provided client libraries rather than implementing the raw protocol yourself:</p> <ul> <li>Go Client: Reference implementation included in the repository</li> <li>Generator Documentation: Information about code generation</li> <li>C Client Library: Generated C library with type-safe device streams</li> <li>C++ Client Library: Header-only C++20 library (requires external JSON parser)</li> <li>C# Client Library: Generated .NET library with async/await support</li> <li>TypeScript Client Library: Generated Node.js library with EventEmitter streams</li> <li>Rust Client Library: Generated Rust library with sync/async support</li> </ul> <p>The documentation below is provided for reference and for implementing clients in languages not yet supported by the generator.</p>"},{"location":"api/overview/#protocol-overview","title":"Protocol overview","text":"<ul> <li>Transport: TCP</li> <li>Default listen address: <code>:3242</code> (configurable via <code>--api.addr</code>)</li> <li>Request format: a single ASCII/UTF\u20118 line terminated by <code>\\0</code> (null byte)</li> <li>Routing: path followed by optional payload separated by whitespace (e.g., <code>bus/list\\0</code> or <code>bus/create 5\\0</code>)</li> <li>Payload: optional string that can be a JSON object, numeric value, or plain string depending on the endpoint. The payload may contain newlines (e.g., pretty-printed JSON) as only the null byte terminates the request.</li> <li>Success response: a single line containing a JSON payload (or an empty line for commands that have no payload), followed by <code>\\n</code>, then connection close</li> <li>Error response: a single line JSON object following RFC 7807 Problem Details format with a <code>status</code> field (HTTP-style status code) and other error details, followed by <code>\\n</code>, then connection close</li> </ul> <p>Tip: You can experiment with <code>nc</code>/<code>ncat</code> or PowerShell\u2019s <code>tcpclient</code> to send lines and read JSON back.</p> <p>Connection timing and auto\u2011cleanup</p> <p>After you add a device with <code>bus/{id}/add</code>, you must connect to its streaming endpoint within the configured <code>DeviceHandlerConnectTimeout</code> (default: 5s). If no stream connection is established in time, the device is automatically removed. Likewise, when a stream disconnects, a reconnection timer with the same timeout starts; if the client doesn\u2019t reconnect before it expires, the device is removed.</p>"},{"location":"api/overview/#endpoints","title":"Endpoints","text":"<ul> <li><code>ping</code></li> <li>Simple identity and version check.</li> <li> <p>Response: <code>{ \"server\": \"VIIPER\", \"version\": \"1.2.3[-dev-abcd]\" }</code></p> </li> <li> <p><code>bus/list</code></p> </li> <li>List all virtual bus IDs.</li> <li> <p>Response: <code>{ \"buses\": [1, 2, ...] }</code></p> </li> <li> <p><code>bus/create [busId]</code></p> </li> <li>Create a new bus. If <code>busId</code> (numeric) is provided, VIIPER attempts to create the bus with that id; otherwise it picks the next free id.</li> <li>Payload: Optional numeric bus ID (e.g., <code>5</code>)</li> <li> <p>Response: <code>{ \"busId\": &lt;id&gt; }</code></p> </li> <li> <p><code>bus/remove &lt;busId&gt;</code></p> </li> <li>Remove a bus and all devices on it.</li> <li>Payload: Numeric bus ID (e.g., <code>1</code>)</li> <li> <p>Response: <code>{ \"busId\": &lt;id&gt; }</code></p> </li> <li> <p><code>bus/{id}/list</code></p> </li> <li>List devices on a bus.</li> <li> <p>Response: <code>{ \"devices\": [{ \"busId\": 1, \"devId\": \"1\", \"vid\": \"0x045e\", \"pid\": \"0x028e\", \"type\": \"xbox360\" }, ...] }</code></p> </li> <li> <p><code>bus/{id}/add &lt;json_payload&gt;</code></p> </li> <li>Add a device to a bus.</li> <li>Payload: JSON object with device creation parameters: <code>{\"type\": \"&lt;deviceType&gt;\", \"idVendor\": &lt;optional_vid&gt;, \"idProduct\": &lt;optional_pid&gt;}</code></li> <li>Example: <code>{\"type\": \"xbox360\"}</code> or <code>{\"type\": \"keyboard\", \"idVendor\": 1234, \"idProduct\": 5678}</code></li> <li>Response: JSON device object with fields: <code>{\"busId\": &lt;id&gt;, \"devId\": \"&lt;devId&gt;\", \"vid\": \"0x045e\", \"pid\": \"0x028e\", \"type\": \"xbox360\"}</code></li> <li>Important: After add, the server starts a connect timer (default <code>5s</code>). You must open a device stream (see below) before the timeout expires, otherwise the device is auto-removed.</li> <li> <p>If auto-attach is enabled (default) the server automatically attaches the new device to a local USBIP client on the same host (localhost only).     Failures (missing tool, non-zero exit) are logged but do not affect the API response.</p> </li> <li> <p><code>bus/{id}/remove &lt;deviceId&gt;</code></p> </li> <li>Remove a device by its device number on that bus.</li> <li>Payload: Numeric device ID (e.g., <code>1</code> for device 1-1 on the bus)</li> <li>Response: <code>{ \"busId\": &lt;id&gt;, \"devId\": \"&lt;dev&gt;\" }</code></li> </ul>"},{"location":"api/overview/#streaming-endpoint","title":"Streaming endpoint","text":"<ul> <li>Path: <code>bus/{busId}/{deviceid}</code></li> <li>Handshake: Send the path followed by <code>\\0</code> (null byte) (e.g., <code>bus/1/1\\0</code>)</li> <li>Type: long-lived TCP connection</li> <li>Purpose: device-specific, bidirectional stream. The API server hands the socket to the device's registered stream handler.</li> <li>Timeout behavior: When a stream ends, a reconnect timer is started (same <code>DeviceHandlerConnectTimeout</code>).   If the client doesn't reconnect in time, the device is removed.</li> </ul>"},{"location":"api/overview/#xbox-360-controller-stream-device-type-xbox360","title":"Xbox 360 controller stream (device type: <code>xbox360</code>)","text":"<p>Direction: client \u279c server (input state)</p> <ul> <li>Fixed 14-byte packets, little-endian layout:</li> <li><code>Buttons</code> uint32 (4 bytes)</li> <li><code>LT</code> uint8, <code>RT</code> uint8 (2 bytes)</li> <li><code>LX, LY, RX, RY</code> int16 each (8 bytes)</li> </ul> <p>Direction: server \u279c client (rumble)</p> <ul> <li>Fixed 2-byte packets:</li> <li><code>LeftMotor</code> uint8, <code>RightMotor</code> uint8</li> </ul> <p>See <code>/device/xbox360/protocol.go</code> for full details.</p>"},{"location":"api/overview/#hid-keyboard-stream-device-type-keyboard","title":"HID keyboard stream (device type: <code>keyboard</code>)","text":"<p>Direction: client \u279c server (keys pressed)</p> <ul> <li>Variable-length packets per frame:</li> <li>Header: Modifiers uint8, KeyCount uint8</li> <li>Body: KeyCount bytes of HID Usage IDs for currently pressed (non-modifier) keys</li> </ul> <p>Direction: server \u279c client (LED state)</p> <ul> <li>1-byte packets whenever host LED state changes:</li> <li>Bit 0 NumLock, Bit 1 CapsLock, Bit 2 ScrollLock</li> </ul> <p>Host-facing HID input report is 34 bytes: [Modifiers (1), Reserved (1), 256-bit key bitmap (32)].</p> <p>See <code>/device/keyboard/</code> for helpers and constants.</p>"},{"location":"api/overview/#hid-mouse-stream-device-type-mouse","title":"HID mouse stream (device type: <code>mouse</code>)","text":"<p>Direction: client \u279c server (motion/buttons)</p> <ul> <li>Fixed 5-byte packets per frame:</li> <li>Buttons uint8 (bits 0..4)</li> <li>dX int8, dY int8</li> <li>Wheel int8, Pan int8</li> </ul> <p>Direction: server \u279c client</p> <ul> <li>None (mouse is input-only)</li> </ul> <p>Note: Motion and wheel deltas are consumed after each IN report so movement is relative.</p> <p>Note on protocol compatibility:</p> <ul> <li>The wire format is modeled after the XInput gamepad state (XINPUT_GAMEPAD) but is not byte\u2011for\u2011byte identical. Key differences:</li> <li>Buttons are encoded as a 32\u2011bit little\u2011endian field (XInput uses a 16\u2011bit bitmask), making the packet 14 bytes instead of 12.</li> <li>No header or framing: packets are fixed\u2011length and back\u2011to\u2011back on the TCP stream.</li> <li>Endianness is little\u2011endian for all multi\u2011byte fields.</li> </ul>"},{"location":"api/overview/#example-sessions","title":"Example sessions","text":""},{"location":"api/overview/#using-netcat-linuxmacos","title":"Using netcat (Linux/macOS)","text":"<pre><code># List buses\nprintf \"bus/list\\0\" | nc localhost 3242\n\n# Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n# \u2192 {\"busId\":1}\n\n# Create a bus with specific ID\nprintf \"bus/create 5\\0\" | nc localhost 3242\n# \u2192 {\"busId\":5}\n\n# Add a virtual Xbox 360 controller to bus 1\nprintf 'bus/1/add {\"type\":\"xbox360\"}\\0' | nc localhost 3242\n# \u2192 {\"busId\":1,\"devId\":\"1\",\"vid\":\"0x045e\",\"pid\":\"0x028e\",\"type\":\"xbox360\"}\n\n# List devices on bus 1\nprintf \"bus/1/list\\0\" | nc localhost 3242\n</code></pre> <p>Then, open a second TCP connection for streaming to <code>bus/1/1</code> (the API port, not the USBIP port). First send the handshake <code>bus/1/1\\0</code>, then you'll write 14\u2011byte input packets and read 2\u2011byte rumble packets. Any language with raw TCP support works.</p>"},{"location":"api/overview/#windows-powershell","title":"WIndows (PowerShell)","text":"<p>VIIPER includes convenience scripts for quick testing and automation:</p> <pre><code># Source the script to load helper functions\n. .\\scripts\\viiper-api.ps1\n\n# Use the Invoke-ViiperApi function (or 'viiper' alias)\nviiper \"bus/list\"\nviiper \"bus/create\"\nviiper \"bus/1/add {\\\"type\\\":\\\"xbox360\\\"}\" -Port 3242 -Hostname localhost\n</code></pre> <p>The script provides <code>Invoke-ViiperApi</code> (alias: <code>viiper</code>) for sending commands and <code>Connect-ViiperDevice</code> for testing persistent device connections.</p>"},{"location":"api/overview/#go-snippet-raw","title":"Go snippet (raw)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net\"\n)\n\nfunc main() {\n    conn, _ := net.Dial(\"tcp\", \"localhost:3242\")\n    defer conn.Close()\n\n    // Send request with null terminator\n    fmt.Fprint(conn, \"bus/create\\x00\")\n\n    // Read entire response until connection closes\n    resp, _ := io.ReadAll(conn)\n    fmt.Println(string(resp)) // {\"busId\":1}\\n\n}\n</code></pre> <p>For a higher-level experience, see the Go client in <code>/apiclient/</code>.</p>"},{"location":"api/overview/#how-this-relates-to-usbip","title":"How this relates to USBIP","text":"<p>The API controls which virtual devices exist and exposes a device stream for live input/feedback. Separately, the USBIP server (default <code>:3241</code>) makes these devices attachable from clients. Typical flow:</p> <p>1) Create a bus \u279c 2) Add a device \u279c 3) Connect the device stream \u279c 4) Attach using USBIP by <code>busid</code> (see the Server command page for syntax).</p> <p>If auto-attach is enabled step 4 is attempted automatically for the local host; you still must perform step 3 to keep the device alive.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Development Version (main)</li> </ul>"},{"location":"changelog/#released-versions","title":"Released Versions","text":"<ul> <li>Version 0.3.1</li> <li>Version 0.3.0</li> <li>Version 0.2.2</li> <li>Version 0.2.1</li> <li>Version 0.2.0</li> <li>Version 0.1.0</li> <li>Version 0.0.4</li> <li>Version 0.0.3</li> <li>Version 0.0.2</li> <li>Version 0.0.1</li> </ul>"},{"location":"changelog/main/","title":"Main","text":""},{"location":"changelog/main/#changelog-for-development-version","title":"Changelog for Development Version","text":"<p>Changes since v0.3.1:</p>"},{"location":"changelog/main/#new-features","title":"\u2728 New Features","text":"<ul> <li>SteamDeck (Jupiter) Controller emulation</li> <li>Windows: Detect gui launches and auto-run server in BG</li> </ul>"},{"location":"changelog/main/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix busCreate with id 0 not choosing next free bus</li> <li>Windows-Install: Fix VIIPER server closing upon terminal close</li> </ul>"},{"location":"changelog/main/#miscellaneous","title":"\ud83d\udd27 Miscellaneous","text":"<ul> <li>Linux install script: handle updates more gracefully</li> </ul>"},{"location":"cli/codegen/","title":"Code Generation Command","text":"<p>The <code>codegen</code> command generates type-safe client libraries from Go source code annotations.</p>"},{"location":"cli/codegen/#usage","title":"Usage","text":"<pre><code>viiper codegen [flags]\n</code></pre>"},{"location":"cli/codegen/#description","title":"Description","text":"<p>Scans the VIIPER server codebase to extract:</p> <ul> <li>API routes and response DTOs</li> <li>Device wire formats from <code>viiper:wire</code> comment tags</li> <li>Device constants (keycodes, modifiers, button masks)</li> </ul> <p>Then generates client libraries with:</p> <ul> <li>Management API clients</li> <li>Device-agnostic stream wrappers</li> <li>Per-device encode/decode functions</li> <li>Typed constants and enums</li> </ul> <p>Sourcecode access is required</p> <p>The codegen command requires access to VIIPER source code. Run it from the repository root.</p>"},{"location":"cli/codegen/#flags","title":"Flags","text":""},{"location":"cli/codegen/#-output","title":"<code>--output</code>","text":"<p>Output directory for generated client libraries (relative to repository root).</p> <p>Default: <code>clients</code> Environment Variable: <code>VIIPER_CODEGEN_OUTPUT</code></p> <p>Example:</p> <pre><code>viiper codegen --output=../client-libs-output\n</code></pre>"},{"location":"cli/codegen/#-lang","title":"<code>--lang</code>","text":"<p>Target language to generate.</p> <p>Values: <code>c</code>, <code>csharp</code>, <code>typescript</code>, <code>all</code> Default: <code>all</code> Environment Variable: <code>VIIPER_CODEGEN_LANG</code></p> <p>Examples:</p> <pre><code># Generate all client libraries\nviiper codegen --lang=all\n\n# Generate C client library only\nviiper codegen --lang=c\n\n# Generate C# client library only\nviiper codegen --lang=csharp\n\n# Generate TypeScript client library only\nviiper codegen --lang=typescript\n</code></pre>"},{"location":"cli/codegen/#examples","title":"Examples","text":""},{"location":"cli/codegen/#generate-all-client-libraries","title":"Generate All Client Libraries","text":"<pre><code>go run ./cmd/viiper codegen\n</code></pre>"},{"location":"cli/codegen/#generate-c-client-library-and-rebuild-examples","title":"Generate C Client Library and Rebuild Examples","text":"<pre><code>go run ./cmd/viiper codegen --lang=c\ncd examples/c\ncmake --build build --config Release\n</code></pre>"},{"location":"cli/codegen/#when-to-regenerate","title":"When to Regenerate","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>/apitypes/*.go</code>: API response structures</li> <li><code>/device/*/inputstate.go</code>: Wire format annotations</li> <li><code>/device/*/const.go</code>: Exported constants</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li>Generator templates in <code>internal/codegen/generator/</code></li> </ul>"},{"location":"cli/codegen/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: Detailed explanation of tagging system and code generation flow</li> <li>C Client Library Documentation: C-specific usage and build instructions</li> <li>Configuration: Global configuration options</li> </ul>"},{"location":"cli/configuration/","title":"Configuration","text":"<p>VIIPER can be configured via:</p> <ul> <li>Command-line flags</li> <li>Environment variables</li> <li>Configuration files (JSON/YAML/TOML)</li> </ul>"},{"location":"cli/configuration/#environment-variables","title":"Environment Variables","text":"<p>All command-line flags have corresponding environment variables for easier deployment and configuration management.</p>"},{"location":"cli/configuration/#global-configuration","title":"Global Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_LOG_LEVEL</code> <code>--log.level</code> <code>info</code> Logging level: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> <code>VIIPER_LOG_FILE</code> <code>--log.file</code> (none) Log file path (logs only to console if not set) <code>VIIPER_LOG_RAW_FILE</code> <code>--log.raw-file</code> (none) Raw packet log file path"},{"location":"cli/configuration/#server-configuration","title":"Server Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_USB_ADDR</code> <code>--usb.addr</code> <code>:3241</code> USBIP server listen address <code>VIIPER_API_ADDR</code> <code>--api.addr</code> <code>:3242</code> API server listen address <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code> <code>--api.device-handler-timeout</code> <code>5s</code> Device handler auto-cleanup timeout <code>VIIPER_API_AUTO_ATTACH_LOCAL_CLIENT</code> <code>--api.auto-attach-local-client</code> <code>true</code> Auto-attach exported devices to local usbip client <code>VIIPER_CONNECTION_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection operation timeout"},{"location":"cli/configuration/#proxy-configuration","title":"Proxy Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_PROXY_ADDR</code> <code>--listen-addr</code> <code>:3241</code> Proxy listen address <code>VIIPER_PROXY_UPSTREAM</code> <code>--upstream</code> (required) Upstream USBIP server address <code>VIIPER_PROXY_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection timeout"},{"location":"cli/configuration/#configuration-files","title":"Configuration Files","text":"<p>VIIPER supports JSON, YAML, and TOML configuration files. Generate a starter file with:</p> <pre><code>viiper config init server --format=json   # or yaml|toml\n</code></pre> <p>If no output path is provided, the file is written to the current working directory (e.g., server.json, proxy.yaml).</p> <p>You can also specify a custom location:</p> <pre><code>viiper config init server --format=json --output ./server.json\n</code></pre> <p>To use a specific configuration file when starting VIIPER, pass the --config flag (or set VIIPER_CONFIG):</p> <pre><code>viiper --config ./server.json server\n</code></pre> <p>If --config is not provided, VIIPER will search for configuration in this order and first-found is used for each format:</p> <ol> <li>Working directory: server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), viiper.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Platform config directory (see above): server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Linux system-wide: /etc/viiper/server.(json|yaml|yml|toml), /etc/viiper/proxy.(json|yaml|yml|toml), /etc/viiper/config.(json|yaml|yml|toml)</li> </ol> <p>Example JSON configurations:</p> <p>Server:</p> <pre><code>{\n  \"api\": {\n    \"addr\": \":3242\",\n    \"device-handler-connect-timeout\": \"5s\",\n    \"auto-attach-local-client\": true\n  },\n  \"usb\": {\n    \"addr\": \":3241\"\n  },\n  \"connection-timeout\": \"30s\"\n}\n</code></pre> <p>Proxy:</p> <pre><code>{\n  \"listen-addr\": \":3241\",\n  \"upstream-addr\": \"127.0.0.1:3242\",\n  \"connection-timeout\": \"30s\"\n}\n</code></pre>"},{"location":"cli/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"cli/configuration/#using-environment-variables","title":"Using Environment Variables","text":"<p>Create a <code>.env</code> file or export variables:</p> <pre><code>export VIIPER_LOG_LEVEL=debug\nexport VIIPER_USB_ADDR=:3241\nexport VIIPER_API_ADDR=:3242\nexport VIIPER_LOG_FILE=/var/log/viiper.log\n</code></pre> <p>Then run:</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/configuration/#systemd-service","title":"Systemd Service","text":"<p>Example systemd service file for running VIIPER as a service:</p> <pre><code>[Unit]\nDescription=VIIPER USBIP Server\nAfter=network.target\n\n[Service]\nType=simple\nUser=viiper\nGroup=viiper\nEnvironment=\"VIIPER_LOG_LEVEL=info\"\nEnvironment=\"VIIPER_LOG_FILE=/var/log/viiper/viiper.log\"\nEnvironment=\"VIIPER_USB_ADDR=:3241\"\nEnvironment=\"VIIPER_API_ADDR=:3242\"\nExecStart=/usr/local/bin/viiper server\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"cli/configuration/#configuration-priority","title":"Configuration Priority","text":"<p>When both CLI flags and environment variables are set, CLI flags take precedence:</p> <ol> <li>CLI flags (highest priority)</li> <li>Environment variables</li> <li>Configuration file values</li> <li>Default values (lowest priority)</li> </ol>"},{"location":"cli/configuration/#see-also","title":"See Also","text":"<ul> <li>Server Command</li> <li>Proxy Command</li> </ul>"},{"location":"cli/overview/","title":"CLI Overview","text":"<p>VIIPER provides a command-line interface for running the USBIP server and proxy.</p>"},{"location":"cli/overview/#commands","title":"Commands","text":"<ul> <li><code>server</code> - Start the VIIPER USBIP server</li> <li><code>proxy</code> - Start the VIIPER USBIP proxy</li> <li><code>install</code> - Configure VIIPER to start automatically on system boot (see Installation)</li> <li><code>uninstall</code> - Remove VIIPER from system startup configuration</li> <li><code>codegen</code> - Generate client libraries from source code annotations</li> </ul>"},{"location":"cli/overview/#global-options","title":"Global Options","text":""},{"location":"cli/overview/#logging","title":"Logging","text":"<p>VIIPER supports flexible logging configuration via global flags or environment variables.</p>"},{"location":"cli/overview/#-loglevel","title":"<code>--log.level</code>","text":"<p>Set the logging level.</p> <p>Values: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> Default: <code>info</code> Environment Variable: <code>VIIPER_LOG_LEVEL</code></p> <p>Example:</p> <pre><code>viiper server --log.level=debug\n</code></pre>"},{"location":"cli/overview/#-logfile","title":"<code>--log.file</code>","text":"<p>Log to a file in addition to console output.</p> <p>Default: (none - logs only to console) Environment Variable: <code>VIIPER_LOG_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/overview/#-lograw-file","title":"<code>--log.raw-file</code>","text":"<p>Log raw USB packet data to a file for debugging and reverse engineering.</p> <p>Default: (none) Environment Variable: <code>VIIPER_LOG_RAW_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre> <p>Automatic Raw Logging</p> <p>When <code>--log.level=trace</code> is set without <code>--log.raw-file</code>, raw packets are logged to stdout.</p>"},{"location":"cli/overview/#getting-help","title":"Getting Help","text":"<p>Display help for any command:</p> <pre><code>viiper --help\nviiper server --help\nviiper proxy --help\n</code></pre>"},{"location":"cli/proxy/","title":"Proxy Command","text":"<p>Start the VIIPER USBIP proxy for traffic inspection and logging.</p>"},{"location":"cli/proxy/#usage","title":"Usage","text":"<pre><code>viiper proxy --upstream=&lt;address&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/proxy/#description","title":"Description","text":"<p>The <code>proxy</code> command starts VIIPER in proxy mode, sitting between a USBIP client and a USBIP server. VIIPER intercepts and logs all USB traffic passing through, without handling the devices directly.</p> <p>This is useful for reverse engineering USB protocols and understanding how devices communicate.</p>"},{"location":"cli/proxy/#options","title":"Options","text":""},{"location":"cli/proxy/#-listen-addr","title":"<code>--listen-addr</code>","text":"<p>Proxy listen address (where clients connect).</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_PROXY_ADDR</code></p> <p>Example:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3240\n</code></pre>"},{"location":"cli/proxy/#-upstream","title":"<code>--upstream</code>","text":"<p>Required. Upstream USBIP server address (where real devices are).</p> <p>Environment Variable: <code>VIIPER_PROXY_UPSTREAM</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240\n</code></pre>"},{"location":"cli/proxy/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection timeout for proxy operations.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_PROXY_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --connection-timeout=60s\n</code></pre>"},{"location":"cli/proxy/#examples","title":"Examples","text":""},{"location":"cli/proxy/#basic-proxy","title":"Basic Proxy","text":"<p>Start proxy between local clients and remote USBIP server:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240\n</code></pre> <p>Clients connect to <code>localhost:3241</code>, traffic is proxied to <code>192.168.1.100:3240</code>.</p>"},{"location":"cli/proxy/#custom-listen-address","title":"Custom Listen Address","text":"<p>Start proxy on a different port:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3240\n</code></pre> <p>Clients connect to <code>localhost:9000</code>, traffic is proxied to <code>192.168.1.100:3240</code>.</p>"},{"location":"cli/proxy/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Capture all USB traffic for reverse engineering:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --log.raw-file=usb-capture.log\n</code></pre> <p>All USB packets will be logged to <code>usb-capture.log</code>.</p>"},{"location":"cli/proxy/#with-debug-logging","title":"With Debug Logging","text":"<p>Enable debug logging to see proxy operations:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --log.level=debug\n</code></pre>"},{"location":"cli/proxy/#use-cases","title":"Use Cases","text":""},{"location":"cli/proxy/#reverse-engineering","title":"Reverse Engineering","text":"<p>Intercept USB traffic between a client and server to understand device protocols:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.raw-file=device-capture.log\n</code></pre>"},{"location":"cli/proxy/#traffic-analysis","title":"Traffic Analysis","text":"<p>Monitor USB communication for debugging:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.level=trace\n</code></pre>"},{"location":"cli/proxy/#network-inspection","title":"Network Inspection","text":"<p>Route USB traffic through VIIPER to inspect and log all operations:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.level=debug --log.raw-file=traffic.log\n</code></pre>"},{"location":"cli/proxy/#proxy-architecture","title":"Proxy Architecture","text":"<pre><code>USBIP Client  \u2192  VIIPER Proxy  \u2192  USBIP Server (real devices)\n                      \u2193\n              Logs/Captures Traffic\n</code></pre> <p>VIIPER sits in the middle, forwarding all traffic while logging packets for inspection.</p>"},{"location":"cli/proxy/#see-also","title":"See Also","text":"<ul> <li>Server Command - Run VIIPER as a USBIP server</li> <li>Configuration - Environment variables and configuration files</li> </ul>"},{"location":"cli/server/","title":"Server Command","text":"<p>Start the VIIPER USBIP server to expose virtual devices.</p>"},{"location":"cli/server/#usage","title":"Usage","text":"<pre><code>viiper server [OPTIONS]\n</code></pre>"},{"location":"cli/server/#description","title":"Description","text":"<p>The <code>server</code> command starts the VIIPER USBIP server, which allows you to create and manage virtual USB devices that appear as real hardware to USBIP clients.</p> <p>The server exposes two interfaces:</p> <ol> <li>USBIP Server - Standard USBIP protocol for device attachment</li> <li>API Server - Management API for device/bus control</li> </ol> <p>Automatic Local Attachment</p> <p>By default, VIIPER automatically attaches newly created devices to the local USBIP client (localhost only). This means when you create a device via the API, it will be immediately available on the same machine without manual <code>usbip attach</code> commands. This behavior can be disabled with <code>--api.auto-attach-local-client=false</code> if you prefer manual control or are running on a remote server.</p>"},{"location":"cli/server/#options","title":"Options","text":""},{"location":"cli/server/#-usbaddr","title":"<code>--usb.addr</code>","text":"<p>USBIP server listen address.</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_USB_ADDR</code></p> <p>Example:</p> <pre><code>viiper server --usb.addr=0.0.0.0:3241\n</code></pre>"},{"location":"cli/server/#-apiaddr","title":"<code>--api.addr</code>","text":"<p>API server listen address.</p> <p>Default: <code>:3242</code> Environment Variable: <code>VIIPER_API_ADDR</code></p> <p>Example:</p> <pre><code># Enable API on custom port\nviiper server --api.addr=:8080\n</code></pre>"},{"location":"cli/server/#-apidevice-handler-timeout","title":"<code>--api.device-handler-timeout</code>","text":"<p>Time before auto-cleanup occurs when a device handler has no active connection.</p> <p>Default: <code>5s</code> Environment Variable: <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --api.device-handler-timeout=10s\n</code></pre>"},{"location":"cli/server/#-apiauto-attach-local-client","title":"<code>--api.auto-attach-local-client</code>","text":"<p>Automatically attach newly added devices to a local USBIP client on the same host (localhost only). This is a convenience feature; attachment failures (tool not found, error exit) are logged but do not abort device creation.</p> <p>VIIPER expects the USBIP command-line tool to be in the PATH (should be by default) (<code>usbip</code> on Linux, <code>usbip.exe</code> on Windows). If it is missing, auto-attach will simply log an error.</p> <p>Default: <code>true</code> Environment Variable: <code>VIIPER_API_AUTO_ATTACH_LOCAL_CLIENT</code></p> <p>Disable example:</p> <pre><code>viiper server --api.auto-attach-local-client=false\n</code></pre>"},{"location":"cli/server/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection operation timeout for both USBIP and API servers.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_CONNECTION_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --connection-timeout=60s\n</code></pre>"},{"location":"cli/server/#examples","title":"Examples","text":""},{"location":"cli/server/#basic-server","title":"Basic Server","text":"<p>Start server with default settings (USBIP on :3241, API on :3242):</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/server/#custom-addresses","title":"Custom Addresses","text":"<p>Start server on custom ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre>"},{"location":"cli/server/#with-logging","title":"With Logging","text":"<p>Start server with debug logging to file:</p> <pre><code>viiper server --log.level=debug --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/server/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Start server with raw USB packet logging (useful for reverse engineering):</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre>"},{"location":"cli/server/#connect-from-a-client-usbip","title":"Connect from a client (USBIP)","text":"<p>After the server is running and a virtual device has been added to a bus (via the API), attach it from a client using USBIP.</p> <p>Notes:</p> <ul> <li>VIIPER's USBIP server listens on <code>:3241</code> by default (configurable via <code>--usb.addr</code>).</li> <li>The BUSID-DEVICEID you need (e.g. <code>1-1</code>) is returned by the API on device add and also visible via <code>usbip list</code>.</li> </ul>"},{"location":"cli/server/#linux","title":"Linux","text":"<pre><code># Load the virtual host controller (only needed once per boot)\nsudo modprobe vhci-hcd\n\n# List exportable devices on the VIIPER host\nusbip list --remote=VIIPER_HOST --tcp-port=3241\n\n# Attach a device by busid (long flags)\nsudo usbip attach --remote=VIIPER_HOST --tcp-port=3241 --busid=BUSID-DEVICEID\n\n# Equivalent short-form flags\nsudo usbip --tcp-port 3241 -r VIIPER_HOST -b BUSID-DEVICEID\n</code></pre> <p>Replace <code>VIIPER_HOST</code> with the server's hostname/IP. If you changed the USBIP port, use that port instead of <code>3241</code>.</p>"},{"location":"cli/server/#windows","title":"Windows","text":"<p>On Windows, use usbip-win2:</p> <ul> <li>GUI: use the client to add a remote host and attach by busid.</li> <li>CLI (similar flags):</li> </ul> <pre><code>usbip.exe list --remote VIIPER_HOST --tcp-port 3241\nusbip.exe attach --remote VIIPER_HOST --tcp-port 3241 --busid BUSID-DEVICEID\n</code></pre> <p>Once attached, the device will appear to the OS/applications as a local USB device.</p>"},{"location":"cli/server/#see-also","title":"See Also","text":"<ul> <li>Configuration - Environment variables and configuration files</li> <li>API Reference - API server documentation</li> </ul>"},{"location":"clients/c/","title":"C Client Library Documentation","text":"<p>The VIIPER C client library provides a lightweight, dependency-free client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/c/#overview","title":"Overview","text":"<p>The C client library features:</p> <ul> <li>Device-agnostic streaming API: Uniform interface for all device types</li> <li>Zero dependencies: Pure C99, no external libraries required</li> <li>Cross-platform: Windows (MSVC) and POSIX (GCC/Clang)</li> <li>Type-safe: Generated headers with packed structs and constants</li> <li>Thread-safe: Recommended: one <code>viiper_client_t</code> per thread</li> </ul> <p>License</p> <p>The C client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/c/#installation","title":"Installation","text":""},{"location":"clients/c/#building-from-source","title":"Building from Source","text":"<p>The C client library is generated from the VIIPER server codebase:</p> <pre><code>go run ./cmd/viiper codegen --lang=c\n</code></pre> <p>Build the client library:</p> <pre><code>cd ../clients/c\ncmake -B build -G \"Visual Studio 17 2022\"  # Windows\ncmake -B build                              # POSIX\ncmake --build build --config Release\n</code></pre>"},{"location":"clients/c/#linking-to-your-project","title":"Linking to Your Project","text":"<p>CMake:</p> <pre><code># Add viiper client library\nadd_subdirectory(path/to/clients/c)\ntarget_link_libraries(your_target PRIVATE viiper)\n\n# Copy DLL on Windows (post-build)\nif(WIN32)\n    add_custom_command(TARGET your_target POST_BUILD\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n        $&lt;TARGET_FILE:viiper&gt;\n        $&lt;TARGET_FILE_DIR:your_target&gt;\n    )\nendif()\n</code></pre> <p>Manual:</p> <ul> <li>Include: <code>clients/c/include/viiper/viiper.h</code></li> <li>Link: <code>clients/c/build/Release/viiper.lib</code> (Windows) or <code>libviiper.a</code> (POSIX)</li> <li>Runtime: Copy <code>viiper.dll</code> next to your executable (Windows)</li> </ul>"},{"location":"clients/c/#quick-start","title":"Quick Start","text":"<pre><code>#include &lt;viiper/viiper.h&gt;\n#include &lt;viiper/viiper_keyboard.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Create new Viiper client\n    viiper_client_t* client = NULL;\n    int err = viiper_client_create(\"127.0.0.1\", 3242, &amp;client);\n    if (err != 0) {\n        fprintf(stderr, \"Failed to connect: %s\\n\", viiper_strerror(err));\n        return 1;\n    }\n\n    // Create or find a bus\n    viiper_bus_list_response_t buses = {0};\n    err = viiper_bus_list(client, &amp;buses);\n    uint32_t bus_id = (buses.BusesCount &gt; 0) ? buses.Buses[0] : 0;\n\n    if (bus_id == 0) {\n        viiper_bus_create_response_t resp = {0};\n        uint32_t desired_id = 1;\n        err = viiper_bus_create(client, &amp;desired_id, &amp;resp); // NULL for auto-assign\n        bus_id = resp.BusID;\n    }\n\n    // Add device and connect (convenience function)\n    const char* device_type = \"keyboard\";\n    viiper_device_create_request_t req = {\n        .Type = &amp;device_type,\n        .IdVendor = NULL,\n        .IdProduct = NULL\n    };\n    viiper_device_info_t dev_info = {0};\n    viiper_device_t* device = NULL;\n    err = viiper_add_device_and_connect(client, bus_id, &amp;req, &amp;dev_info, &amp;device);\n\n    // Send keyboard input\n    viiper_keyboard_input_t input = {\n        .modifiers = 0,\n        .count = 1\n    };\n    uint8_t keys[] = {VIIPER_KEYBOARD_KEY_A};\n    input.keys = keys;\n    input.keys_count = 1;\n\n    err = viiper_device_send(device, &amp;input, sizeof(input.modifiers) + sizeof(input.count) + input.keys_count);\n\n    // Cleanup\n    viiper_device_close(device);\n\n    char bus_id_str[32];\n    snprintf(bus_id_str, sizeof(bus_id_str), \"%u\", bus_id);\n    viiper_device_remove_response_t remove_resp = {0};\n    viiper_bus_device_remove(client, bus_id_str, dev_info.DevId, &amp;remove_resp);\n\n    viiper_client_free(client);\n    return 0;\n}\n</code></pre>"},{"location":"clients/c/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/c/#creating-a-device-stream","title":"Creating a Device Stream","text":"<p>Manual approach (add device, then connect):</p> <pre><code>// Add device first\nconst char* device_type = \"keyboard\";\nviiper_device_create_request_t req = {\n    .Type = &amp;device_type,\n    .IdVendor = NULL,  // Optional: set to specify custom VID\n    .IdProduct = NULL  // Optional: set to specify custom PID\n};\n\nchar bus_id_str[32];\nsnprintf(bus_id_str, sizeof(bus_id_str), \"%u\", bus_id);\n\nviiper_device_info_t dev_info = {0};\nviiper_error_t err = viiper_bus_device_add(client, bus_id_str, &amp;req, &amp;dev_info);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to add device: %s\\n\", viiper_get_error(client));\n}\n\n// Then connect to its stream\nviiper_device_t* device = NULL;\nerr = viiper_open_stream(client, bus_id, dev_info.DevId, &amp;device);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to open device stream: %s\\n\", viiper_get_error(client));\n}\n</code></pre> <p>Convenience approach (add and connect in one call):</p> <pre><code>const char* device_type = \"xbox360\";\nviiper_device_create_request_t req = {\n    .Type = &amp;device_type,\n    .IdVendor = NULL,\n    .IdProduct = NULL\n};\n\nviiper_device_info_t dev_info = {0};\nviiper_device_t* device = NULL;\nviiper_error_t err = viiper_add_device_and_connect(client, bus_id, &amp;req, &amp;dev_info, &amp;device);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to add and connect device: %s\\n\", viiper_get_error(client));\n}\n</code></pre>"},{"location":"clients/c/#sending-input","title":"Sending Input","text":"<pre><code>viiper_mouse_input_t input = {\n    .buttons = VIIPER_MOUSE_BTN_LEFT,\n    .dx = 10,\n    .dy = -5,\n    .wheel = 0,\n    .pan = 0\n};\n\nint err = viiper_device_send(device, &amp;input, sizeof(input));\n</code></pre>"},{"location":"clients/c/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<pre><code>void on_led_update(void* user_data, const void* data, size_t len) {\n    if (len &lt; 1) return;\n    uint8_t leds = ((uint8_t*)data)[0];\n    printf(\"LEDs: NumLock=%d CapsLock=%d ScrollLock=%d\\n\",\n           !!(leds &amp; VIIPER_KEYBOARD_LED_NUM_LOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LED_CAPS_LOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LED_SCROLL_LOCK));\n}\n\nviiper_device_on_output(device, on_led_update, NULL);\n</code></pre>"},{"location":"clients/c/#closing-a-stream","title":"Closing a Stream","text":"<pre><code>viiper_device_close(device);\n</code></pre>"},{"location":"clients/c/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific packet formats, constants, and wire protocols. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The C client library provides generated structs and constants in device-specific headers (e.g., <code>viiper_keyboard.h</code>, <code>viiper_mouse.h</code>, <code>viiper_xbox360.h</code>).</p>"},{"location":"clients/c/#struct-packing","title":"Struct Packing","text":"<p>All device I/O structs use <code>#pragma pack(1)</code> to ensure wire compatibility (no padding).</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t buttons;\n    int8_t dx;\n    // ...\n} viiper_mouse_input_t;\n#pragma pack(pop)\n</code></pre> <p>Important: Always ensure your compiler respects packing directives. MSVC and GCC/Clang handle this correctly by default.</p>"},{"location":"clients/c/#troubleshooting","title":"Troubleshooting","text":""},{"location":"clients/c/#missing-dll-on-windows","title":"Missing DLL on Windows","text":"<p>Symptom: Application crashes immediately with \"viiper.dll not found\"</p> <p>Solution: Copy <code>viiper.dll</code> to the same directory as your executable:</p> <pre><code>add_custom_command(TARGET your_target POST_BUILD\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    $&lt;TARGET_FILE:viiper&gt;\n    $&lt;TARGET_FILE_DIR:your_target&gt;\n)\n</code></pre>"},{"location":"clients/c/#repeated-keys-not-working","title":"Repeated Keys Not Working","text":"<p>Symptom: Typing \"Hello\" outputs \"Helo\" (missing duplicate letter)</p> <p>Solution: Add sufficient delays between key press, release, and next action:</p> <pre><code>press_and_release(dev, VIIPER_KEYBOARD_KEY_L, 0);\nSleep(100);\npress_and_release(dev, VIIPER_KEYBOARD_KEY_L, 0);\n</code></pre>"},{"location":"clients/c/#struct-padding-issues","title":"Struct Padding Issues","text":"<p>Symptom: Device input is corrupted or \"spazzing\"</p> <p>Solution: Verify <code>#pragma pack(1)</code> is applied to device structs. All generated headers include this by default.</p>"},{"location":"clients/c/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/c/virtual_keyboard/main.c</code></li> <li>Types \"Hello!\" every 5 seconds</li> <li> <p>Reads LED state (NumLock, CapsLock, ScrollLock)</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/c/virtual_x360_pad/main.c</code></p> </li> <li>Simulates button presses and stick movements</li> <li>Receives rumble feedback</li> </ul> <p>Build and run:</p> <pre><code>cd examples/c\ncmake -B build -G \"Visual Studio 17 2022\"\ncmake --build build --config Release\n./build/Release/virtual_keyboard.exe 127.0.0.1:3242\n</code></pre>"},{"location":"clients/c/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How the C client library is generated</li> <li>Go Client Documentation: Reference implementation</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>C# Client Library Documentation: .NET client library</li> <li>Rust Client Library Documentation: Rust client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"clients/cpp/","title":"C++ Client Library Documentation","text":"<p>The VIIPER C++ client library provides a modern, header-only C++20 client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/cpp/#overview","title":"Overview","text":"<p>The C++ client library features:</p> <ul> <li>Header-only: No separate compilation required, just include and use</li> <li>Modern C++20: Uses concepts, designated initializers, std::optional, smart pointers</li> <li>Type-safe: Generated structs with constants and helper maps</li> <li>Callback-based output: Register lambdas for device feedback (LEDs, rumble)</li> <li>Thread-safe: Separate mutexes for send/recv operations</li> <li>Cross-platform: Windows (MSVC) and POSIX (GCC/Clang)</li> </ul> <p>JSON Parser Required</p> <p>The C++ client library requires a JSON library to be provided by the user. You must define <code>VIIPER_JSON_INCLUDE</code>, <code>VIIPER_JSON_NAMESPACE</code>, and <code>VIIPER_JSON_TYPE</code> before including the client library headers.</p> <p>Recommended: nlohmann/json - a header-only JSON library that can be easily integrated.</p> <p>License</p> <p>The C++ client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/cpp/#installation","title":"Installation","text":""},{"location":"clients/cpp/#1-header-only-integration","title":"1. Header-Only Integration","text":"<p>Copy the <code>clients/cpp/include/viiper</code> directory to your project's include path:</p> <pre><code>cp -r clients/cpp/include/viiper /path/to/your/project/include/\n</code></pre> <p>Or add it as an include directory in your build system.</p>"},{"location":"clients/cpp/#2-cmake-integration","title":"2. CMake Integration","text":"<pre><code># Add viiper include directory\ntarget_include_directories(your_target PRIVATE path/to/clients/cpp/include)\n\n# Also ensure nlohmann/json is available\n# Option A: FetchContent\ninclude(FetchContent)\nFetchContent_Declare(json\n    GIT_REPOSITORY https://github.com/nlohmann/json.git\n    GIT_TAG v3.11.3\n)\nFetchContent_MakeAvailable(json)\ntarget_link_libraries(your_target PRIVATE nlohmann_json::nlohmann_json)\n\n# Option B: Find package (if installed system-wide)\nfind_package(nlohmann_json REQUIRED)\ntarget_link_libraries(your_target PRIVATE nlohmann_json::nlohmann_json)\n</code></pre>"},{"location":"clients/cpp/#3-generating-from-source","title":"3. Generating from Source","text":"<pre><code>go run ./cmd/viiper codegen --lang=cpp\n</code></pre> <p>The client library will be generated in <code>clients/cpp/include/viiper/</code>.</p>"},{"location":"clients/cpp/#json-parser-configuration","title":"JSON Parser Configuration","text":"<p>Before including the VIIPER client library, you must configure a JSON parser. The client library is designed to work with any JSON library that provides a compatible interface.</p>"},{"location":"clients/cpp/#using-nlohmannjson-recommended","title":"Using nlohmann/json (Recommended)","text":"<pre><code>// Define these BEFORE including viiper headers\n#define VIIPER_JSON_INCLUDE &lt;nlohmann/json.hpp&gt;\n#define VIIPER_JSON_NAMESPACE nlohmann\n#define VIIPER_JSON_TYPE json\n\n#include &lt;viiper/viiper.hpp&gt;\n</code></pre>"},{"location":"clients/cpp/#using-a-custom-json-library","title":"Using a Custom JSON Library","text":"<p>Your JSON type must support:</p> <ul> <li><code>parse(const std::string&amp;)</code> \u2192 JsonType</li> <li><code>dump()</code> \u2192 std::string</li> <li><code>operator[](const std::string&amp;)</code> \u2192 JsonType</li> <li><code>contains(const std::string&amp;)</code> \u2192 bool</li> <li><code>is_number()</code>, <code>is_string()</code>, <code>is_array()</code>, <code>is_object()</code> \u2192 bool</li> <li><code>get&lt;T&gt;()</code> \u2192 T</li> <li><code>size()</code> \u2192 std::size_t (for arrays)</li> </ul> <p>Example with a custom library:</p> <pre><code>#define VIIPER_JSON_INCLUDE \"my_json_lib.hpp\"\n#define VIIPER_JSON_NAMESPACE myjson\n#define VIIPER_JSON_TYPE JsonValue\n\n#include &lt;viiper/viiper.hpp&gt;\n</code></pre>"},{"location":"clients/cpp/#quick-start","title":"Quick Start","text":"<pre><code>#define VIIPER_JSON_INCLUDE &lt;nlohmann/json.hpp&gt;\n#define VIIPER_JSON_NAMESPACE nlohmann\n#define VIIPER_JSON_TYPE json\n\n#include &lt;viiper/viiper.hpp&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create new Viiper client\n    viiper::ViiperClient client(\"localhost\", 3242);\n\n    // Find or create a bus\n    auto buses_result = client.buslist();\n    if (buses_result.is_error()) {\n        std::cerr &lt;&lt; \"BusList error: \" &lt;&lt; buses_result.error().to_string() &lt;&lt; \"\\n\";\n        return 1;\n    }\n\n    std::uint32_t bus_id;\n    if (buses_result.value().buses.empty()) {\n        auto create_result = client.buscreate(std::nullopt);  // Auto-assign ID\n        if (create_result.is_error()) {\n            std::cerr &lt;&lt; \"BusCreate error: \" &lt;&lt; create_result.error().to_string() &lt;&lt; \"\\n\";\n            return 1;\n        }\n        bus_id = create_result.value().busid;\n    } else {\n        bus_id = buses_result.value().buses[0];\n    }\n\n    // Add device\n    auto device_result = client.busdeviceadd(bus_id, {.type = \"keyboard\"});\n    if (device_result.is_error()) {\n        std::cerr &lt;&lt; \"AddDevice error: \" &lt;&lt; device_result.error().to_string() &lt;&lt; \"\\n\";\n        return 1;\n    }\n    auto device_info = std::move(device_result.value());\n\n    // Connect to device stream\n    auto stream_result = client.connectDevice(device_info.busid, device_info.devid);\n    if (stream_result.is_error()) {\n        std::cerr &lt;&lt; \"Connect error: \" &lt;&lt; stream_result.error().to_string() &lt;&lt; \"\\n\";\n        return 1;\n    }\n    auto stream = std::move(stream_result.value());\n\n    std::cout &lt;&lt; \"Connected to device \" &lt;&lt; device_info.devid\n              &lt;&lt; \" on bus \" &lt;&lt; device_info.busid &lt;&lt; \"\\n\";\n\n    // Send keyboard input\n    viiper::keyboard::Input input = {\n        .modifiers = viiper::keyboard::ModLeftShift,\n        .keys = {viiper::keyboard::KeyH},\n    };\n    stream-&gt;send(input);\n\n    // Cleanup\n    client.busdeviceremove(device_info.busid, device_info.devid);\n\n    return 0;\n}\n</code></pre>"},{"location":"clients/cpp/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/cpp/#creating-a-device-stream","title":"Creating a Device Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>auto [device_info, stream] = client.addDeviceAndConnect(bus_id, {.type = \"xbox360\"}).value();\n</code></pre> <p>With custom VID/PID:</p> <pre><code>viiper::Devicecreaterequest req = {\n    .type = \"keyboard\",\n    .idvendor = 0x1234,\n    .idproduct = 0x5678\n};\nauto [device_info, stream] = client.addDeviceAndConnect(bus_id, req).value();\n</code></pre> <p>Or manually add and connect:</p> <pre><code>auto device_result = client.busdeviceadd(bus_id, {.type = \"keyboard\"});\nauto device_info = device_result.value();\n\nauto stream_result = client.connectDevice(device_info.busid, device_info.devid);\nauto stream = std::move(stream_result.value());\n</code></pre>"},{"location":"clients/cpp/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated structs:</p> <p>Keyboard:</p> <pre><code>viiper::keyboard::Input input = {\n    .modifiers = viiper::keyboard::ModLeftShift,\n    .keys = {viiper::keyboard::KeyH, viiper::keyboard::KeyE},\n};\nstream-&gt;send(input);\n</code></pre> <p>Mouse:</p> <pre><code>viiper::mouse::Input input = {\n    .buttons = viiper::mouse::ButtonLeft,\n    .x = 10,\n    .y = -5,\n    .wheel = 0,\n};\nstream-&gt;send(input);\n</code></pre> <p>Xbox360 Controller:</p> <pre><code>viiper::xbox360::Input input = {\n    .buttons = viiper::xbox360::ButtonA,\n    .lt = 255,           // Left trigger (0-255)\n    .rt = 0,             // Right trigger (0-255)\n    .lx = -32768,        // Left stick X (-32768 to 32767)\n    .ly = 32767,         // Left stick Y\n    .rx = 0,             // Right stick X\n    .ry = 0,             // Right stick Y\n};\nstream-&gt;send(input);\n</code></pre>"},{"location":"clients/cpp/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<p>For devices that send feedback (rumble, LEDs), register a callback:</p> <p>Keyboard LEDs:</p> <pre><code>stream-&gt;on_output(viiper::keyboard::OUTPUT_SIZE, [](const std::uint8_t* data, std::size_t len) {\n    if (len &lt; viiper::keyboard::OUTPUT_SIZE) return;\n    auto result = viiper::keyboard::Output::from_bytes(data, len);\n    if (result.is_error()) return;\n\n    auto&amp; leds = result.value();\n    bool num_lock = (leds.leds &amp; viiper::keyboard::LEDNumLock) != 0;\n    bool caps_lock = (leds.leds &amp; viiper::keyboard::LEDCapsLock) != 0;\n    std::cout &lt;&lt; \"LEDs: Num=\" &lt;&lt; num_lock &lt;&lt; \" Caps=\" &lt;&lt; caps_lock &lt;&lt; \"\\n\";\n});\n</code></pre> <p>Xbox360 Rumble:</p> <pre><code>stream-&gt;on_output(viiper::xbox360::OUTPUT_SIZE, [](const std::uint8_t* data, std::size_t len) {\n    if (len &lt; viiper::xbox360::OUTPUT_SIZE) return;\n    auto result = viiper::xbox360::Output::from_bytes(data, len);\n    if (result.is_error()) return;\n\n    auto&amp; rumble = result.value();\n    std::cout &lt;&lt; \"Rumble: Left=\" &lt;&lt; static_cast&lt;int&gt;(rumble.left)\n              &lt;&lt; \", Right=\" &lt;&lt; static_cast&lt;int&gt;(rumble.right) &lt;&lt; \"\\n\";\n});\n</code></pre>"},{"location":"clients/cpp/#event-handlers","title":"Event Handlers","text":"<pre><code>// Called when the server disconnects the device\nstream-&gt;on_disconnect([]() {\n    std::cerr &lt;&lt; \"Device disconnected by server\\n\";\n});\n\n// Called on stream errors\nstream-&gt;on_error([](const viiper::Error&amp; err) {\n    std::cerr &lt;&lt; \"Stream error: \" &lt;&lt; err.to_string() &lt;&lt; \"\\n\";\n});\n</code></pre>"},{"location":"clients/cpp/#stopping-a-device","title":"Stopping a Device","text":"<pre><code>stream-&gt;stop();  // Stops the output thread and closes the connection\n</code></pre> <p>The device is also automatically stopped when the <code>ViiperDevice</code> is destroyed.</p>"},{"location":"clients/cpp/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The C++ client library automatically generates constants and helper maps for each device type.</p>"},{"location":"clients/cpp/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Codes:</p> <pre><code>auto key = viiper::keyboard::KeyA;           // 0x04\nauto f1 = viiper::keyboard::KeyF1;           // 0x3A\nauto enter = viiper::keyboard::KeyEnter;     // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>std::uint8_t mods = viiper::keyboard::ModLeftShift | viiper::keyboard::ModLeftCtrl;\n</code></pre> <p>LED Flags:</p> <pre><code>bool num_lock = (leds &amp; viiper::keyboard::LEDNumLock) != 0;\nbool caps_lock = (leds &amp; viiper::keyboard::LEDCapsLock) != 0;\n</code></pre>"},{"location":"clients/cpp/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CHAR_TO_KEY Map - Convert ASCII characters to key codes:</p> <pre><code>auto it = viiper::keyboard::CHAR_TO_KEY.find(static_cast&lt;std::uint8_t&gt;('a'));\nif (it != viiper::keyboard::CHAR_TO_KEY.end()) {\n    std::uint8_t key = it-&gt;second;  // KeyA\n}\n</code></pre> <p>KEY_NAME Array - Get human-readable key names:</p> <pre><code>for (const auto&amp; [key, name] : viiper::keyboard::KEY_NAME) {\n    if (key == viiper::keyboard::KeyF1) {\n        std::cout &lt;&lt; \"Key name: \" &lt;&lt; name &lt;&lt; \"\\n\";  // \"F1\"\n        break;\n    }\n}\n</code></pre> <p>SHIFT_CHARS Set - Check if a character requires shift:</p> <pre><code>bool needs_shift = viiper::keyboard::SHIFT_CHARS.contains(static_cast&lt;std::uint8_t&gt;('A'));\n</code></pre>"},{"location":"clients/cpp/#xbox360-constants","title":"Xbox360 Constants","text":"<p>Button Flags:</p> <pre><code>std::uint16_t buttons = viiper::xbox360::ButtonA | viiper::xbox360::ButtonB;\n</code></pre> <p>All Button Constants:</p> <pre><code>viiper::xbox360::ButtonDPadUp\nviiper::xbox360::ButtonDPadDown\nviiper::xbox360::ButtonDPadLeft\nviiper::xbox360::ButtonDPadRight\nviiper::xbox360::ButtonStart\nviiper::xbox360::ButtonBack\nviiper::xbox360::ButtonLThumb\nviiper::xbox360::ButtonRThumb\nviiper::xbox360::ButtonLShoulder\nviiper::xbox360::ButtonRShoulder\nviiper::xbox360::ButtonGuide\nviiper::xbox360::ButtonA\nviiper::xbox360::ButtonB\nviiper::xbox360::ButtonX\nviiper::xbox360::ButtonY\n</code></pre>"},{"location":"clients/cpp/#practical-example-typing-text","title":"Practical Example: Typing Text","text":"<p>Using the generated maps to type a string:</p> <pre><code>void type_string(viiper::ViiperDevice&amp; stream, const std::string&amp; text) {\n    for (char ch : text) {\n        auto it = viiper::keyboard::CHAR_TO_KEY.find(static_cast&lt;std::uint8_t&gt;(ch));\n        if (it == viiper::keyboard::CHAR_TO_KEY.end()) continue;\n        std::uint8_t key = it-&gt;second;\n\n        std::uint8_t mods = 0;\n        if (viiper::keyboard::SHIFT_CHARS.contains(static_cast&lt;std::uint8_t&gt;(ch))) {\n            mods = viiper::keyboard::ModLeftShift;\n        }\n\n        // Press key\n        viiper::keyboard::Input down = {\n            .modifiers = mods,\n            .keys = {key},\n        };\n        stream.send(down);\n        std::this_thread::sleep_for(std::chrono::milliseconds(50));\n\n        // Release key\n        viiper::keyboard::Input up = {\n            .modifiers = 0,\n            .keys = {},\n        };\n        stream.send(up);\n        std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    }\n}\n\n// Usage\ntype_string(*stream, \"Hello, World!\");\n</code></pre>"},{"location":"clients/cpp/#error-handling","title":"Error Handling","text":"<p>All API methods return <code>Result&lt;T&gt;</code>, which is either a value or an error:</p> <pre><code>auto result = client.buslist();\nif (result.is_error()) {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; result.error().to_string() &lt;&lt; \"\\n\";\n    return 1;\n}\nauto buses = result.value();\n</code></pre> <p>Using the value directly (throws on error):</p> <pre><code>// Only use if you're certain the operation succeeded\nauto buses = client.buslist().value();\n</code></pre>"},{"location":"clients/cpp/#resource-management","title":"Resource Management","text":"<p><code>ViiperDevice</code> is managed via <code>std::unique_ptr</code> and automatically cleans up:</p> <pre><code>{\n    auto stream = client.connectDevice(bus_id, device_id).value();\n    // ... use stream ...\n}  // stream-&gt;stop() called automatically\n</code></pre>"},{"location":"clients/cpp/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/cpp/virtual_keyboard.cpp</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/cpp/virtual_mouse.cpp</code></p> </li> <li>Moves cursor in a circle pattern</li> <li> <p>Demonstrates button clicks</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/cpp/virtual_x360_pad.cpp</code></p> </li> <li>Cycles through buttons A, B, X, Y</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/cpp/#building-examples","title":"Building Examples","text":"<pre><code>cd examples/cpp\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\ncmake --build . --config Release\n</code></pre>"},{"location":"clients/cpp/#running-examples","title":"Running Examples","text":"<pre><code>./virtual_keyboard localhost:3242\n./virtual_mouse localhost:3242\n./virtual_x360_pad localhost:3242\n</code></pre>"},{"location":"clients/cpp/#project-structure","title":"Project Structure","text":"<p>Generated SDK layout:</p> <pre><code>clients/cpp/include/viiper/\n\u251c\u2500\u2500 viiper.hpp              # Main include (includes all others)\n\u251c\u2500\u2500 config.hpp              # JSON configuration macros\n\u251c\u2500\u2500 error.hpp               # Result&lt;T&gt; and Error types\n\u251c\u2500\u2500 types.hpp               # API request/response types\n\u251c\u2500\u2500 client.hpp              # ViiperClient management API\n\u251c\u2500\u2500 device.hpp              # ViiperDevice stream wrapper\n\u251c\u2500\u2500 detail/\n\u2502   \u251c\u2500\u2500 socket.hpp          # Cross-platform socket wrapper\n\u2502   \u2514\u2500\u2500 json.hpp            # JSON parsing helpers\n\u2514\u2500\u2500 devices/\n    \u251c\u2500\u2500 keyboard.hpp        # Keyboard constants, Input, Output\n    \u251c\u2500\u2500 mouse.hpp           # Mouse constants, Input\n    \u2514\u2500\u2500 xbox360.hpp         # Xbox360 constants, Input, Output\n</code></pre>"},{"location":"clients/cpp/#requirements","title":"Requirements","text":"<ul> <li>C++20 or later</li> <li>JSON library (nlohmann/json recommended)</li> <li>Platform: Windows (MSVC 2019+) or POSIX (GCC 10+, Clang 10+)</li> </ul>"},{"location":"clients/cpp/#windows-specific","title":"Windows-Specific","text":"<p>The client library uses Winsock2 for networking. Link against <code>Ws2_32.lib</code> (done automatically via <code>#pragma comment</code>).</p>"},{"location":"clients/cpp/#posix-specific","title":"POSIX-specific","text":"<p>Standard POSIX sockets are used. No additional libraries required.</p>"},{"location":"clients/cpp/#troubleshooting","title":"Troubleshooting","text":"<p>Error: VIIPER_JSON_INCLUDE must be defined</p> <p>You must define the JSON macros before including any VIIPER headers:</p> <pre><code>#define VIIPER_JSON_INCLUDE &lt;nlohmann/json.hpp&gt;\n#define VIIPER_JSON_NAMESPACE nlohmann\n#define VIIPER_JSON_TYPE json\n\n#include &lt;viiper/viiper.hpp&gt;  // Include AFTER the defines\n</code></pre> <p>Linker errors on Windows</p> <p>Ensure Winsock2 is linked. If not using the auto-link pragma, add:</p> <pre><code>target_link_libraries(your_target PRIVATE Ws2_32)\n</code></pre> <p>Connection refused</p> <p>Verify the VIIPER server is running:</p> <pre><code>viiper server --api-addr localhost:3242\n</code></pre>"},{"location":"clients/cpp/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>C Client Library Documentation: Pure C alternative</li> <li>Rust Client Library Documentation: Rust client library with sync/async support</li> <li>C# Client Library Documentation: .NET client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"clients/csharp/","title":"C# Client Library Documentation","text":"<p>The VIIPER C# client library provides a modern, type-safe .NET client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/csharp/#overview","title":"Overview","text":"<p>The C# client library features:</p> <ul> <li>Async/await support: Full async API with cancellation token support</li> <li>Type-safe: Generated classes with enums, structs, and helper maps</li> <li>Event-driven: <code>OnOutput</code> event for device feedback (LEDs, rumble)</li> <li>Modern .NET: Targets .NET 8.0 with nullable reference types</li> <li>Zero external dependencies: Uses only built-in .NET libraries</li> </ul> <p>License</p> <p>The C# client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/csharp/#installation","title":"Installation","text":""},{"location":"clients/csharp/#1-using-the-published-nuget-package-recommended","title":"1. Using the Published NuGet Package (Recommended)","text":"<p>Install the stable package:</p> <pre><code>dotnet add package Viiper.Client\n</code></pre> <p>Package page: Viiper.Client on NuGet</p> <p>Pre-release / snapshot builds are not published to NuGet. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p> <p>To use a snapshot <code>.nupkg</code> from a GitHub Release:</p> <pre><code># 1. Download viiper-csharp-sdk-nupkg-Release.nupkg (or Snapshot) to ./packages\nmkdir -p packages\ncp /path/to/downloaded/viiper-csharp-sdk-nupkg.nupkg packages/\n\n# 2. Add a temporary local source and install\ndotnet nuget add source ./packages --name viiper-local || true\ndotnet add package Viiper.Client --source viiper-local\n</code></pre> <p>Or add directly in your <code>.csproj</code> (stable only):</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Viiper.Client\" Version=\"*\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#2-project-reference-for-local-development-against-source","title":"2. Project Reference (For Local Development Against Source)","text":"<p>Use this when modifying the generator or contributing new device types:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;ProjectReference Include=\"..\\..\\clients\\csharp\\Viiper.Client\\Viiper.Client.csproj\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#3-generating-from-source-advanced-contributors","title":"3. Generating from Source (Advanced / Contributors)","text":"<p>Only required when enhancing VIIPER itself:</p> <pre><code>go run ./cmd/viiper codegen --lang=csharp\ncd clients/csharp\ndotnet build -c Release Viiper.Client\n</code></pre>"},{"location":"clients/csharp/#quick-start","title":"Quick Start","text":"<pre><code>using Viiper.Client;\nusing Viiper.Client.Devices.Keyboard;\n\n// Create new Viiper client\nvar client = new ViiperClient(\"localhost\", 3242);\n\n// Find or create a bus\nvar buses = await client.BusListAsync();\nuint busId;\nif (buses.Buses.Length == 0)\n{\n    var resp = await client.BusCreateAsync(null); // null = auto-assign ID\n    // Or specify ID: await client.BusCreateAsync(5);\n    busId = resp.BusID;\n}\nelse\n{\n    busId = buses.Buses[0];\n}\n\n// Add device and connect\nvar deviceReq = new DeviceCreateRequest { Type = \"keyboard\" };\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n\nConsole.WriteLine($\"Connected to device {deviceResp.BusID}-{deviceResp.DevId}\");\n\n// Send keyboard input\nvar input = new KeyboardInput\n{\n    Modifiers = (byte)Mod.LeftShift,\n    Count = 1,\n    Keys = new[] { (byte)Key.H }\n};\nawait device.SendAsync(input);\n\n// Cleanup\nawait client.BusDeviceRemoveAsync(busId, deviceResp.DevId);\n</code></pre>"},{"location":"clients/csharp/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/csharp/#creating-a-device-stream","title":"Creating a Device Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>var deviceReq = new DeviceCreateRequest { Type = \"xbox360\" };\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n</code></pre> <p>With custom VID/PID:</p> <pre><code>var deviceReq = new DeviceCreateRequest { \n    Type = \"keyboard\", \n    IdVendor = 0x1234, \n    IdProduct = 0x5678 \n};\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>var device = await client.ConnectDeviceAsync(busId, deviceId);\n</code></pre>"},{"location":"clients/csharp/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated structs with async methods:</p> <pre><code>using Viiper.Client.Devices.Xbox360;\n\nvar input = new Xbox360Input\n{\n    Buttons = (uint)Button.A,\n    LeftTrigger = 255,\n    RightTrigger = 0,\n    ThumbLX = -32768,  // Left stick left\n    ThumbLY = 32767,   // Left stick up\n    ThumbRX = 0,\n    ThumbRY = 0\n};\nawait device.SendAsync(input);\n</code></pre>"},{"location":"clients/csharp/#receiving-output-events","title":"Receiving Output (Events)","text":"<p>For devices that send feedback (rumble, LEDs), subscribe to the <code>OnOutput</code> event:</p> <pre><code>using Viiper.Client.Devices.Keyboard;\n\ndevice.OnOutput += data =&gt;\n{\n    if (data.Length &lt; 1) return;\n    byte leds = data[0];\n\n    Console.WriteLine($\"LEDs: \" +\n        $\"Num={(leds &amp; (byte)LED.NumLock) != 0} \" +\n        $\"Caps={(leds &amp; (byte)LED.CapsLock) != 0} \" +\n        $\"Scroll={(leds &amp; (byte)LED.ScrollLock) != 0}\");\n};\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>using Viiper.Client.Devices.Xbox360;\n\ndevice.OnOutput += data =&gt;\n{\n    if (data.Length &lt; 2) return;\n    byte leftMotor = data[0];\n    byte rightMotor = data[1];\n    Console.WriteLine($\"Rumble: Left={leftMotor} Right={rightMotor}\");\n};\n</code></pre>"},{"location":"clients/csharp/#closing-a-device","title":"Closing a Device","text":"<pre><code>device.Dispose();\n// or\nawait using var device = await client.ConnectDeviceAsync(busId, deviceId);\n</code></pre>"},{"location":"clients/csharp/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The C# client library automatically generates enums and helper maps for each device type.</p>"},{"location":"clients/csharp/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Enum:</p> <pre><code>using Viiper.Client.Devices.Keyboard;\n\nvar key = Key.A;               // 0x04\nvar f1 = Key.F1;               // 0x3A\nvar enter = Key.Enter;         // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>var mods = (byte)(Mod.LeftShift | Mod.LeftCtrl);  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>bool numLock = (leds &amp; (byte)LED.NumLock) != 0;\nbool capsLock = (leds &amp; (byte)LED.CapsLock) != 0;\n</code></pre>"},{"location":"clients/csharp/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CharToKey Map - Convert ASCII characters to key codes:</p> <pre><code>if (CharToKey.TryGetValue((byte)'A', out var key))\n{\n    Console.WriteLine($\"'A' maps to {key}\");  // Key.A\n}\n</code></pre> <p>KeyName Map - Get human-readable key names:</p> <pre><code>if (KeyName.TryGetValue((byte)Key.F1, out var name))\n{\n    Console.WriteLine($\"Key name: {name}\");  // \"F1\"\n}\n</code></pre> <p>ShiftChars Map - Check if a character requires shift:</p> <pre><code>bool needsShift = ShiftChars.ContainsKey((byte)'A');  // true for uppercase\n</code></pre>"},{"location":"clients/csharp/#practical-example-typing-text","title":"Practical Example: Typing Text","text":"<p>Using the generated maps to type a string:</p> <pre><code>async Task TypeString(ViiperDevice device, string text)\n{\n    foreach (char c in text)\n    {\n        if (!CharToKey.TryGetValue((byte)c, out var key))\n            continue;\n\n        byte mods = ShiftChars.ContainsKey((byte)c) \n            ? (byte)Mod.LeftShift \n            : (byte)0;\n\n        // Press\n        await device.SendAsync(new KeyboardInput\n        {\n            Modifiers = mods,\n            Count = 1,\n            Keys = new[] { (byte)key }\n        });\n        await Task.Delay(50);\n\n        // Release\n        await device.SendAsync(new KeyboardInput\n        {\n            Modifiers = 0,\n            Count = 0,\n            Keys = Array.Empty&lt;byte&gt;()\n        });\n        await Task.Delay(50);\n    }\n}\n\n// Usage\nawait TypeString(device, \"Hello, World!\");\n</code></pre>"},{"location":"clients/csharp/#device-specific-wire-formats","title":"Device-Specific Wire Formats","text":""},{"location":"clients/csharp/#keyboard-input","title":"Keyboard Input","text":"<pre><code>public struct KeyboardInput\n{\n    public byte Modifiers;    // Modifier flags (Ctrl, Shift, Alt, GUI)\n    public byte Count;        // Number of keys in Keys array\n    public byte[] Keys;       // Key codes (max 6 for HID compliance)\n}\n</code></pre> <p>Wire format: 1 byte modifiers + 1 byte count + N bytes keys (variable-length)</p>"},{"location":"clients/csharp/#keyboard-output-leds","title":"Keyboard Output (LEDs)","text":"<pre><code>// Single byte with LED flags\nbyte leds = data[0];\nbool numLock = (leds &amp; (byte)LED.NumLock) != 0;\n</code></pre>"},{"location":"clients/csharp/#xbox360-input","title":"Xbox360 Input","text":"<pre><code>public struct Xbox360Input\n{\n    public ushort Buttons;     // Button flags\n    public byte LeftTrigger;   // 0-255\n    public byte RightTrigger;  // 0-255\n    public short ThumbLX;      // -32768 to 32767\n    public short ThumbLY;      // -32768 to 32767\n    public short ThumbRX;      // -32768 to 32767\n    public short ThumbRY;      // -32768 to 32767\n}\n</code></pre> <p>Wire format: Fixed 14 bytes, packed structure</p>"},{"location":"clients/csharp/#xbox360-output-rumble","title":"Xbox360 Output (Rumble)","text":"<pre><code>// Two bytes: left motor + right motor (0-255 each)\nbyte leftMotor = data[0];\nbyte rightMotor = data[1];\n</code></pre>"},{"location":"clients/csharp/#mouse-input","title":"Mouse Input","text":"<pre><code>public struct MouseInput\n{\n    public byte Buttons;  // Button flags\n    public sbyte X;       // Relative X movement (-128 to 127)\n    public sbyte Y;       // Relative Y movement (-128 to 127)\n    public sbyte Wheel;   // Vertical scroll\n    public sbyte Pan;     // Horizontal scroll\n}\n</code></pre> <p>Wire format: Fixed 5 bytes, packed structure</p>"},{"location":"clients/csharp/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/csharp/#custom-timeouts","title":"Custom Timeouts","text":"<pre><code>var client = new ViiperClient(\"localhost\", 3242)\n{\n    Timeout = TimeSpan.FromSeconds(10)\n};\n</code></pre> <p>Default timeout is 5 seconds.</p>"},{"location":"clients/csharp/#cancellation-tokens","title":"Cancellation Tokens","text":"<p>All async methods support cancellation:</p> <pre><code>using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));\n\ntry\n{\n    var buses = await client.BusListAsync(cts.Token);\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Request timed out\");\n}\n</code></pre>"},{"location":"clients/csharp/#error-handling","title":"Error Handling","text":"<p>The server returns errors as JSON. The client throws exceptions:</p> <pre><code>try\n{\n    await client.BusCreateAsync(\"invalid-bus-id\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Request failed: {ex.Message}\");\n}\n</code></pre>"},{"location":"clients/csharp/#resource-management","title":"Resource Management","text":"<p><code>ViiperDevice</code> implements <code>IDisposable</code>:</p> <pre><code>await using var device = await client.ConnectDeviceAsync(busId, deviceId);\n// Device automatically closed when scope exits\n</code></pre> <p>Or manual cleanup:</p> <pre><code>try\n{\n    var device = await client.ConnectDeviceAsync(busId, deviceId);\n    // ... use device ...\n}\nfinally\n{\n    device.Dispose();\n}\n</code></pre>"},{"location":"clients/csharp/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/csharp/virtual_keyboard/Program.cs</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/csharp/virtual_mouse/Program.cs</code></p> </li> <li>Moves cursor in a circle pattern</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/csharp/virtual_x360_pad/Program.cs</code></p> </li> <li>Presses buttons and moves sticks</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/csharp/#running-examples","title":"Running Examples","text":"<pre><code>cd examples/csharp/virtual_keyboard\ndotnet run -- localhost\n</code></pre>"},{"location":"clients/csharp/#project-structure","title":"Project Structure","text":"<p>Generated client library layout:</p> <pre><code>clients/csharp/Viiper.Client/\n\u251c\u2500\u2500 ViiperClient.cs              # Management API client\n\u251c\u2500\u2500 ViiperDevice.cs              # Device stream wrapper\n\u251c\u2500\u2500 Types/\n\u2502   \u251c\u2500\u2500 BusListResponse.cs       # API response types\n\u2502   \u251c\u2500\u2500 BusCreateResponse.cs\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 Devices/\n        \u251c\u2500\u2500 Keyboard/\n        \u2502   \u251c\u2500\u2500 KeyboardInput.cs     # Wire format struct\n        \u2502   \u2514\u2500\u2500 KeyboardConstants.cs # Enums + maps\n        \u251c\u2500\u2500 Mouse/\n        \u2502   \u251c\u2500\u2500 MouseInput.cs\n        \u2502   \u2514\u2500\u2500 MouseConstants.cs\n        \u2514\u2500\u2500 Xbox360/\n                \u251c\u2500\u2500 Xbox360Input.cs\n                \u251c\u2500\u2500 Xbox360Output.cs\n                \u2514\u2500\u2500 Xbox360Constants.cs\n</code></pre>"},{"location":"clients/csharp/#troubleshooting","title":"Troubleshooting","text":"<p>Build Errors:</p> <p>Ensure you have .NET 8.0 SDK installed:</p> <pre><code>dotnet --version  # Should be 8.0 or higher\n</code></pre> <p>Nullable Reference Warnings:</p> <p>The generated code uses nullable annotations. You may see warnings like CS8601/CS8625. These are safe to ignore or suppress in your project file:</p> <pre><code>&lt;PropertyGroup&gt;\n    &lt;NoWarn&gt;$(NoWarn);CS8601;CS8625&lt;/NoWarn&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>Go Client Documentation: Reference implementation patterns</li> <li>Rust Client Library Documentation: Rust client library with sync/async support</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>C Client Library Documentation: Alternative client library for native integration</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"clients/generator/","title":"VIIPER Client Generator Documentation","text":""},{"location":"clients/generator/#overview","title":"Overview","text":"<p>The VIIPER client generator scans Go source code to extract API routes, device wire formats, and constants; then emits type-safe client libraries for multiple languages.</p> <p>What it extracts:</p> <ul> <li>API routes and DTOs from management API handlers  </li> <li>Device wire formats from <code>viiper:wire</code> comment tags  </li> <li>All exported constants from device packages (automatic)</li> </ul> <p>Output: Type-safe client libraries for multiple target languages</p> <p>License</p> <p>All generated client libraries are licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/generator/#running-the-generator","title":"Running the Generator","text":"<pre><code>go run ./cmd/viiper codegen --lang=all        # Generate all client libraries\ngo run ./cmd/viiper codegen --lang=c          # Generate C client library only\ngo run ./cmd/viiper codegen --lang=csharp     # Generate C# client library only\ngo run ./cmd/viiper codegen --lang=typescript # Generate TypeScript client library only\n</code></pre> <p>Output directory: <code>clients/</code> (relative to repository root)</p>"},{"location":"clients/generator/#comment-tag-system","title":"Comment Tag System","text":"<p>The generator uses lightweight comment tags placed next to device types and constants.</p>"},{"location":"clients/generator/#viiperwire-device-stream-formats","title":"<code>viiper:wire</code>: Device Stream Formats","text":"<p>Syntax:</p> <pre><code>// viiper:wire &lt;device&gt; &lt;direction&gt; &lt;field1:type&gt; &lt;field2:type&gt; ...\n</code></pre> <p>Directions: </p> <ul> <li><code>c2s</code>: Client to server (input)  </li> <li><code>s2c</code>: Server to client (output, e.g., rumble, LEDs)</li> </ul> <p>Field types: </p> <ul> <li>Fixed: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code> </li> <li>Variable: <code>u8*countField</code> (pointer to count field)</li> </ul> <p>Example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct { ... }\n</code></pre>"},{"location":"clients/generator/#constant-and-map-export","title":"Constant and Map Export","text":"<p>The generator automatically exports all constants and map literals from <code>/device/*/const.go</code> for each device type. No special tags are required. Exported Go constants and maps are emitted with language-appropriate representations:</p> <ul> <li>Constants: Grouped into enums (C#/TS) or <code>#define</code> macros (C) based on common prefixes</li> <li>Maps: Converted to Dictionary/Map/lookup functions with helper methods</li> </ul>"},{"location":"clients/generator/#code-generation-flow","title":"Code Generation Flow","text":"<p>Scan Phase: </p> <ol> <li>Parse API routes from <code>internal/server/api/*.go</code> </li> <li>Reflect response DTOs from <code>/apitypes/*.go</code> </li> <li>Find device types via <code>RegisterDevice()</code> calls  </li> <li>Parse <code>viiper:wire</code> comments for packet layouts  </li> <li>Extract all exported constants and map literals from <code>/device/*/const.go</code> (automatic)</li> </ol> <p>Emit Phase: For each language, generate management client, DTO types, device streams, constants, and build configs.</p> <p>Post-Process: Optional formatting with <code>clang-format</code>, <code>dotnet format</code>, or <code>prettier</code>.</p>"},{"location":"clients/generator/#wire-format-mapping-rules","title":"Wire Format Mapping Rules","text":""},{"location":"clients/generator/#fixed-size-fields","title":"Fixed-Size Fields","text":"<p>Fixed-size fields are mapped to native integer types in each target language:</p> <ul> <li><code>u8</code> / <code>i8</code>: 8-bit unsigned/signed integers</li> <li><code>u16</code> / <code>i16</code>: 16-bit unsigned/signed integers</li> <li><code>u32</code> / <code>i32</code>: 32-bit unsigned/signed integers</li> </ul>"},{"location":"clients/generator/#variable-length-fields","title":"Variable-Length Fields","text":"<p>Variable-length arrays use a pointer + count pattern. The field syntax <code>u8*count</code> references a count field that determines the array length.</p> <p>Wire tag example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\n</code></pre> <p>Each target language emits appropriate types for dynamic arrays (pointers with counts, managed arrays, or typed arrays depending on the language).</p>"},{"location":"clients/generator/#struct-packing","title":"Struct Packing","text":"<p>For wire compatibility, all device I/O structs are tightly packed (no padding).</p> <ul> <li>C: <code>#pragma pack(push, 1)</code> / <code>#pragma pack(pop)</code></li> <li>C#: <code>[StructLayout(LayoutKind.Sequential, Pack = 1)]</code></li> <li>TypeScript: Manual byte-level encoding/decoding</li> </ul>"},{"location":"clients/generator/#example-keyboard-input-variable-length","title":"Example: Keyboard Input (Variable-Length)","text":"<p>Go source with wire tag:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct {\n    Modifiers uint8\n    KeyBitmap [32]uint8  // Internal: 256-bit NKR bitmap\n}\n</code></pre> <p>Emitted C struct:</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t modifiers;\n    uint8_t count;\n    uint8_t* keys;\n    size_t keys_count;\n} viiper_keyboard_input_t;\n#pragma pack(pop)\n</code></pre>"},{"location":"clients/generator/#example-constant-and-map-export","title":"Example: Constant and Map Export","text":"<p>Go source (<code>/device/keyboard/const.go</code>):</p> <pre><code>const (\n    ModLeftCtrl  = 0x01\n    ModLeftShift = 0x02\n    KeyA = 0x04\n    KeyB = 0x05\n    // ...\n)\n\nvar CharToKey = map[byte]byte{\n    'a': KeyA,\n    'b': KeyB,\n    '\\n': KeyEnter,\n    // ...\n}\n</code></pre> <p>Emitted C header (<code>viiper_keyboard.h</code>):</p> <pre><code>#define VIIPER_KEYBOARD_MOD_LEFT_CTRL 0x1\n#define VIIPER_KEYBOARD_MOD_LEFT_SHIFT 0x2\n#define VIIPER_KEYBOARD_KEY_A 0x4\n#define VIIPER_KEYBOARD_KEY_B 0x5\n\n// Map lookup function\nint viiper_keyboard_char_to_key_lookup(uint8_t key, uint8_t* out_value);\n</code></pre> <p>Emitted C# (<code>KeyboardConstants.cs</code>):</p> <pre><code>public enum Mod : uint\n{\n    LeftCtrl = 0x01,\n    LeftShift = 0x02,\n    // ...\n}\n\npublic enum Key : uint\n{\n    A = 0x04,\n    B = 0x05,\n    // ...\n}\n\npublic static class CharToKey\n{\n    private static readonly Dictionary&lt;byte, Key&gt; _map = new()\n    {\n        { (byte)'a', Key.A },\n        { (byte)'b', Key.B },\n        { (byte)'\\n', Key.Enter },\n        // ...\n    };\n\n    public static bool TryGetValue(byte key, out Key value)\n    {\n        return _map.TryGetValue(key, out value);\n    }\n}\n</code></pre>"},{"location":"clients/generator/#regeneration-triggers","title":"Regeneration Triggers","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>/apitypes/*.go</code>: API response structures</li> <li><code>/device/*/inputstate.go</code>: Wire tag annotations</li> <li><code>/device/*/const.go</code>: Exported constants and map literals</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li><code>internal/codegen/generator/**/*.go</code>: Generator templates</li> <li><code>internal/codegen/scanner/**/*.go</code>: Scanner logic (constants, maps, wire tags)</li> </ul>"},{"location":"clients/generator/#language-specific-notes","title":"Language-Specific Notes","text":"<ul> <li>C: <code>#define</code> macros for constants; switch-based lookup functions for maps; manual memory management for variable-length fields; builds with CMake.  </li> <li>C#: Enums for constant groups; <code>Dictionary&lt;K,V&gt;</code> with static helper methods for maps; <code>ViiperDevice</code> class with <code>OnOutput</code> event; async/await for management API; struct packing via attributes.  </li> <li>TypeScript: Enums for constant groups; <code>Record&lt;K, V&gt;</code> objects with <code>Get</code>/<code>Has</code> helper functions for maps; manual byte encoding via <code>BinaryWriter</code>/<code>BinaryReader</code>; <code>ViiperDevice</code> class with EventEmitter for output; <code>addDeviceAndConnect</code> convenience method; builds with <code>tsc</code>.  </li> </ul>"},{"location":"clients/generator/#further-reading","title":"Further Reading","text":"<ul> <li>Design Document: Architectural rationale and detailed generation strategy</li> <li>Go Client Documentation: Go reference client usage</li> <li>C Client Library Documentation: C-specific usage, build, and examples</li> <li>C# Client Library Documentation: C#-specific usage, async patterns, and map helpers</li> <li>TypeScript Client Library Documentation: TypeScript-specific usage, EventEmitter patterns, and examples</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"clients/go/","title":"Go Client Documentation","text":"<p>The Go client is the reference implementation for interacting with VIIPER servers. It's included in the repository under <code>/apiclient</code> and <code>/device</code>.</p>"},{"location":"clients/go/#overview","title":"Overview","text":"<p>The Go client features:</p> <ul> <li>Type-safe API: Structured request/response types with context support</li> <li>Device streams: Bidirectional communication using <code>encoding.BinaryMarshaler</code>/<code>BinaryUnmarshaler</code></li> <li>Built-in: No code generation needed; part of the main repository</li> <li>Flexible timeouts: Configurable connection and I/O timeouts</li> </ul>"},{"location":"clients/go/#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n  \"context\"\n  \"log\"\n  \"time\"\n\n  apiclient \"github.com/Alia5/VIIPER/apiclient\"\n  \"github.com/Alia5/VIIPER/device\"\n  \"github.com/Alia5/VIIPER/device/keyboard\"\n)\n\nfunc main() {\n  // Create new Viiper client\n  client := apiclient.New(\"127.0.0.1:3242\")\n  ctx := context.Background()\n\n  // Create or find a bus\n  buses, err := client.BusList()\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  var busID uint32\n  if len(buses) &gt; 0 {\n    busID = buses[0]\n  } else {\n    resp, err := client.BusCreate(nil)\n    if err != nil {\n      log.Fatal(err)\n    }\n    busID = resp.BusID\n  }\n\n  // Add device and connect (optional CreateOptions parameter for VID/PID)\n  // Pass nil to use default VID/PID for the device type.\n  stream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"keyboard\", nil)\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer stream.Close()\n\n  log.Printf(\"Connected to device %s\", resp.ID)\n\n  // Send keyboard input\n  input := &amp;keyboard.InputState{\n    Modifiers: keyboard.ModLeftShift,\n  }\n  input.SetKey(keyboard.KeyH, true)\n\n  if err := stream.WriteBinary(input); err != nil {\n    log.Fatal(err)\n  }\n\n  time.Sleep(100 * time.Millisecond)\n\n  // Release\n  input = &amp;keyboard.InputState{}\n  stream.WriteBinary(input)\n}\n</code></pre>"},{"location":"clients/go/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/go/#creating-and-connecting","title":"Creating and Connecting","text":"<p>// The simplest way to add a device and open its stream (nil opts):</p> <pre><code>// Use default VID/PID for the device type\nstream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"xbox360\", nil)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream.Close()\n\nlog.Printf(\"Connected to device %s\", resp.ID)\n</code></pre> <p>// Or specify VID/PID using CreateOptions:</p> <pre><code>opts := &amp;device.CreateOptions{\n  IdVendor:  func() *uint16 { v := uint16(0x1234); return &amp;v }(),\n  IdProduct: func() *uint16 { p := uint16(0x5678); return &amp;p }(),\n}\nstream2, resp2, err := client.AddDeviceAndConnect(ctx, busID, \"keyboard\", opts)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream2.Close()\n\nlog.Printf(\"Connected to device %s (custom VID/PID)\", resp2.ID)\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>stream, err := client.OpenStream(ctx, busID, deviceID)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream.Close()\n</code></pre>"},{"location":"clients/go/#sending-input","title":"Sending Input","text":"<p>Device input is sent using structs that implement <code>encoding.BinaryMarshaler</code>:</p> <pre><code>import \"github.com/Alia5/VIIPER/device/xbox360\"\n\ninput := &amp;xbox360.InputState{\n  Buttons: xbox360.ButtonA,\n  LX:      -32768, // Left stick left\n  LY:      32767,  // Left stick up\n}\nif err := stream.WriteBinary(input); err != nil {\n  log.Fatal(err)\n}\n</code></pre>"},{"location":"clients/go/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<p>For devices that send feedback (rumble, LEDs), use <code>StartReading</code> with a decode function:</p> <pre><code>import (\n  \"bufio\"\n  \"encoding\"\n  \"io\"\n  \"github.com/Alia5/VIIPER/device/xbox360\"\n)\n\n// Start async reading for rumble commands\nrumbleCh, errCh := stream.StartReading(ctx, 10, func(r *bufio.Reader) (encoding.BinaryUnmarshaler, error) {\n  var b [2]byte\n  if _, err := io.ReadFull(r, b[:]); err != nil { return nil, err }\n  msg := new(xbox360.XRumbleState)\n  if err := msg.UnmarshalBinary(b[:]); err != nil { return nil, err }\n  return msg, nil\n})\n\ngo func() {\n  for {\n    select {\n    case msg := &lt;-rumbleCh:\n      rumble := msg.(*xbox360.XRumbleState)\n      fmt.Printf(\"Rumble: Left=%d Right=%d\\n\", rumble.LeftMotor, rumble.RightMotor)\n    case err := &lt;-errCh:\n      if err != nil { log.Printf(\"Stream error: %v\", err) }\n      return\n    }\n  }\n}()\n</code></pre>"},{"location":"clients/go/#closing-a-stream","title":"Closing a Stream","text":"<pre><code>stream.Close()\n</code></pre>"},{"location":"clients/go/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific wire formats and helper methods. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The Go client provides device packages under <code>/device/</code> with type-safe structs and constants (e.g., <code>keyboard.InputState</code>, <code>keyboard.KeyA</code>, <code>mouse.Btn_Left</code>).</p>"},{"location":"clients/go/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/go/#custom-timeouts","title":"Custom Timeouts","text":"<pre><code>cfg := &amp;apiclient.Config{\n  DialTimeout:  2 * time.Second,\n  ReadTimeout:  3 * time.Second,\n  WriteTimeout: 3 * time.Second,\n}\nclient := apiclient.NewWithConfig(\"127.0.0.1:3242\", cfg)\n</code></pre> <p>Default timeouts are: Dial 3s, Read/Write 5s.</p>"},{"location":"clients/go/#context-aware-calls","title":"Context-Aware Calls","text":"<p>All methods have context-aware variants ending with <code>Ctx</code>:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\nbuses, err := client.BusListCtx(ctx)\n</code></pre>"},{"location":"clients/go/#error-handling","title":"Error Handling","text":"<p>The server returns errors as <code>{ \"error\": \"message\" }</code> JSON. The client wraps these as Go errors:</p> <pre><code>if err != nil {\n  log.Printf(\"request failed: %v\", err)\n}\n</code></pre>"},{"location":"clients/go/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Mouse: <code>examples/go/virtual_mouse/main.go</code></li> <li>Virtual Keyboard: <code>examples/go/virtual_keyboard/main.go</code></li> <li>Virtual Xbox360 Controller: <code>examples/go/virtual_x360_pad/main.go</code></li> </ul>"},{"location":"clients/go/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>C Client Library Documentation: Generated C client library usage</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>C# Client Library Documentation: .NET client library</li> <li>Rust Client Library Documentation: Rust client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"clients/rust/","title":"Rust Client Library Documentation","text":"<p>The VIIPER Rust client library provides a type-safe, zero-cost abstraction client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/rust/#overview","title":"Overview","text":"<p>The Rust client library features:</p> <ul> <li>Sync and Async APIs: Choose between blocking <code>ViiperClient</code> or async <code>AsyncViiperClient</code> (with <code>async</code> feature)</li> <li>Type-safe: Generated structs with constants, helper maps, and <code>DeviceInput</code> trait implementations</li> <li>Callback-based output: Register closures for device feedback (LEDs, rumble)</li> <li>Zero external dependencies (sync): Uses only <code>std</code> for the synchronous client</li> <li>Tokio-based async: Optional <code>async</code> feature for async/await support with Tokio runtime</li> </ul> <p>License</p> <p>The Rust client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/rust/#installation","title":"Installation","text":""},{"location":"clients/rust/#1-using-the-published-crate-recommended","title":"1. Using the Published Crate (Recommended)","text":"<p>Install the client library using Cargo:</p> <pre><code>cargo add viiper-client\n</code></pre> <p>For async support:</p> <pre><code>cargo add viiper-client --features async\ncargo add tokio --features full\n</code></pre> <p>Package page: viiper-client on crates.io</p> <p>Pre-release / snapshot builds are not published to crates.io. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p>"},{"location":"clients/rust/#2-path-dependency-for-local-development-against-source","title":"2. Path Dependency (For Local Development Against Source)","text":"<p>Use this when modifying the generator or contributing new device types:</p> <pre><code>[dependencies]\nviiper-client = { path = \"../../clients/rust\" }\n</code></pre>"},{"location":"clients/rust/#3-generating-from-source-advanced-contributors","title":"3. Generating from Source (Advanced / Contributors)","text":"<p>Only required when enhancing VIIPER itself:</p> <pre><code>go run ./cmd/viiper codegen --lang=rust\ncd clients/rust\ncargo build --release\n</code></pre>"},{"location":"clients/rust/#quick-start-sync","title":"Quick Start (Sync)","text":"<pre><code>use viiper_client::{ViiperClient, devices::keyboard::*};\nuse std::net::ToSocketAddrs;\n\nfn main() {\n    // Create new Viiper client\n    let addr = \"localhost:3242\"\n        .to_socket_addrs()\n        .expect(\"Invalid address\")\n        .next()\n        .expect(\"No address resolved\");\n    let client = ViiperClient::new(addr);\n\n    // Find or create a bus\n    let bus_id = match client.bus_list() {\n        Ok(resp) if resp.buses.is_empty() =&gt; {\n            client.bus_create(None).expect(\"Failed to create bus\").bus_id\n        }\n        Ok(resp) =&gt; *resp.buses.first().unwrap(),\n        Err(e) =&gt; panic!(\"BusList error: {}\", e),\n    };\n\n    // Add device\n    let device_info = client.bus_device_add(\n        bus_id,\n        &amp;viiper_client::types::DeviceCreateRequest {\n            r#type: Some(\"keyboard\".to_string()),\n            id_vendor: None,\n            id_product: None,\n        },\n    ).expect(\"Failed to add device\");\n\n    // Connect to device stream\n    let mut stream = client\n        .connect_device(device_info.bus_id, &amp;device_info.dev_id)\n        .expect(\"Failed to connect\");\n\n    println!(\"Connected to device {} on bus {}\", device_info.dev_id, device_info.bus_id);\n\n    // Send keyboard input\n    let input = KeyboardInput {\n        modifiers: MOD_LEFT_SHIFT,\n        count: 1,\n        keys: vec![KEY_H],\n    };\n    stream.send(&amp;input).expect(\"Failed to send input\");\n\n    // Cleanup\n    let _ = client.bus_device_remove(device_info.bus_id, Some(&amp;device_info.dev_id));\n}\n</code></pre>"},{"location":"clients/rust/#quick-start-async","title":"Quick Start (Async)","text":"<pre><code>use tokio::time::{sleep, Duration};\nuse viiper_client::{AsyncViiperClient, devices::keyboard::*};\nuse std::net::ToSocketAddrs;\n\n#[tokio::main]\nasync fn main() {\n    // Create new Viiper client\n    let addr = \"localhost:3242\"\n        .to_socket_addrs()\n        .expect(\"Invalid address\")\n        .next()\n        .expect(\"No address resolved\");\n    let client = AsyncViiperClient::new(addr);\n\n    // Find or create a bus\n    let bus_id = match client.bus_list().await {\n        Ok(resp) if resp.buses.is_empty() =&gt; {\n            client.bus_create(None).await.expect(\"Failed to create bus\").bus_id\n        }\n        Ok(resp) =&gt; *resp.buses.first().unwrap(),\n        Err(e) =&gt; panic!(\"BusList error: {}\", e),\n    };\n\n    // Add device\n    let device_info = client.bus_device_add(\n        bus_id,\n        &amp;viiper_client::types::DeviceCreateRequest {\n            r#type: Some(\"keyboard\".to_string()),\n            id_vendor: None,\n            id_product: None,\n        },\n    ).await.expect(\"Failed to add device\");\n\n    // Connect to device stream\n    let mut stream = client\n        .connect_device(device_info.bus_id, &amp;device_info.dev_id)\n        .await\n        .expect(\"Failed to connect\");\n\n    println!(\"Connected to device {} on bus {}\", device_info.dev_id, device_info.bus_id);\n\n    // Send keyboard input\n    let input = KeyboardInput {\n        modifiers: MOD_LEFT_SHIFT,\n        count: 1,\n        keys: vec![KEY_H],\n    };\n    stream.send(&amp;input).await.expect(\"Failed to send input\");\n\n    // Cleanup\n    let _ = client.bus_device_remove(device_info.bus_id, Some(&amp;device_info.dev_id)).await;\n}\n</code></pre>"},{"location":"clients/rust/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/rust/#creating-a-device-stream-sync","title":"Creating a Device Stream (Sync)","text":"<pre><code>use viiper_client::{ViiperClient, types::DeviceCreateRequest};\nuse std::net::ToSocketAddrs;\n\nlet addr = \"localhost:3242\"\n    .to_socket_addrs()\n    .expect(\"Invalid address\")\n    .next()\n    .expect(\"No address resolved\");\nlet client = ViiperClient::new(addr);\n\n// Add device first\nlet device_info = client.bus_device_add(\n    bus_id,\n    &amp;DeviceCreateRequest {\n        r#type: Some(\"xbox360\".to_string()),\n        id_vendor: None,\n        id_product: None,\n    },\n).expect(\"Failed to add device\");\n\n// Then connect to its stream\nlet mut stream = client\n    .connect_device(device_info.bus_id, &amp;device_info.dev_id)\n    .expect(\"Failed to connect\");\n</code></pre> <p>With custom VID/PID:</p> <pre><code>let device_info = client.bus_device_add(\n    bus_id,\n    &amp;DeviceCreateRequest {\n        r#type: Some(\"keyboard\".to_string()),\n        id_vendor: Some(0x1234),\n        id_product: Some(0x5678),\n    },\n).expect(\"Failed to add device\");\n</code></pre>"},{"location":"clients/rust/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated structs that implement the <code>DeviceInput</code> trait:</p> <pre><code>use viiper_client::devices::xbox360::*;\n\nlet input = Xbox360Input {\n    buttons: BUTTON_A as u32,\n    lt: 255,\n    rt: 0,\n    lx: -32768,  // Left stick left\n    ly: 32767,   // Left stick up\n    rx: 0,\n    ry: 0,\n};\nstream.send(&amp;input).expect(\"Failed to send\");\n</code></pre>"},{"location":"clients/rust/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<p>For devices that send feedback (rumble, LEDs), register a callback with <code>on_output</code>:</p> <p>Sync API:</p> <pre><code>use viiper_client::devices::keyboard::OUTPUT_SIZE;\n\nstream.on_output(|reader| {\n    let mut buf = [0u8; OUTPUT_SIZE];\n    reader.read_exact(&amp;mut buf)?;\n    let leds = buf[0];\n\n    let num_lock = (leds &amp; 0x01) != 0;\n    let caps_lock = (leds &amp; 0x02) != 0;\n    let scroll_lock = (leds &amp; 0x04) != 0;\n\n    println!(\"LEDs: Num={} Caps={} Scroll={}\", num_lock, caps_lock, scroll_lock);\n    Ok(())\n}).expect(\"Failed to register callback\");\n</code></pre> <p>Async API:</p> <pre><code>use tokio::io::AsyncReadExt;\nuse viiper_client::devices::keyboard::OUTPUT_SIZE;\n\nstream.on_output(|stream| async move {\n    let mut buf = [0u8; OUTPUT_SIZE];\n    let mut guard = stream.lock().await;\n    guard.read_exact(&amp;mut buf).await?;\n    drop(guard);\n\n    let leds = buf[0];\n    let num_lock = (leds &amp; 0x01) != 0;\n    let caps_lock = (leds &amp; 0x02) != 0;\n\n    println!(\"LEDs: Num={} Caps={}\", num_lock, caps_lock);\n    Ok(())\n}).expect(\"Failed to register callback\");\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>stream.on_output(|reader| {\n    let mut buf = [0u8; 2];\n    reader.read_exact(&amp;mut buf)?;\n    let left_motor = buf[0];\n    let right_motor = buf[1];\n    println!(\"Rumble: Left={} Right={}\", left_motor, right_motor);\n    Ok(())\n}).expect(\"Failed to register callback\");\n</code></pre>"},{"location":"clients/rust/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The Rust client library generates constants and lazy-static maps for each device type.</p>"},{"location":"clients/rust/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Constants:</p> <pre><code>use viiper_client::devices::keyboard::*;\n\nlet key = KEY_A;           // 0x04\nlet f1 = KEY_F1;           // 0x3A\nlet enter = KEY_ENTER;     // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>use viiper_client::devices::keyboard::*;\n\nlet mods = MOD_LEFT_SHIFT | MOD_LEFT_CTRL;  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>use viiper_client::devices::keyboard::*;\n\nlet num_lock = (leds &amp; LED_NUM_LOCK) != 0;\nlet caps_lock = (leds &amp; LED_CAPS_LOCK) != 0;\n</code></pre>"},{"location":"clients/rust/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CHAR_TO_KEY - Convert ASCII characters to key codes:</p> <pre><code>use viiper_client::devices::keyboard::CHAR_TO_KEY;\n\nif let Some(&amp;key) = CHAR_TO_KEY.get(&amp;b'a') {\n    println!(\"'a' maps to key code {}\", key);  // KEY_A\n}\n</code></pre> <p>KEY_NAME - Get human-readable key names:</p> <pre><code>use viiper_client::devices::keyboard::KEY_NAME;\n\nif let Some(name) = KEY_NAME.get(&amp;KEY_F1) {\n    println!(\"Key name: {}\", name);  // \"F1\"\n}\n</code></pre> <p>SHIFT_CHARS - Check if a character requires shift:</p> <pre><code>use viiper_client::devices::keyboard::SHIFT_CHARS;\n\nlet needs_shift = SHIFT_CHARS.contains(&amp;b'A');  // true for uppercase\n</code></pre>"},{"location":"clients/rust/#practical-example-typing-text","title":"Practical Example: Typing Text","text":"<p>Using the generated maps to type a string:</p> <pre><code>use std::thread;\nuse std::time::Duration;\nuse viiper_client::{DeviceStream, devices::keyboard::*};\n\nfn type_string(stream: &amp;mut DeviceStream, text: &amp;str) -&gt; Result&lt;(), viiper_client::ViiperError&gt; {\n    for ch in text.chars() {\n        let byte = ch as u8;\n        let key = match CHAR_TO_KEY.get(&amp;byte) {\n            Some(&amp;k) =&gt; k,\n            None =&gt; continue,\n        };\n\n        let mods = if SHIFT_CHARS.contains(&amp;byte) {\n            MOD_LEFT_SHIFT\n        } else {\n            0\n        };\n\n        // Press\n        let down = KeyboardInput {\n            modifiers: mods,\n            count: 1,\n            keys: vec![key],\n        };\n        stream.send(&amp;down)?;\n        thread::sleep(Duration::from_millis(50));\n\n        // Release\n        let up = KeyboardInput {\n            modifiers: 0,\n            count: 0,\n            keys: vec![],\n        };\n        stream.send(&amp;up)?;\n        thread::sleep(Duration::from_millis(50));\n    }\n    Ok(())\n}\n\n// Usage\ntype_string(&amp;mut stream, \"Hello, World!\")?;\n</code></pre>"},{"location":"clients/rust/#device-specific-wire-formats","title":"Device-Specific Wire Formats","text":""},{"location":"clients/rust/#keyboard-input","title":"Keyboard Input","text":"<pre><code>pub struct KeyboardInput {\n    pub modifiers: u8,    // Modifier flags (Ctrl, Shift, Alt, GUI)\n    pub count: u8,        // Number of keys in keys vec\n    pub keys: Vec&lt;u8&gt;,    // Key codes (max 6 for HID compliance)\n}\n</code></pre> <p>Wire format: 1 byte modifiers + 1 byte count + N bytes keys (variable-length)</p>"},{"location":"clients/rust/#keyboard-output-leds","title":"Keyboard Output (LEDs)","text":"<pre><code>// Single byte with LED flags\nlet leds = buf[0];\nlet num_lock = (leds &amp; LED_NUM_LOCK) != 0;\n</code></pre>"},{"location":"clients/rust/#xbox360-input","title":"Xbox360 Input","text":"<pre><code>pub struct Xbox360Input {\n    pub buttons: u32,   // Button flags\n    pub lt: u8,         // Left trigger (0-255)\n    pub rt: u8,         // Right trigger (0-255)\n    pub lx: i16,        // Left stick X (-32768 to 32767)\n    pub ly: i16,        // Left stick Y (-32768 to 32767)\n    pub rx: i16,        // Right stick X (-32768 to 32767)\n    pub ry: i16,        // Right stick Y (-32768 to 32767)\n}\n</code></pre> <p>Wire format: Fixed 14 bytes, packed structure (little-endian)</p>"},{"location":"clients/rust/#xbox360-output-rumble","title":"Xbox360 Output (Rumble)","text":"<pre><code>// Two bytes: left motor + right motor (0-255 each)\nlet left_motor = buf[0];\nlet right_motor = buf[1];\n</code></pre>"},{"location":"clients/rust/#mouse-input","title":"Mouse Input","text":"<pre><code>pub struct MouseInput {\n    pub buttons: u8,   // Button flags\n    pub dx: i8,        // Relative X movement (-128 to 127)\n    pub dy: i8,        // Relative Y movement (-128 to 127)\n    pub wheel: i8,     // Vertical scroll\n    pub pan: i8,       // Horizontal scroll\n}\n</code></pre> <p>Wire format: Fixed 5 bytes, packed structure</p>"},{"location":"clients/rust/#error-handling","title":"Error Handling","text":"<p>The client library uses a custom <code>ViiperError</code> type for all errors:</p> <pre><code>use viiper_client::ViiperError;\n\nmatch client.bus_list() {\n    Ok(buses) =&gt; println!(\"Found {} buses\", buses.buses.len()),\n    Err(ViiperError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ViiperError::Protocol(problem)) =&gt; eprintln!(\"API error: {}\", problem),\n    Err(e) =&gt; eprintln!(\"Other error: {}\", e),\n}\n</code></pre> <p>The server returns errors as RFC 7807 Problem JSON. The client parses these into <code>ProblemJson</code>:</p> <pre><code>use viiper_client::ProblemJson;\n\nif let Err(ViiperError::Protocol(problem)) = result {\n    println!(\"Status: {}\", problem.status);\n    println!(\"Title: {}\", problem.title);\n    println!(\"Detail: {}\", problem.detail);\n}\n</code></pre>"},{"location":"clients/rust/#features","title":"Features","text":"<p>The Rust client library supports optional features:</p> Feature Description Dependencies (default) Synchronous blocking client None <code>async</code> Async client with Tokio runtime <code>tokio</code>, <code>tokio-util</code> <p>Enable async support:</p> <pre><code>[dependencies]\nviiper-client = { version = \"0.1\", features = [\"async\"] }\n</code></pre>"},{"location":"clients/rust/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard (sync): <code>examples/rust/sync/virtual_keyboard/</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Keyboard (async): <code>examples/rust/async/virtual_keyboard/</code></p> </li> <li> <p>Async version using Tokio runtime</p> </li> <li> <p>Virtual Mouse (sync/async): <code>examples/rust/sync/virtual_mouse/</code>, <code>examples/rust/async/virtual_mouse/</code></p> </li> <li>Moves cursor diagonally</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller (sync/async): <code>examples/rust/sync/virtual_x360_pad/</code>, <code>examples/rust/async/virtual_x360_pad/</code></p> </li> <li>Cycles through buttons</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/rust/#running-examples","title":"Running Examples","text":"<pre><code>cd examples/rust\n\n# Sync examples\ncargo run --release -p virtual_keyboard_sync -- localhost:3242\ncargo run --release -p virtual_mouse_sync -- localhost:3242\ncargo run --release -p virtual_x360_pad_sync -- localhost:3242\n\n# Async examples\ncargo run --release -p virtual_keyboard_async -- localhost:3242\ncargo run --release -p virtual_mouse_async -- localhost:3242\ncargo run --release -p virtual_x360_pad_async -- localhost:3242\n</code></pre>"},{"location":"clients/rust/#project-structure","title":"Project Structure","text":"<p>Generated client library layout:</p> <pre><code>clients/rust/\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs                 # Re-exports\n\u2502   \u251c\u2500\u2500 client.rs              # Sync ViiperClient + DeviceStream\n\u2502   \u251c\u2500\u2500 async_client.rs        # Async ViiperClient (feature = \"async\")\n\u2502   \u251c\u2500\u2500 error.rs               # ViiperError, ProblemJson\n\u2502   \u251c\u2500\u2500 types.rs               # API request/response types\n\u2502   \u251c\u2500\u2500 wire.rs                # DeviceInput/DeviceOutput traits\n\u2502   \u2514\u2500\u2500 devices/\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u251c\u2500\u2500 keyboard/\n\u2502       \u2502   \u251c\u2500\u2500 mod.rs\n\u2502       \u2502   \u251c\u2500\u2500 input.rs       # KeyboardInput struct\n\u2502       \u2502   \u251c\u2500\u2500 output.rs      # Output parsing\n\u2502       \u2502   \u2514\u2500\u2500 constants.rs   # Keys, mods, LEDs, maps\n\u2502       \u251c\u2500\u2500 mouse/\n\u2502       \u2502   \u2514\u2500\u2500 ...\n\u2502       \u2514\u2500\u2500 xbox360/\n\u2502           \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"clients/rust/#troubleshooting","title":"Troubleshooting","text":"<p>Connection refused:</p> <p>Verify VIIPER server is running and listening on the expected API port (default 3242).</p> <pre><code>use std::net::SocketAddr;\nlet addr: SocketAddr = \"127.0.0.1:3242\".parse().expect(\"Invalid address\");\nlet client = ViiperClient::new(addr);\n</code></pre> <p>Feature not found errors:</p> <p>Make sure to enable the <code>async</code> feature if using <code>AsyncViiperClient</code>:</p> <pre><code>viiper-client = { version = \"0.1\", features = [\"async\"] }\n</code></pre>"},{"location":"clients/rust/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>Go Client Documentation: Reference implementation patterns</li> <li>C# Client Library Documentation: Alternative managed language client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>C Client Library Documentation: Native C client library</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"clients/typescript/","title":"TypeScript Client Library Documentation","text":"<p>The VIIPER TypeScript client library provides a modern, type-safe Node.js client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/typescript/#overview","title":"Overview","text":"<p>The TypeScript client library features:</p> <ul> <li>Type-safe API: Structured request/response types with proper TypeScript definitions</li> <li>Event-driven: EventEmitter-based output handling for device feedback (LEDs, rumble)</li> <li>Auto-generated: Generated from server code with device-specific Input/Output classes</li> <li>Modern Node.js: Targets Node.js 18+ with ES modules</li> <li>Zero external dependencies: Uses only built-in Node.js libraries</li> </ul> <p>License</p> <p>The TypeScript client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/typescript/#installation","title":"Installation","text":""},{"location":"clients/typescript/#1-using-the-published-package-recommended","title":"1. Using the Published Package (Recommended)","text":"<p>Install the client library from the public npm registry:</p> <pre><code>npm install viiperclient\n</code></pre> <p>Or with pnpm / yarn:</p> <pre><code>pnpm add viiperclient\n# or\nyarn add viiperclient\n</code></pre> <p>The latest stable version is tagged as <code>latest</code>.</p> <p>Pre-release / snapshot builds are not published to npm. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p> <p>To use a snapshot artifact from GitHub:</p> <ol> <li>Download <code>viiperclient-typescript-sdk-Snapshot.tgz</code> (or a versioned tarball) from the appropriate Release.</li> <li>Install it directly:</li> </ol> <pre><code>npm install ./viiperclient-typescript-sdk-Snapshot.tgz\n</code></pre> <p>Package page: npm: viiperclient</p>"},{"location":"clients/typescript/#2-local-project-reference-for-development-against-source","title":"2. Local Project Reference (For Development Against Source)","text":"<p>If you are actively modifying VIIPER or the code generator, link directly:</p> <pre><code>{\n  \"dependencies\": {\n    \"viiperclient\": \"file:../../clients/typescript\"\n  }\n}\n</code></pre> <p>Then build locally after regeneration:</p> <pre><code>cd clients/typescript\nnpm install\nnpm run build\n</code></pre>"},{"location":"clients/typescript/#3-generating-from-source-advanced-contributors","title":"3. Generating from Source (Advanced / Contributors)","text":"<p>This is only required if you are contributing to VIIPER or adding device types. Normal users should use the npm package.</p> <pre><code>go run ./cmd/viiper codegen --lang=typescript\ncd clients/typescript\nnpm install\nnpm run build\n</code></pre>"},{"location":"clients/typescript/#quick-start","title":"Quick Start","text":"<pre><code>import { ViiperClient, Keyboard } from \"viiperclient\";\n\nconst { KeyboardInput, Key, Mod } = Keyboard;\n\n// Create new Viiper client\nconst client = new ViiperClient(\"localhost\", 3242);\n\n// Find or create a bus\nconst busesResp = await client.buslist();\nlet busID: number;\nif (busesResp.buses.length === 0) {\n  const resp = await client.buscreate(); // Auto-assign ID\n  // Or specify ID: await client.buscreate(5);\n  busID = resp.busId;\n} else {\n  busID = busesResp.buses[0];\n}\n\n// Add device and connect\nconst deviceReq = { type: \"keyboard\" };\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n\nconsole.log(`Connected to device ${response.busId}-${response.devId}`);\n\n// Send keyboard input\nconst input = new KeyboardInput({\n  Modifiers: Mod.LeftShift,\n  Count: 1,\n  Keys: [Key.H]\n});\nawait device.send(input);\n\n// Cleanup\nawait client.busdeviceremove(busID, response.devId);\n</code></pre>"},{"location":"clients/typescript/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/typescript/#creating-a-device-stream","title":"Creating a Device Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>const deviceReq = { type: \"xbox360\" };\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n</code></pre> <p>With custom VID/PID:</p> <pre><code>const deviceReq = { \n  type: \"keyboard\", \n  idVendor: 0x1234, \n  idProduct: 0x5678 \n};\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n</code></pre> <p>Or manually add and connect:</p> <pre><code>const deviceResp = await client.busdeviceadd(busId, { type: \"keyboard\" });\nconst device = await client.connectDevice(busId, deviceResp.devId);\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>const device = await client.connectDevice(busId, deviceId);\n</code></pre>"},{"location":"clients/typescript/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated classes:</p> <pre><code>import { Xbox360 } from \"viiperclient\";\n\nconst { Xbox360Input, Button } = Xbox360;\n\nconst input = new Xbox360Input({\n  Buttons: Button.A,\n  Lt: 255,\n  Rt: 0,\n  Lx: -32768,  // Left stick left\n  Ly: 32767,   // Left stick up\n  Rx: 0,\n  Ry: 0\n});\nawait device.send(input);\n</code></pre>"},{"location":"clients/typescript/#receiving-output-events","title":"Receiving Output (Events)","text":"<p>For devices that send feedback (rumble, LEDs), subscribe to the <code>output</code> event:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { LED } = Keyboard;\n\ndevice.on(\"output\", (data: Buffer) =&gt; {\n  if (data.length &lt; 1) return;\n  const leds = data.readUInt8(0);\n\n  console.log(`LEDs: ` +\n    `Num=${(leds &amp; LED.NumLock) !== 0} ` +\n    `Caps=${(leds &amp; LED.CapsLock) !== 0} ` +\n    `Scroll=${(leds &amp; LED.ScrollLock) !== 0}`);\n});\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>device.on(\"output\", (data: Buffer) =&gt; {\n  if (data.length &lt; 2) return;\n  const leftMotor = data.readUInt8(0);\n  const rightMotor = data.readUInt8(1);\n  console.log(`Rumble: Left=${leftMotor} Right=${rightMotor}`);\n});\n</code></pre>"},{"location":"clients/typescript/#closing-a-device","title":"Closing a Device","text":"<pre><code>device.close();\n</code></pre>"},{"location":"clients/typescript/#error-handling-and-events","title":"Error Handling and Events","text":"<p>Device streams emit <code>error</code> and <code>end</code> events that should be handled:</p> <pre><code>device.on(\"error\", async (err: Error) =&gt; {\n  console.error(`Stream error: ${err}`);\n  // Handle error and cleanup\n});\n\ndevice.on(\"end\", async () =&gt; {\n  console.log(\"Stream ended by server\");\n  // Handle disconnection and cleanup\n});\n</code></pre> <p>For long-running applications with intervals or timers, stop them before cleanup:</p> <pre><code>let running = true;\nconst interval = setInterval(async () =&gt; {\n  if (!running) return;\n\n  try {\n    await device.send(input);\n  } catch (err) {\n    console.error(`Send error: ${err}`);\n    running = false;\n    clearInterval(interval);\n    // Cleanup...\n  }\n}, 16);\n\n// Handle Ctrl+C gracefully\nprocess.on(\"SIGINT\", async () =&gt; {\n  console.log(\"Stopping...\");\n  running = false;\n  clearInterval(interval);\n  device.close();\n  await client.busdeviceremove(busId, deviceId);\n  process.exit(0);\n});\n</code></pre>"},{"location":"clients/typescript/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The TypeScript SDK automatically generates enums and helper maps for each device type.</p>"},{"location":"clients/typescript/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Enum:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { Key } = Keyboard;\n\nconst key = Key.A;               // 0x04\nconst f1 = Key.F1;               // 0x3A\nconst enter = Key.Enter;         // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { Mod } = Keyboard;\n\nconst mods = Mod.LeftShift | Mod.LeftCtrl;  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst numLock = (leds &amp; LED.NumLock) !== 0;\nconst capsLock = (leds &amp; LED.CapsLock) !== 0;\n</code></pre>"},{"location":"clients/typescript/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CharToKey Map - Convert ASCII characters to key codes:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { CharToKeyGet } = Keyboard;\n\nconst key = CharToKeyGet('A'.codePointAt(0)!);\nif (key !== undefined) {\n  console.log(`'A' maps to ${key}`);  // Key.A\n}\n</code></pre> <p>KeyName Map - Get human-readable key names:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { KeyNameGet } = Keyboard;\n\nconst name = KeyNameGet(Key.F1);\nif (name !== undefined) {\n  console.log(`Key name: ${name}`);  // \"F1\"\n}\n</code></pre> <p>ShiftChars Map - Check if a character requires shift:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { ShiftCharsHas } = Keyboard;\n\nconst needsShift = ShiftCharsHas('A'.codePointAt(0)!);  // true for uppercase\n</code></pre>"},{"location":"clients/typescript/#practical-example-typing-text","title":"Practical Example: Typing Text","text":"<p>Using the generated maps to type a string:</p> <pre><code>import { ViiperDevice, Keyboard } from \"viiperclient\";\n\nconst { KeyboardInput, CharToKeyGet, ShiftCharsHas, Mod } = Keyboard;\n\nasync function typeString(device: ViiperDevice, text: string): Promise&lt;void&gt; {\n  for (const ch of text) {\n    const cp = ch.codePointAt(0)!;\n    const key = CharToKeyGet(cp);\n    if (key === undefined) continue;\n\n    const mods = ShiftCharsHas(cp) ? Mod.LeftShift : 0;\n\n    // Press\n    await device.send(new KeyboardInput({\n      Modifiers: mods,\n      Count: 1,\n      Keys: [key]\n    }));\n    await new Promise(r =&gt; setTimeout(r, 50));\n\n    // Release\n    await device.send(new KeyboardInput({\n      Modifiers: 0,\n      Count: 0,\n      Keys: []\n    }));\n    await new Promise(r =&gt; setTimeout(r, 50));\n  }\n}\n\n// Usage\nawait typeString(device, \"Hello, World!\");\n</code></pre>"},{"location":"clients/typescript/#device-specific-wire-formats","title":"Device-Specific Wire Formats","text":""},{"location":"clients/typescript/#keyboard-input","title":"Keyboard Input","text":"<pre><code>interface KeyboardInput {\n  Modifiers: number;    // Modifier flags (Ctrl, Shift, Alt, GUI)\n  Count: number;        // Number of keys in Keys array\n  Keys: number[];       // Key codes (max 6 for HID compliance)\n}\n</code></pre> <p>Wire format: 1 byte modifiers + 1 byte count + N bytes keys (variable-length)</p>"},{"location":"clients/typescript/#keyboard-output-leds","title":"Keyboard Output (LEDs)","text":"<pre><code>// Single byte with LED flags\nconst leds = data.readUInt8(0);\nconst numLock = (leds &amp; LED.NumLock) !== 0;\n</code></pre>"},{"location":"clients/typescript/#xbox360-input","title":"Xbox360 Input","text":"<pre><code>interface Xbox360Input {\n  Buttons: number;     // Button flags\n  Lt: number;          // Left trigger (0-255)\n  Rt: number;          // Right trigger (0-255)\n  Lx: number;          // Left stick X (-32768 to 32767)\n  Ly: number;          // Left stick Y (-32768 to 32767)\n  Rx: number;          // Right stick X (-32768 to 32767)\n  Ry: number;          // Right stick Y (-32768 to 32767)\n}\n</code></pre> <p>Wire format: Fixed 14 bytes, packed structure</p>"},{"location":"clients/typescript/#xbox360-output-rumble","title":"Xbox360 Output (Rumble)","text":"<pre><code>// Two bytes: left motor + right motor (0-255 each)\nconst leftMotor = data.readUInt8(0);\nconst rightMotor = data.readUInt8(1);\n</code></pre>"},{"location":"clients/typescript/#mouse-input","title":"Mouse Input","text":"<pre><code>interface MouseInput {\n  Buttons: number;  // Button flags\n  Dx: number;       // Relative X movement (-32768 to 32767)\n  Dy: number;       // Relative Y movement (-32768 to 32767)\n  Wheel: number;    // Vertical scroll (-32768 to 32767)\n  Pan: number;      // Horizontal scroll (-32768 to 32767)\n}\n</code></pre> <p>Wire format: Fixed 9 bytes, int16 values little-endian</p>"},{"location":"clients/typescript/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/typescript/#custom-port","title":"Custom Port","text":"<pre><code>const client = new ViiperClient(\"localhost\", 3242);\n</code></pre> <p>Default port is 3242 if not specified.</p>"},{"location":"clients/typescript/#error-handling","title":"Error Handling","text":"<p>The server returns errors as JSON. The client throws exceptions:</p> <pre><code>try {\n  await client.buscreate(\"invalid-bus-id\");\n} catch (err) {\n  console.error(`Request failed: ${err}`);\n}\n</code></pre> <p>Stream errors are surfaced through the EventEmitter error event:</p> <pre><code>device.on('error', (err) =&gt; {\n  console.error(`Stream error: ${err}`);\n});\n</code></pre>"},{"location":"clients/typescript/#resource-management","title":"Resource Management","text":"<p>Always close devices when done:</p> <pre><code>try {\n  const device = await client.connectDevice(busId, deviceId);\n  // ... use device ...\n} finally {\n  device.close();\n}\n</code></pre>"},{"location":"clients/typescript/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/typescript/virtual_keyboard.ts</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/typescript/virtual_mouse.ts</code></p> </li> <li>Moves cursor diagonally</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/typescript/virtual_x360_pad.ts</code></p> </li> <li>Runs at 60fps with cycling buttons and animated triggers</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/typescript/#running-examples","title":"Running Examples","text":"<pre><code>cd examples/typescript\nnpm install\nnpm run build\n\nnode dist/virtual_keyboard.js localhost:3242\n</code></pre>"},{"location":"clients/typescript/#troubleshooting","title":"Troubleshooting","text":"<p>Some quick troubleshooting tips for the TypeScript SDK and device streams:</p> <ul> <li>Connection refused / timeout: Verify VIIPER server is running and listening on the expected API port (default 3242). Ensure firewall/ACLs allow TCP connections.</li> <li>Unexpected response or parse errors: The VIIPER API uses null-byte (\\x00) terminated requests. Use the provided SDK helper methods or ensure raw sockets append a null terminator when calling the server.</li> <li>Stream closed unexpectedly: Confirm the device stream was opened (device added and connected) and that the device handler did not time out (default 5s reconnect window). Check server logs for reasons.</li> <li>Use examples: See the repository examples in <code>examples/typescript/</code> for working end-to-end samples that demonstrate bus creation, device streams, and cleanup.</li> </ul>"},{"location":"clients/typescript/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>Go Client Documentation: Reference implementation patterns</li> <li>C# Client Library Documentation: Alternative managed language client library</li> <li>Rust Client Library Documentation: Rust client library with sync/async support</li> <li>C Client Library Documentation: Alternative client library for native integration</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"devices/keyboard/","title":"HID Keyboard","text":"<p>A full-featured HID keyboard with N-key rollover using a 256-bit key bitmap, plus LED status feedback (NumLock, CapsLock, ScrollLock) via an OUT report.</p> <ul> <li>USB IDs: VID 0x2E8A (Raspberry Pi), PID 0x0010</li> <li>Interfaces/Endpoints:</li> <li>IN: 0x81 (keyboard input report)</li> <li>OUT: 0x01 (LED output report)</li> <li>Device type id (for API add): <code>keyboard</code></li> </ul>"},{"location":"devices/keyboard/#client-library-support","title":"Client Library Support","text":"<p>The wire protocol is abstracted by client libraries. The Go client includes built-in types (<code>/device/keyboard</code>), and generated client libraries provide equivalent structures with proper packing. You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: Go Client, Generated Client Libraries</p>"},{"location":"devices/keyboard/#hid-report-format-host-facing","title":"HID report format (host-facing)","text":"<p>Input (device \u2192 host): 34 bytes</p> <ul> <li>Byte 0: Modifiers bitfield (LeftCtrl, LeftShift, LeftAlt, LeftGUI, RightCtrl, RightShift, RightAlt, RightGUI)</li> <li>Byte 1: Reserved (0)</li> <li>Bytes 2..33: 256-bit key bitmap (least-significant bit = usage ID 0)</li> </ul> <p>Output (host \u2192 device): 1 byte LEDs</p> <ul> <li>Bit 0 NumLock, Bit 1 CapsLock, Bit 2 ScrollLock (remaining bits reserved)</li> </ul> <p>Note: The HID descriptor uses a long-item Report Count (0x96) to encode 256 for the bitmap.</p>"},{"location":"devices/keyboard/#device-stream-protocol-client-facing","title":"Device stream protocol (client-facing)","text":"<p>Wire format from your client into VIIPER:</p> <ul> <li>Variable-length packets</li> <li>Header: [Modifiers (1 byte), KeyCount (1 byte)]</li> <li>Followed by KeyCount bytes of HID Usage IDs for the currently pressed non-modifier keys</li> </ul> <p>VIIPER converts this to the bitmap report for the host, so you don\u2019t need to manage the 256-bit array yourself.</p> <p>Example wire packet to press \u201cA\u201d with LeftShift:</p> <ul> <li>Modifiers = 0x02 (LeftShift)</li> <li>Count = 1</li> <li>Keys = [0x04]  // HID usage for \u201cA\u201d</li> </ul>"},{"location":"devices/keyboard/#leds-feedback","title":"LEDs feedback","text":"<p>The device sends the current LED state (1 byte) back on the same stream whenever the host changes it. You can use this to update indicators in your client.</p>"},{"location":"devices/keyboard/#helpers-and-keycodes","title":"Helpers and keycodes","text":"<p>Convenience helpers and key constants are available in the Go package:</p> <ul> <li><code>/device/keyboard/helpers.go</code>: TypeString, TypeChar, PressKey, Release, etc.</li> <li><code>/device/keyboard/const.go</code>: Modifiers, LED bits, and HID usage IDs, including media keys (Mute, VolumeUp/Down, PlayPause, Stop, Next, Previous)</li> </ul>"},{"location":"devices/keyboard/#adding-the-device","title":"Adding the device","text":"<p>Using the raw API (see API Reference for details):</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n\n# Add keyboard device with JSON payload\nprintf 'bus/1/add {\"type\":\"keyboard\"}\\0' | nc localhost 3242\n</code></pre> <p>Or use one of the client libraries which handle the protocol automatically.</p>"},{"location":"devices/keyboard/#examples","title":"Examples","text":"<p>A runnable example that types \u201cHello!\u201d followed by Enter every few seconds is provided in <code>examples/virtual_keyboard/</code>.</p>"},{"location":"devices/mouse/","title":"HID Mouse","text":"<p>A standard 5-button mouse with vertical and horizontal scroll wheels. Reports relative motion deltas and supports up to five buttons.</p> <ul> <li>USB IDs: VID 0x2E8A (Raspberry Pi), PID 0x0011</li> <li>Interface/Endpoint: IN 0x81 (mouse input report)</li> <li>Device type id (for API add): <code>mouse</code></li> </ul>"},{"location":"devices/mouse/#client-library-support","title":"Client Library Support","text":"<p>The wire protocol is abstracted by client libraries. The Go client includes built-in types (<code>/device/mouse</code>), and generated client libraries provide equivalent structures with proper packing. You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: Go Client, Generated Client Libraries</p>"},{"location":"devices/mouse/#hid-report-format-host-facing","title":"HID report format (host-facing)","text":"<p>Input (device \u2192 host): 9 bytes</p> <ul> <li>Byte 0: Buttons bitfield (bits 0..4 for buttons 1..5)</li> <li>Bytes 1-2: X delta (int16 little-endian, -32768 to +32767)</li> <li>Bytes 3-4: Y delta (int16 little-endian, -32768 to +32767)</li> <li>Bytes 5-6: Vertical wheel (int16 little-endian; positive up)</li> <li>Bytes 7-8: Horizontal wheel/pan (int16 little-endian; positive right)</li> </ul> <p>Deltas are consumed after each IN report so motion is truly relative and not repeated across host polls.</p>"},{"location":"devices/mouse/#device-stream-protocol-client-facing","title":"Device stream protocol (client-facing)","text":"<p>Wire format from your client into VIIPER:</p> <ul> <li>Fixed 9-byte packets matching the HID report layout:   [Buttons, dX_lo, dX_hi, dY_lo, dY_hi, Wheel_lo, Wheel_hi, Pan_lo, Pan_hi]</li> </ul> <p>Buttons persist until changed; motion/wheel deltas are applied once and reset.</p>"},{"location":"devices/mouse/#adding-the-device","title":"Adding the device","text":"<p>Using the raw API (see API Reference for details):</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n\n# Add mouse device with JSON payload\nprintf 'bus/1/add {\"type\":\"mouse\"}\\0' | nc localhost 3242\n</code></pre> <p>Or use one of the client libraries which handle the protocol automatically.</p>"},{"location":"devices/mouse/#examples","title":"Examples","text":"<p>A runnable example that periodically moves the mouse a short distance, clicks, and scrolls is provided in <code>examples/virtual_mouse/</code>.</p>"},{"location":"devices/steamdeck/","title":"Steam Deck Controller (Jupiter)","text":"<p>Steam Deck (Jupiter/LCD) virtual controller.</p> <ul> <li>Device type id (for API add): <code>steamdeck</code></li> </ul>"},{"location":"devices/steamdeck/#client-library-support","title":"Client library support","text":"<p>All supported client libraries generate strongly-typed structs/classes for the Steam Deck wire protocol from the <code>viiper:wire</code> annotations in <code>/device/steamdeck/deviceState.go</code>.</p>"},{"location":"devices/steamdeck/#device-stream-protocol-client-facing","title":"Device stream protocol (client-facing)","text":"<p>The device stream is a bidirectional, raw TCP connection.</p>"},{"location":"devices/steamdeck/#client-server-input","title":"Client \u2192 server (input)","text":"<ul> <li>Fixed 52-byte packet, little-endian.</li> <li>Fields (in order):</li> <li><code>buttons</code> (u64)</li> <li><code>leftPadX</code>, <code>leftPadY</code>, <code>rightPadX</code>, <code>rightPadY</code> (i16)</li> <li><code>accelX</code>, <code>accelY</code>, <code>accelZ</code> (i16)</li> <li><code>gyroX</code>, <code>gyroY</code>, <code>gyroZ</code> (i16)</li> <li><code>gyroQuatW</code>, <code>gyroQuatX</code>, <code>gyroQuatY</code>, <code>gyroQuatZ</code> (i16)</li> <li><code>triggerRawL</code>, <code>triggerRawR</code> (u16)</li> <li><code>leftStickX</code>, <code>leftStickY</code>, <code>rightStickX</code>, <code>rightStickY</code> (i16)</li> <li><code>pressurePadLeft</code>, <code>pressurePadRight</code> (u16)</li> </ul>"},{"location":"devices/steamdeck/#server-client-haptics","title":"Server \u2192 client (haptics)","text":"<ul> <li>Fixed 4-byte packet, little-endian.</li> <li>Fields:</li> <li><code>leftMotor</code> (u16)</li> <li><code>rightMotor</code> (u16)</li> </ul> <p>See: <code>/device/steamdeck/deviceState.go</code> and <code>/device/steamdeck/handler.go</code>.</p>"},{"location":"devices/xbox360/","title":"Xbox 360 Controller","text":"<p>The Xbox 360 virtual gamepad emulates an XInput-compatible controller that most operating systems and games understand out of the box.</p> <ul> <li>USB IDs: VID 0x045E (Microsoft), PID 0x028E (Xbox 360 Controller)</li> <li>Interfaces/Endpoints: single HID interface with one IN interrupt endpoint and one OUT interrupt endpoint for rumble</li> <li>Device type id (for API add): <code>xbox360</code></li> </ul>"},{"location":"devices/xbox360/#client-library-support","title":"Client Library Support","text":"<p>The wire protocol is abstracted by client libraries. The Go client includes built-in types (<code>/device/xbox360</code>), and generated client libraries provide equivalent structures with proper packing. You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: Go Client, Generated Client Libraries</p>"},{"location":"devices/xbox360/#adding-the-device","title":"Adding the device","text":"<p>Use the API to create a bus and add an Xbox 360 controller. Using the raw API (see API Reference for details):</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n\n# Add xbox360 device with JSON payload\nprintf 'bus/1/add {\"type\":\"xbox360\"}\\0' | nc localhost 3242\n</code></pre> <p>The API returns a Device object with <code>busId</code>, <code>devId</code>, and other details. Attach it from a USB/IP client, then open a stream to drive input and receive rumble.</p> <p>Or use one of the client libraries which handle the protocol automatically.</p>"},{"location":"devices/xbox360/#streaming-protocol","title":"Streaming protocol","text":"<p>The device stream is a bidirectional, raw TCP connection with fixed-size packets.</p> <p>Direction: client \u2192 server (input state)</p> <ul> <li>14-byte packets, little-endian layout:</li> <li>Buttons: uint32 (4 bytes)</li> <li>LT, RT: uint8, uint8 (2 bytes)</li> <li>LX, LY, RX, RY: int16 each (8 bytes)</li> </ul> <p>Direction: server \u2192 client (rumble feedback)</p> <ul> <li>2-byte packets:</li> <li>LeftMotor: uint8, RightMotor: uint8</li> </ul> <p>See <code>/device/xbox360/inputstate.go</code> for details.</p>"},{"location":"devices/xbox360/#example","title":"Example","text":"<p>A minimal example program that sends input and reads rumble is provided in <code>examples/</code>.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>VIIPER currently comes in a single flavor:</p> <ul> <li>a standalone executable that exposes an API over TCP.</li> <li>There will eventually be a shared-library version (libVIIPER) that you can link against directly from your application. For more information, see FAQ</li> </ul>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":""},{"location":"getting-started/installation/#usbip","title":"USBIP","text":"<p>VIIPER relies on USBIP. You must have a USBIP-Client implementation available on your system to use VIIPER's virtual devices.</p> WindowsLinux <p>usbip-win2 is by far the most complete implementation of USBIP for Windows (comes with a SIGNED kernel mode driver).</p> <p>Install and done \ud83d\ude09</p> <p>USBIP-Win2 security issue</p> <p>The releases of usbip-win2 currently (at the time of writing) install the publicly available test signing CA as a trusted root CA on your system. You can safely remove this CA after installation using <code>certmgr.msc</code> (run as admin) and removing the \"USBIP\" from the \"Trusted Root Certification Authorities\" -&gt; \"Certificates\" list.</p> <p>Alternativly, you can download and istall the latest pre-release driver manually from the OSSign repository, which has this issue fixed already. Note that the installer does not work, only the driver <code>.cat,.inf,.sys</code> files.</p>"},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt install linux-tools-generic\n</code></pre> <p>Ubuntu USBIP Manual</p>"},{"location":"getting-started/installation/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S usbip\n</code></pre> <p>Arch Wiki: USBIP</p>"},{"location":"getting-started/installation/#linux-kernel-module-setup","title":"Linux Kernel Module Setup","text":"<p>USBIP Client Requirement</p> <p>USBIP requires the <code>vhci-hcd</code> (Virtual Host Controller Interface) kernel module on Linux for client operations. This includes VIIPER's auto-attach feature and manual device attachment.</p> <p>Most Linux distributions include this module but don't load it automatically.</p>"},{"location":"getting-started/installation/#one-time-setup","title":"One-Time Setup","text":"<p>To load the module automatically on boot:</p> <pre><code>echo \"vhci-hcd\" | sudo tee /etc/modules-load.d/vhci-hcd.conf\nsudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/installation/#manual-loading","title":"Manual Loading","text":"<p>To load the module for the current session only:</p> <pre><code>sudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Check if the module is loaded:</p> <pre><code>lsmod | grep vhci_hcd\n</code></pre>"},{"location":"getting-started/installation/#installing-viiper","title":"Installing VIIPER","text":"<p>VIIPER does not require system-wide installation. The <code>viiper</code> executable is completely self-contained (and fully portable without any dependencies, except USBIP) and can be:</p> <ul> <li>Placed in any directory</li> <li>Shipped alongside your application</li> <li>Run directly without installation</li> <li>Bundled with your application's distribution</li> </ul> <p>This makes VIIPER ideal for embedding in applications or distributing as part of a software package.</p> <p>Daemon/Service Conflicts</p> <p>If VIIPER is already running as a system service or daemon on the target machine, be aware of potential port conflicts. Applications should: - Check if VIIPER is already running before starting their own instance   - use the <code>ping</code> API endpoint to check for VIIPER presence and version - Connect to the existing VIIPER instance (if accessible) - Use a custom port via <code>--api.addr</code> flag to run a separate instance</p> <p>Linux Permissions</p> <p>On Linux, attaching devices via USBIP requires root permissions. You can run VIIPER with <code>sudo</code>, or configure appropriate udev rules to allow non-root users to attach devices.</p>"},{"location":"getting-started/installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release from the GitHub Releases page. Pre-built binaries are available for:</p> <ul> <li>Windows (x64, ARM64)</li> <li>Linux (x64, ARM64)</li> </ul>"},{"location":"getting-started/installation/#automated-install-script","title":"Automated Install Script","text":"<p>Regardless of portability, it can be convenient to have VIIPER start automatically on system boot, especially if end users want to use your application through a network or you want to enable that possibility.  </p> <p>The following scripts will download a VIIPER release, install it to a system location, and configure it to start automatically on boot.  </p> <p>For Application Developers</p> <p>The installation scripts are intended for end-users setting up a permanent VIIPER service on their system.  </p> <p>If you're developing an application that uses VIIPER, I strongly encourage you to not install a permanent VIIPER service on your users machines. </p> <p>Instead, bundle the (no dependencies, portable) VIIPER binary with your application and start/stop the server directly from your application as needed. You may need to check for existing VIIPER instances or use a custom port via <code>--api.addr</code> to avoid conflicts.   </p> <p>USBIP installed by scripts</p> <p>The install scripts install and configure USBIP for you:</p> <ul> <li>Windows: installs the usbip-win2 driver (admin prompt) and prompts for a reboot when drivers were added.</li> <li>Linux: installs USBIP via the distro package manager (when available), loads <code>vhci_hcd</code>, and configures it to autoload.</li> </ul> <p>If the automated USBIP setup fails, follow the USBIP guide to finish manually.</p> WindowsLinux <pre><code>irm https://alia5.github.io/VIIPER/stable/install.ps1 | iex\n</code></pre> <p>Installs to: <code>%LOCALAPPDATA%\\VIIPER\\viiper.exe</code></p> <p>The scripts will:</p> <ol> <li>Download the specified VIIPER binary version</li> <li>Install it to the system location</li> <li>Install and configure USBIP (driver on Windows; packages/modules on Linux)</li> <li>Configure automatic startup (Registry RunKey on Windows, systemd service on Linux)</li> <li>Start/restart the VIIPER service</li> </ol> <pre><code>curl -fsSL https://alia5.github.io/VIIPER/stable/install.sh | sh\n</code></pre> <p>Installs to: <code>/usr/local/bin/viiper</code></p> <p>The scripts will:</p> <ol> <li>Download the specified VIIPER binary version</li> <li>Install it to the system location</li> <li>Attempt to install and configure USBIP </li> <li>Load the <code>vhci_hcd</code> kernel module and configure it to autoload on boot</li> <li>Configure and run a systemd service</li> </ol> <p>Version-Specific Installation:</p> <p>The install scripts are version-aware based on where you download them from:</p> <ul> <li> <p>Latest stable release: <code>curl -fsSL https://alia5.github.io/VIIPER/stable/install.sh | sh</code></p> </li> <li> <p>Specific version (e.g., v0.2.2): <code>curl -fsSL https://alia5.github.io/VIIPER/0.2.2/install.sh | sh</code></p> </li> <li> <p>Latest pre-release (development snapshot): <code>curl -fsSL https://alia5.github.io/VIIPER/main/install.sh | sh</code></p> </li> </ul>"},{"location":"getting-started/installation/#system-startup-configuration","title":"System Startup Configuration","text":"<p>The <code>install</code> and <code>uninstall</code> commands configure automatic startup for the VIIPER binary.</p> <p>What These Commands Do</p> <p>These commands do not copy or move the VIIPER binary. They configure your system to automatically run the binary from its current location when the system boots.</p> <p>Make sure the binary is in a permanent location before running <code>viiper install</code>!</p>"},{"location":"getting-started/installation/#viiper-install","title":"<code>viiper install</code>","text":"<p>Configures VIIPER to start automatically on system boot:</p> <pre><code>viiper install\n</code></pre> <ul> <li>Windows:  </li> <li>Adds entry to Registry RunKey: <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\VIIPER</code></li> <li>Value: <code>\"&lt;current-exe-path&gt;\" server</code></li> <li>Kills any previous autorun instances</li> <li> <p>Starts the server</p> </li> <li> <p>Linux:  </p> </li> <li>Creates systemd service: <code>/etc/systemd/system/viiper.service</code></li> <li>Service ExecStart points to current binary path</li> <li>Enables and starts the service</li> </ul>"},{"location":"getting-started/installation/#viiper-uninstall","title":"<code>viiper uninstall</code>","text":"<p>Removes VIIPER from system startup and stops any running instance:</p> <pre><code>viiper uninstall\n</code></pre> <ul> <li>Windows:  </li> <li>Removes Registry RunKey entry</li> <li> <p>Kills any running autorun instances</p> </li> <li> <p>Linux:  </p> </li> <li>Stops and disables the systemd service</li> <li>Removes <code>/etc/systemd/system/viiper.service</code></li> </ul>"},{"location":"getting-started/installation/#building-from-source","title":"Building from Source","text":"<p>Building from source is only necessary if you need to modify VIIPER or target an unsupported platform.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or newer</li> <li>USBIP installed</li> <li>(Optional) Make</li> <li>Linux/macOS: Usually pre-installed</li> <li>Windows: <code>winget install ezwinports.make</code></li> </ul>"},{"location":"getting-started/installation/#build-steps","title":"Build Steps","text":"<pre><code>git clone https://github.com/Alia5/VIIPER.git\ncd VIIPER\nmake build\n</code></pre> <p>The compiled binary will be in <code>dist/viiper</code> (or <code>dist/viiper.exe</code> on Windows).</p> <p>Additional build targets:</p> <pre><code>make help          # Show all available make targets\nmake test          # Run tests\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide walks you through setting up VIIPER and creating your first virtual device.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ol> <li>USBIP installed on your system (see Installation)</li> <li>VIIPER binary downloaded from GitHub Releases or built from source</li> </ol>"},{"location":"getting-started/quickstart/#starting-the-server","title":"Starting the Server","text":"<p>Start VIIPER with default settings:</p> <pre><code>viiper server\n</code></pre> <p>This starts two services:</p> <ul> <li>USBIP Server on port <code>3241</code> (standard USBIP protocol)</li> <li>API Server on port <code>3242</code> (device management)</li> </ul> <p>Auto-attach Feature</p> <p>By default, VIIPER automatically attaches newly created devices to the local machine. You can disable this with <code>--api.auto-attach-local-client=false</code>. Linux users: Auto-attach requires running VIIPER with <code>sudo</code> as USBIP attach operations need elevated permissions.</p>"},{"location":"getting-started/quickstart/#custom-ports","title":"Custom Ports","text":"<p>To use different ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre>"},{"location":"getting-started/quickstart/#creating-your-first-virtual-device","title":"Creating Your First Virtual Device","text":"<p>VIIPER provides multiple ways to interact with the API. Choose the method that works best for you.</p>"},{"location":"getting-started/quickstart/#option-1-using-client-libraries-recommended","title":"Option 1: Using Client Libraries (Recommended)","text":"<p>Client libraries are available for C, C#, Go, and TypeScript. They handle the protocol details automatically, providing type-safe interfaces and device-specific helpers.</p> <p>For complete client library documentation and code examples, see:</p> <ul> <li>C Client Library Documentation</li> <li>C# Client Library Documentation</li> <li>TypeScript Client Library Documentation</li> <li>Go Client Documentation</li> </ul> <p>Full working examples for all device types are available in the <code>examples/</code> directory of the repository.</p>"},{"location":"getting-started/quickstart/#option-2-using-raw-tcp-netcat","title":"Option 2: Using Raw TCP (netcat)","text":"<p>For quick testing without client libraries:</p> <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n# Response: {\"busId\":1}\n\n# Add a keyboard device\nprintf 'bus/1/add {\"type\":\"keyboard\"}\\0' | nc localhost 3242\n# Response: {\"busId\":1,\"devId\":\"1\",\"vid\":\"0x2e8a\",\"pid\":\"0x0010\",\"type\":\"keyboard\"}\n\n# List devices on the bus\nprintf \"bus/1/list\\0\" | nc localhost 3242\n</code></pre> <p>Protocol Details</p> <p>The API uses TCP with null-byte (<code>\\0</code>) terminated requests. See API Reference for complete protocol documentation.</p>"},{"location":"getting-started/quickstart/#option-3-using-powershell-helper-script","title":"Option 3: Using PowerShell Helper Script","text":"<p>VIIPER includes a PowerShell helper script for Windows users:</p> <pre><code># Load the helper script\n. .\\scripts\\viiper-api.ps1\n\n# Create a bus\nInvoke-ViiperAPI \"bus/create\"\n\n# Add a device\nInvoke-ViiperAPI 'bus/1/add {\"type\":\"keyboard\"}'\n</code></pre>"},{"location":"getting-started/quickstart/#attaching-devices-usbip","title":"Attaching Devices (USBIP)","text":"<p>After creating a device via the API, attach it using your system's USBIP client.</p> <p>Automatic Attachment</p> <p>If you're running VIIPER on the same machine where you want to use the device, it's likely already attached automatically! Check your device manager or <code>lsusb</code> to confirm.</p>"},{"location":"getting-started/quickstart/#manual-attachment","title":"Manual Attachment","text":"<p>If auto-attach is disabled or you're connecting from a remote machine:</p> LinuxWindows <pre><code># Load kernel module (once per boot)\nsudo modprobe vhci-hcd\n\n# List available devices\nusbip list --remote=localhost --tcp-port=3241\n\n# Attach device (use busid from API response, e.g., \"1-1\")\nsudo usbip attach --remote=localhost --tcp-port=3241 --busid=1-1\n\n# Verify attachment\nlsusb | grep \"Raspberry Pi\"  # For keyboard/mouse\nlsusb | grep \"Microsoft\"     # For Xbox 360 controller\n</code></pre> <p>Using usbip-win2:</p> <pre><code># List available devices\nusbip.exe list --remote localhost --tcp-port 3241\n\n# Attach device\nusbip.exe attach --remote localhost --tcp-port 3241 --busid 1-1\n\n# Check Device Manager to verify attachment\n</code></pre>"},{"location":"getting-started/quickstart/#available-device-types","title":"Available Device Types","text":"<p>VIIPER supports multiple virtual device types including keyboards, mice, and game controllers. Each device type has its own protocol and capabilities.</p> <p>For a complete list of supported devices, their specifications, and wire protocols, see the Devices documentation.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you have a working setup:</p> <ol> <li>Explore Examples: Check the <code>examples/</code> directory for complete working programs in C, C#, Go, and TypeScript</li> <li>Read API Documentation: Learn about all available API commands</li> <li>Choose a Client Library: Pick a client library for your preferred language</li> <li>Review Device Specs: Understand device-specific protocols in Devices</li> </ol>"},{"location":"getting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quickstart/#server-wont-start","title":"Server Won't Start","text":"<p>Port already in use:</p> <pre><code># Use custom ports\nviiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre> <p>Permission denied (Linux):</p> <pre><code># Use ports above 1024 or run with sudo\nviiper server --usb.addr=:3241 --api.addr=:3242\n</code></pre>"},{"location":"getting-started/quickstart/#auto-attach-not-working","title":"Auto-Attach Not Working","text":"<p>VIIPER will check prerequisites at startup when auto-attach is enabled and log warnings if requirements are missing.</p> <p>Linux - USBIP tool not found:</p> <pre><code># Ubuntu/Debian\nsudo apt install linux-tools-generic\n\n# Arch Linux\nsudo pacman -S usbip\n</code></pre> <p>Linux - Kernel module not loaded:</p> <pre><code># Load for current session\nsudo modprobe vhci-hcd\n\n# Or configure persistent loading (see Installation guide)\n</code></pre> <p>See Linux Kernel Module Setup for detailed setup instructions.</p> <p>Windows - USBIP tool not found:</p> <p>Download and install usbip-win2 and ensure <code>usbip.exe</code> is in your PATH.</p>"},{"location":"getting-started/quickstart/#device-not-attaching","title":"Device Not Attaching","text":"<p>USBIP tool not found:</p> <p>Make sure USBIP is installed and in your PATH (see Installation requirements).</p> <p>Connection refused:</p> <p>Verify the VIIPER server is running and listening on the expected ports.</p>"},{"location":"getting-started/quickstart/#device-not-working","title":"Device Not Working","text":"<p>No input response:</p> <p>Ensure the device is attached via USBIP AND you've opened a device stream via the API to send input data.</p> <p>Multiple VIIPER instances:</p> <p>If you have VIIPER running as a service, your application's instance may conflict. Either connect to the existing instance or use different ports.</p>"},{"location":"getting-started/quickstart/#linux-permission-denied-when-attaching-devices","title":"Linux: Permission Denied When Attaching Devices","text":"<p>On Linux, USBIP attach operations require root permissions.</p> <p>Run VIIPER with <code>sudo</code>:</p> <pre><code>sudo viiper server\n</code></pre> <p>Or if manually attaching devices, use <code>sudo</code> with the <code>usbip attach</code> command:</p> <pre><code>sudo usbip attach --remote=localhost --tcp-port=3241 --busid=1-1\n</code></pre>"},{"location":"getting-started/quickstart/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Complete command documentation</li> <li>API Reference - Management API protocol</li> <li>Client Libraries - Language-specific client libraries</li> <li>Configuration - Environment variables and config files</li> </ul>"},{"location":"testing/e2e_latency/","title":"E2E Latency Benchmarks","text":"<p>The script <code>viiper/_testing/e2e/scripts/lat_bench.go</code> runs (or parses) end\u2011to\u2011end input latency benchmarks and produces enriched output (table, markdown, or JSON).</p> <p>It groups repeated cycles when <code>-count &gt; 1</code> and uses the single press E2E measurement (<code>E2E-InputDelay</code>) as the 100% baseline.</p>"},{"location":"testing/e2e_latency/#output","title":"Output","text":"Column Meaning Benchmark Name of the sub benchmark Count Iterations performed (from Go bench output; affected by <code>-benchtime</code>) ns/op Nanoseconds per operation (direct Go benchmark figure) % of Full Relative to <code>E2E-InputDelay</code> (single press baseline) Client Share % Portion attributed to the (go) client write phase (for E2E rows) Latency Share % Remainder attributed to transport + virtual device/host stack + tight device polling loop <p><code>E2E-PressAndRelease</code> includes both press and release cycles, so it is expected to be ~2\u00d7 the single press and thus can exceed 100% in <code>% of Full</code>.</p>"},{"location":"testing/e2e_latency/#scope-methodology","title":"Scope / Methodology","text":"<ul> <li>All benchmarks included here are executed against a VIIPER server on the same host (localhost).   They therefore measure in-process client emission plus local USBIP stack + emulated device processing only.   Remote/network USBIP attachment will add network RTT and jitter which is intentionally excluded from these baseline figures.</li> <li>Benchmarks use a single emulated Xbox360 controller device.   Other devices might produce slightly different results depending on USB report size and VIIPER-InputState size.</li> <li>Benchmarks use a single button press, which is enough as clients/VIIPER always produce a full report of the devices state.  </li> </ul>"},{"location":"testing/e2e_latency/#benchtime-mode","title":"Benchtime Mode","text":"<p>Runs use a fixed-iteration benchtime (e.g. <code>-benchtime=1000x</code>, <code>-benchtime=10000x</code>) rather than time-based (e.g. <code>2s</code>).  </p>"},{"location":"testing/e2e_latency/#running","title":"Running","text":"<p>From repository root:</p> <pre><code>cd testing/e2e\n# Single run, 1000 fixed iterations per sub benchmark\ngo run ./scripts/lat_bench.go -benchtime=1000x -count=1 -format markdown\n</code></pre> <p>Results (Arch Linux / SteamDeck Kernel / Steam Deck LCD / Go 1.25+, 10k iterations):</p> Benchmark Count ns/op % of Full Client Share % Latency Share % 1_Go-Client-Write 10000 10668 11.98 100.00 0.00 2_InputDelay-Without-Client 10000 74154 83.25 0.00 100.00 3_E2E-InputDelay 10000 89078 100.00 11.98 88.02 4_E2E-PressAndRelease 10000 184870 207.54 11.54 88.46 <p>Example output (Windows / AMD Ryzen 9 3900X / Go 1.25+, 10k iterations):</p> Benchmark Count ns/op % of Full Client Share % Latency Share % 1_Go-Client-Write 10000 27933 16.60 100.00 0.00 2_InputDelay-Without-Client 10000 133724 79.45 0.00 100.00 3_E2E-InputDelay 10000 168307 100.00 16.60 83.40 4_E2E-PressAndRelease 10000 331439 196.93 16.86 83.14 <p>Variability across repeated measurement runs has been negligible. Use a larger <code>-count</code> if you want to increase the number of runs.</p>"},{"location":"testing/e2e_latency/#notes","title":"Notes","text":"<ul> <li>Memory statistics from Go benchmarks are intentionally omitted.</li> <li><code>% of Full</code> falls back to the largest ns/op if the baseline row is missing.</li> <li>All benchmarking must run with parallelism 1 in underlying benches.</li> <li>Benchmarks use a tight polling loop using SDL3 to detect input state changes on the emulated device.</li> <li>Benchmarks must be run without an already running VIIPER server instance.</li> </ul>"}]}