{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#viiper","title":"VIIPER \ud83d\udc0d","text":"<p>Virtual Input over IP EmulatoR</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>CLI Reference</li> <li>API Reference</li> <li>GitHub Repository</li> </ul>"},{"location":"#what-is-viiper","title":"What is VIIPER?","text":"<p>VIIPER lets developers create virtual USB input devices (like game controllers, keyboards, and mice) that can be controlled programmatically (even over a network!) (using USBIP under the hood). These virtual devices are indistinguishable from real hardware to the operating system and applications, enabling seamless integration for testing, automation, and remote control scenarios.</p> <ul> <li>VIIPER abstracts away all USB / USBIP details.  </li> <li>Device emulation happens in userspace code instead of kernel drivers, so no kernel programming is required to add new device types.  </li> <li>Users need USBIP installed once (built into Linux, usbip-win2 for Windows), after that VIIPER can run without additional dependencies or system-wide installation.  </li> </ul> <p>VIIPER currently comes in a single flavor:</p> <ul> <li>a self-contained, (no dependencies) portable, standalone executable.   providing a lightweight TCP based API for feeder application development.  </li> <li>There will eventually be a library version (libVIIPER) that you can link against directly from your application. For more information, see FAQ </li> </ul> <p>Beyond device emulation, VIIPER can proxy real USB devices for traffic inspection and reverse engineering.</p>"},{"location":"#feeder-application-development","title":"\ud83e\udd6b Feeder application development","text":"<p>VIIPER currently comes in a single flavor:</p> <ul> <li>a standalone executable that exposes an API over TCP.</li> <li>There will eventually be a shared-library version (libVIIPER) that you can link against directly from your application. For more information, see FAQ </li> </ul>"},{"location":"#api","title":"\ud83d\udd0c API","text":"<p>VIIPER includes a lightweight TCP based API for device and bus management, as well as streaming device control. It's designed to be trivial to drive from any language that can open a TCP socket and send null-byte-terminated commands.  </p> <p>Client Libraries Available</p> <p>Most of the time, you don't need to implement that raw protocol yourself, as client libraries are available. See Client Libraries Available.</p> <ul> <li>The TCP API uses a string-based request/response protocol terminated by null bytes (<code>\\0</code>) for device and bus management.  </li> <li>Requests have a \"path\" and optional payload (sometimes  JSON).     eg. <code>bus/{id}/add {\"type\": \"keyboard\", \"idVendor\": \"0x6969\"}\\0</code> </li> <li>Responses are often JSON as well!</li> <li>Errors are reported using JSON objectes similar to RFC 7807 Problem Details <sup>The use of JSON allows for future extenability without breaking compatibility ;)<sup> <li>For controlling, or feeding, a device a long lived TCP stream is used, with a wire-protocol specific to each device type.   After an initial \"handshake\" (<code>bus/{busId}/{deviceId}\\0</code>) a device-specific binary protocol is used to send input reports and receive output reports (e.g., rumble commands).</li> <p>VIIPER takes care of all USBIP protocol details, so you can focus on implementing the device logic only. On <code>localhost</code> VIIPER also automatically attached the USBIP client, so you don't have to worry about USBIP details at all.</p> <p>See the API documentation for details</p>"},{"location":"#faq","title":"\u2753 FAQ","text":""},{"location":"#what-is-usbip-and-why-does-viiper-use-it","title":"What is USBIP and why does VIIPER use it?","text":"<p>USBIP is a protocol that allows USB devices to be shared over a network. VIIPER uses it because it's already built into Linux and available for Windows, making virtual device emulation possible without writing custom kernel drivers yourself.</p>"},{"location":"#why-is-this-a-standalone-executable-that-i-have-to-interface-via-tcp-and-not-a-shared-object-library-in-itself","title":"Why is this a standalone executable that I have to interface via TCP, and not a (shared-object) library in itself","text":"<ul> <li>Flexibility</li> <li>allows one to use VIIPER as a service on the same host as the USBIP-Client and use the feeder on a different, remote machine.</li> <li>allows for software written utilizing VIIPER to not be licensed under the terms of the GPLv3</li> <li>future versions: Users can enhance VIIPER with device plugins, sharing a common wire-protocol, which can be dynamically incorporated.</li> <li>That said, there will be a libVIIPER  that you can link against, eleminating multi-process and potential firewall issues.   Note that this will require your application to be licensed under the terms of the GPLv3 (or comptible license)</li> </ul>"},{"location":"#can-i-use-viiper-for-gaming","title":"Can I use VIIPER for gaming?","text":"<p>Yes! VIIPER can create virtual controllers (currently only Xbox360) that appear as real hardware to games and applications. This works with Steam, native Windows games, and any other application supporting controllers.</p>"},{"location":"#how-is-viiper-different-from-other-controller-emulators","title":"How is VIIPER different from other controller emulators?","text":"<p>Most controller emulators require custom kernel drivers for each device type. VIIPER uses USBIP to handle the USB protocol layer, allowing device emulation in userspace without kernel drivers. This makes VIIPER portable, easier to extend, and simpler to bundle with applications.</p>"},{"location":"#can-i-add-support-for-other-device-types","title":"Can I add support for other device types?","text":"<p>Yes! VIIPER's architecture is designed to be extensible. In the future there will be a plugin system to load and expose device types dynamically.</p>"},{"location":"#what-about-the-proxy-mode","title":"What about the proxy mode?","text":"<p>Proxy mode sits between a USBIP client and a USBIP server (like a Linux machine sharing real USB devices). VIIPER intercepts and logs all USB traffic passing through, without handling the devices directly. Useful for reverse engineering USB protocols and understanding how devices communicate.</p>"},{"location":"#what-about-tcp-overhead-or-input-latency-performance","title":"What about TCP overhead or input latency performance?","text":"<p>End-to-end input latency for virtual devices created with VIIPER is typically well below 1 millisecond on a modern desktop (e.g. Windows / Ryzen 3900X test machine). Detailed methodology and sample runs can be found in E2E Latency Benchmarks. However, to not stress the CPU excessively, reports get batched and sent every millisecond. So the best you will achive is a 1000Hz update rate, which is more than enough and more than what most real hardware devices provide. Note: Actual device polling rates may be lower depending on the device type and configuration.</p>"},{"location":"mkdocs-readme/","title":"MkDocs Documentation","text":"<p>This directory contains the MkDocs-based documentation for VIIPER.</p>"},{"location":"mkdocs-readme/#setup","title":"Setup","text":"<p>Install MkDocs with Material theme:</p> <pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"mkdocs-readme/#development","title":"Development","text":"<p>Run the documentation server locally:</p> <pre><code>cd doc\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000/ in your browser.</p>"},{"location":"mkdocs-readme/#building","title":"Building","text":"<p>Build the static documentation site:</p> <pre><code>cd doc\nmkdocs build\n</code></pre> <p>The built site will be in the <code>site/</code> directory.</p>"},{"location":"mkdocs-readme/#deployment","title":"Deployment","text":"<p>Deploy to GitHub Pages:</p> <pre><code>cd doc\nmkdocs gh-deploy\n</code></pre>"},{"location":"mkdocs-readme/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - MkDocs configuration</li> <li><code>docs/</code> - Documentation source files (Markdown)<ul> <li><code>index.md</code> - Home page</li> <li><code>getting-started/</code> - Installation and quick start</li> <li><code>cli/</code> - CLI reference</li> <li><code>api/</code> - API reference</li> </ul> </li> </ul>"},{"location":"api/overview/","title":"API Reference","text":"<p>VIIPER provides a lightweight TCP API for managing and controlling virtual buses/devices. It's designed to be trivial to drive from any language that can open a TCP socket and send null-byte-terminated payloads.</p> <p>Client Libraries Available</p> <p>Client libraries are available that abstract away any protocol details described below. For most use cases, you should use one of the provided client libraries rather than implementing the raw protocol yourself:</p> <ul> <li>Go Client: Reference implementation included in the repository</li> <li>Generator Documentation: Information about code generation</li> <li>C Client Library: Generated C library with type-safe device streams</li> <li>C++ Client Library: Header-only C++20 library (requires external JSON parser)</li> <li>C# Client Library: Generated .NET library with async/await support</li> <li>TypeScript Client Library: Generated Node.js library with EventEmitter streams</li> <li>Rust Client Library: Generated Rust library with sync/async support</li> </ul> <p>The documentation below is provided for reference and for implementing clients in languages not supported officially.</p>"},{"location":"api/overview/#protocol-overview","title":"Protocol overview","text":"<p>The TCP API is inspired by the ubiquitous HTTP REST style, but is more lightweight. If you ever worked with HTTP APIs before, you'll feel right at home. The exception to this are the device-control and feedback streams, which are raw binary streams specific to each device type.</p> <ul> <li>Transport: TCP</li> <li>Default listen address: <code>:3242</code> (configurable via <code>--api.addr</code>)</li> <li>Request format: a single ASCII/UTF\u20118 line terminated by <code>\\0</code></li> <li>Routing: path followed by optional payload separated by whitespace   (e.g., <code>bus/list\\0</code> or <code>bus/create 5\\0</code>)</li> <li>Payload: optional string that can be a JSON object, numeric value, or plain string depending on the endpoint.   The payload may contain newlines (e.g., pretty-printed JSON) as only the null byte terminates the request.</li> <li>Success response: a single line containing a JSON payload (or an empty line for commands that have no payload), terminated by connection close</li> <li>Error response: a single line JSON object following RFC 7807 Problem Details format with a <code>status</code> field (HTTP-style status code) and other error details, terminated by connection close</li> </ul> <p>Testing the API</p> <p>For quick testing, you can use tools like <code>netcat</code> (Linux/macOS) or PowerShell scripts (Windows) to send requests and read responses.</p> <p>Connection timing and auto\u2011cleanup</p> <p>After you add a device with <code>bus/{id}/add</code>, you must connect to its streaming endpoint within the configured <code>DeviceHandlerConnectTimeout</code> (default: 5s). If no stream connection is established in time, the device is automatically removed. Likewise, when a stream disconnects, a reconnection timer with the same timeout starts; if the client doesn\u2019t reconnect before it expires, the device is removed.</p>"},{"location":"api/overview/#endpoints","title":"Endpoints","text":"<p>null byte excluded</p> <p>The <code>\\0</code> (null byte) terminator is excluded from all examples below for readability. All requests must be terminated with a null byte (unless otherwise noted).</p> <ul> <li> <p>Bus Management</p> <p>Create, list, and remove virtual buses</p> <p>Jump to section</p> </li> <li> <p>Device Management</p> <p>Add, list, and remove devices on a bus</p> <p>Jump to section</p> </li> <li> <p>Device Control / Feedback</p> <p>Real-time input and feedback streams for devices</p> <p>Jump to section</p> </li> <li> <p>Error Handling</p> <p>Error response format and common error codes</p> <p>Jump to section</p> </li> </ul>"},{"location":"api/overview/#bus-management","title":"Bus Management","text":""},{"location":"api/overview/#ping","title":"<code>ping</code>","text":"ping - Simple identity and version check <p>Request: <code>ping</code></p> <p>Response: <code>{ \"server\": \"VIIPER\", \"version\": \"1.2.3[-dev-abcd]\" }</code></p>"},{"location":"api/overview/#buslist","title":"<code>bus/list</code>","text":"bus/list - List all virtual bus IDs <p>Request: <code>bus/list</code></p> <p>Response: <code>{ \"buses\": [1, 2, ...] }</code></p>"},{"location":"api/overview/#buscreate-busid","title":"<code>bus/create [busId]</code>","text":"bus/create - Create a new bus <p>Request: <code>bus/create</code> or <code>bus/create 5</code></p> <p>Payload: Optional numeric bus ID (e.g., <code>5</code>) If provided, VIIPER attempts to create the bus with that id; otherwise it picks the next free id.</p> <p>Response: <code>{ \"busId\": &lt;id&gt; }</code></p>"},{"location":"api/overview/#busremove-busid","title":"<code>bus/remove &lt;busId&gt;</code>","text":"bus/remove - Remove a bus and all devices on it <p>Request: <code>bus/remove 1</code></p> <p>Payload: Numeric bus ID (e.g., <code>1</code>)</p> <p>Response: <code>{ \"busId\": &lt;id&gt; }</code></p>"},{"location":"api/overview/#device-management","title":"Device Management","text":""},{"location":"api/overview/#busidlist","title":"<code>bus/{id}/list</code>","text":"bus/{id}/list - List devices on a bus <p>Request: <code>bus/1/list</code></p> <p>Response: <pre><code>{\n  \"devices\": [\n    {\n      \"busId\": 1,\n      \"devId\": \"1\",\n      \"vid\": \"0x045e\",\n      \"pid\": \"0x028e\",\n      \"type\": \"xbox360\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/overview/#busidadd-json_payload","title":"<code>bus/{id}/add &lt;json_payload&gt;</code>","text":"bus/{id}/add - Add a device to a bus <p>Request: <code>bus/1/add {\"type\":\"xbox360\"}</code></p> <p>Payload: JSON object with device creation parameters <pre><code>{\n  \"type\": \"&lt;deviceType&gt;\",\n  \"idVendor\": &lt;optional_vid&gt;,\n  \"idProduct\": &lt;optional_pid&gt;\n}\n</code></pre></p> <p>Examples: - <code>{\"type\":\"xbox360\"}</code> - <code>{\"type\":\"keyboard\",\"idVendor\":1234,\"idProduct\":5678}</code></p> <p>Response: <pre><code>{\n  \"busId\": 1,\n  \"devId\": \"1\",\n  \"vid\": \"0x045e\",\n  \"pid\": \"0x028e\",\n  \"type\": \"xbox360\"\n}\n</code></pre></p> <p>Connection timeout</p> <p>After add, the server starts a connect timer (default <code>5s</code>). You must open a device stream before the timeout expires, otherwise the device is auto-removed.</p> <p>Auto-attach</p> <p>If auto-attach is enabled (default), the server automatically attaches the new device to a local USBIP client on the same host (localhost only). Failures are logged but do not affect the API response.</p>"},{"location":"api/overview/#busidremove-deviceid","title":"<code>bus/{id}/remove &lt;deviceId&gt;</code>","text":"bus/{id}/remove - Remove a device from a bus <p>Request: <code>bus/1/remove 1</code></p> <p>Payload: Numeric device ID (e.g., <code>1</code> for device 1-1 on the bus)</p> <p>Response: <code>{ \"busId\": &lt;id&gt;, \"devId\": \"&lt;dev&gt;\" }</code></p>"},{"location":"api/overview/#device-control--feedback","title":"Device Control / Feedback","text":"<p>Device Control and Feedback requires an initial \"handshake\" request, afterwards the connection is used as a long-lived (device-specific, binary) bidirectional stream.</p> <p>Establish control/feedback connection/stream</p> <p>Path: <code>bus/{busId}/{deviceId}</code></p> <p>Handshake: Send the path followed by <code>\\0</code> (null byte) Example: <code>bus/1/1\\0</code></p> <p>Type: Long-lived TCP connection</p> <p>Purpose: Device-specific, bidirectional stream.  </p> <p>Timeout behavior</p> <p>When a stream ends, a reconnect timer is started. If the client doesn't reconnect in time, the device is removed.</p> <p>Device control and feedback is device-specific. Each device type defines it's own packet formats.  </p> <p>In general the client (your code) sends sends binary input state packets to the VIIPER server and possibly receives binary feedback packets (rumble, keyboard leds, etc.) back.</p> <p>Refer to the individual device documentation for details on packet formats and behavior.</p>"},{"location":"api/overview/#error-handling","title":"Error Handling","text":"<p>All errors are inspired by HTTP REST APIs and are returned as single-line JSON objects in the style of RFC 7807 Problem Details. The connection closes immediately after the error response.  </p> <p>If you have ever worked with HTTP APIs, the errors and status codes will feel familiar.</p>"},{"location":"api/overview/#error-response-format","title":"Error Response Format","text":"<pre><code>{\n  \"status\": 400,\n  \"title\": \"Bad Request\",\n  \"detail\": \"missing payload\"\n}\n</code></pre> <p>Fields:</p> <ul> <li><code>status</code> (number): HTTP-style status code indicating the error type</li> <li><code>title</code> (string): Short, human-readable summary of the problem</li> <li><code>detail</code> (string): Explanation specific to this occurrence</li> </ul>"},{"location":"api/overview/#common-error-codes","title":"Common Error Codes","text":"<p>Error codes are basically HTTP carbon copies:</p> Status Title Cause Example 400 Bad Request Invalid request format, missing payload, or invalid JSON Missing device type in <code>bus/{id}/add</code>, invalid busId format 404 Not Found Resource does not exist Bus ID not found, device ID not found 409 Conflict Resource already exists or cannot be modified Bus ID already exists, auto-attach failure 500 Internal Server Error (Unhandled) Server-side error during operation Failed to marshal response, device add failure, unknown error"},{"location":"api/overview/#example-sessions","title":"Example sessions","text":"PowerShell (Windows)netcat (Linux/macOS)\" <p>VIIPER includes convenience scripts for quick testing and automation:</p> <pre><code># Source the script to load helper functions\n. .\\scripts\\viiper-api.ps1\n\n# Use the Invoke-ViiperApi function (or 'viiper' alias)\nviiper \"bus/list\"\nviiper \"bus/create\"\nviiper \"bus/1/add {\\\"type\\\":\\\"xbox360\\\"}\" -Port 3242 -Hostname localhost\n</code></pre> <p>The script provides <code>Invoke-ViiperApi</code> (alias: <code>viiper</code>) for sending commands and <code>Connect-ViiperDevice</code> for testing persistent device connections.</p> <pre><code># List buses\nprintf \"bus/list\\0\" | nc localhost 3242\n\n# Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n# \u2192 {\"busId\":1}\n\n# Create a bus with specific ID\nprintf \"bus/create 5\\0\" | nc localhost 3242\n# \u2192 {\"busId\":5}\n\n# Add a virtual Xbox 360 controller to bus 1\nprintf 'bus/1/add {\"type\":\"xbox360\"}\\0' | nc localhost 3242\n# \u2192 {\"busId\":1,\"devId\":\"1\",\"vid\":\"0x045e\",\"pid\":\"0x028e\",\"type\":\"xbox360\"}\n\n# List devices on bus 1\nprintf \"bus/1/list\\0\" | nc localhost 3242\n</code></pre> <p>Then, open a second TCP connection for device control to <code>bus/1/1</code> (the API port, not the USBIP port). First send the \"handshake\" <code>bus/1/1\\0</code>, then you'll write device-specific input packets and read device-specific feedback packets. Any language with raw TCP support works.</p>"},{"location":"api/overview/#go-snippet-raw-tcp-socket","title":"Go snippet (raw TCP Socket)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net\"\n)\n\nfunc main() {\n    conn, _ := net.Dial(\"tcp\", \"localhost:3242\")\n    defer conn.Close()\n\n    // Send request with null terminator\n    fmt.Fprint(conn, \"bus/create\\x00\")\n\n    // Read entire response until connection closes\n    resp, _ := io.ReadAll(conn)\n    fmt.Println(string(resp)) // {\"busId\":1}\\n\n}\n</code></pre> <p>For a higher-level experience, see the Go client in <code>/apiclient/</code>.</p>"},{"location":"api/overview/#how-this-relates-to-usbip","title":"How this relates to USBIP","text":"<p>The VIIPER API controls which virtual devices exist and exposes a device stream for live input/feedback. Separately, the USBIP server (default <code>:3241</code>) makes these devices attachable from USBIP clients.</p> <p>Typical flow:</p> <ol> <li>Create a bus</li> <li>Add a device</li> <li>Connect the device stream</li> <li>Attach a USBIP client to the device</li> </ol> <p>If auto-attach is enabled step 4 is attempted automatically for the local host; you still must perform step 3 to keep the device alive.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Development Version (main)</li> </ul>"},{"location":"changelog/#released-versions","title":"Released Versions","text":"<ul> <li>Version 0.4.0</li> <li>Version 0.3.2</li> <li>Version 0.3.1</li> <li>Version 0.3.0</li> <li>Version 0.2.2</li> <li>Version 0.2.1</li> <li>Version 0.2.0</li> <li>Version 0.1.0</li> <li>Version 0.0.4</li> <li>Version 0.0.3</li> <li>Version 0.0.2</li> <li>Version 0.0.1</li> </ul>"},{"location":"changelog/main/","title":"Main","text":""},{"location":"changelog/main/#changelog-for-development-version","title":"Changelog for Development Version","text":"<p>Changes since v0.4.0:</p>"},{"location":"changelog/main/#miscellaneous","title":"\ud83d\udd27 Miscellaneous","text":"<ul> <li>Configurable write batching time</li> </ul>"},{"location":"cli/codegen/","title":"Code Generation Command","text":"<p>The <code>codegen</code> command generates type-safe client libraries from Go source code annotations. The command can only be run from the VIIPER repository root with the source code available.</p> <p>It scans the VIIPER server codebase to extract:</p> <ul> <li>API routes and response DTOs</li> <li>Device wire formats from <code>viiper:wire</code> comment tags</li> <li>Device constants (keycodes, modifiers, button masks)</li> </ul> <p>Then generates client libraries with:</p> <ul> <li>Management API clients</li> <li>Device-agnostic stream wrappers</li> <li>Per-device encode/decode functions</li> <li>Typed constants and enums</li> </ul> <p>Sourcecode access is required</p> <p>The codegen command requires access to VIIPER source code. Run it from the repository root.</p>"},{"location":"cli/codegen/#usage","title":"Usage","text":"<pre><code>viiper codegen [flags]\n</code></pre>"},{"location":"cli/codegen/#description","title":"Description","text":""},{"location":"cli/codegen/#flags","title":"Flags","text":""},{"location":"cli/codegen/#-output","title":"<code>--output</code>","text":"<p>Output directory for generated client libraries (relative to repository root).</p> <p>Default: <code>clients</code> Environment Variable: <code>VIIPER_CODEGEN_OUTPUT</code></p>"},{"location":"cli/codegen/#-lang","title":"<code>--lang</code>","text":"<p>Target language to generate.</p> <p>Values: <code>c</code>, <code>csharp</code>, <code>typescript</code>, <code>all</code> Default: <code>all</code> Environment Variable: <code>VIIPER_CODEGEN_LANG</code></p>"},{"location":"cli/codegen/#examples","title":"Examples","text":""},{"location":"cli/codegen/#generate-all-client-libraries","title":"Generate All Client Libraries","text":"<pre><code>go run ./cmd/viiper codegen\n</code></pre>"},{"location":"cli/codegen/#generate-c-client-library-and-rebuild-examples","title":"Generate C Client Library and Rebuild Examples","text":"<pre><code>go run ./cmd/viiper codegen --lang=c\ncd examples/c\ncmake --build build --config Release\n</code></pre>"},{"location":"cli/codegen/#when-to-regenerate","title":"When to Regenerate","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>/apitypes/*.go</code>: API response structures</li> <li><code>/device/*/inputstate.go</code>: Wire format annotations</li> <li><code>/device/*/const.go</code>: Exported constants</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li>Generator templates in <code>internal/codegen/generator/</code></li> </ul>"},{"location":"cli/codegen/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: Detailed explanation of tagging system and code generation flow</li> <li>API and Client Reference: API endpoints and data structures</li> <li>Configuration: Global configuration options</li> </ul>"},{"location":"cli/configuration/","title":"Configuration","text":"<p>Aside from passing CLI flags, VIIPER can also be configured via environment variables and configuration files.</p> <p>For configuration files, VIIPER supports <code>JSON</code>, <code>YAML</code>, and <code>TOML</code> formats.</p>"},{"location":"cli/configuration/#environment-variables","title":"Environment Variables","text":"<p>All command-line flags have corresponding environment variables for easier deployment and configuration management.</p>"},{"location":"cli/configuration/#global-configuration","title":"Global Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_LOG_LEVEL</code> <code>--log.level</code> <code>info</code> Logging level: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> <code>VIIPER_LOG_FILE</code> <code>--log.file</code> (none) Log file path (logs only to console if not set) <code>VIIPER_LOG_RAW_FILE</code> <code>--log.raw-file</code> (none) Raw packet log file path"},{"location":"cli/configuration/#server-configuration","title":"Server Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_USB_ADDR</code> <code>--usb.addr</code> <code>:3241</code> USBIP server listen address <code>VIIPER_API_ADDR</code> <code>--api.addr</code> <code>:3242</code> API server listen address <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code> <code>--api.device-handler-timeout</code> <code>5s</code> Device handler auto-cleanup timeout <code>VIIPER_API_AUTO_ATTACH_LOCAL_CLIENT</code> <code>--api.auto-attach-local-client</code> <code>true</code> Auto-attach exported devices to local usbip client <code>VIIPER_CONNECTION_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection operation timeout"},{"location":"cli/configuration/#proxy-configuration","title":"Proxy Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_PROXY_ADDR</code> <code>--listen-addr</code> <code>:3241</code> Proxy listen address <code>VIIPER_PROXY_UPSTREAM</code> <code>--upstream</code> (required) Upstream USBIP server address <code>VIIPER_PROXY_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection timeout"},{"location":"cli/configuration/#configuration-files","title":"Configuration Files","text":"<p>VIIPER supports JSON, YAML, and TOML configuration files. Generate a starter file (default configuration) with:</p> <pre><code>viiper config init server --format=json   # or yaml/toml\n</code></pre> <p>If no output path is provided, the file is written to the current working directory (e.g., <code>server.json</code>, <code>proxy.yaml</code>).</p> <p>You can also specify a custom location:</p> <pre><code>viiper config init server --format=json --output ./server.json\n</code></pre> <p>To use a specific configuration file when starting VIIPER, pass the --config flag (or set the <code>VIIPER_CONFIG</code> environment variable):</p> <pre><code>viiper --config ./server.json server\n</code></pre> <p>If --config is not provided, VIIPER will search for configuration in this order and first-found is used for each format:</p> <ol> <li>Working directory: server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), viiper.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Platform config directory (see above): server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Linux system-wide: /etc/viiper/server.(json|yaml|yml|toml), /etc/viiper/proxy.(json|yaml|yml|toml), /etc/viiper/config.(json|yaml|yml|toml)</li> </ol>"},{"location":"cli/configuration/#configuration-examples","title":"Configuration Examples","text":"Config filesEnvironment Variables <p>Server:</p> <pre><code>{\n\"api\": {\n    \"addr\": \":3242\",\n    \"device-handler-connect-timeout\": \"5s\",\n    \"auto-attach-local-client\": true\n},\n\"usb\": {\n    \"addr\": \":3241\"\n},\n\"connection-timeout\": \"30s\"\n}\n</code></pre> <p>Proxy:</p> <pre><code>{\n\"listen-addr\": \":3241\",\n\"upstream-addr\": \"127.0.0.1:3242\",\n\"connection-timeout\": \"30s\"\n}\n</code></pre> <p>Create a <code>.env</code> file or export variables:</p> <pre><code>export VIIPER_LOG_LEVEL=debug\nexport VIIPER_USB_ADDR=:3241\nexport VIIPER_API_ADDR=:3242\nexport VIIPER_LOG_FILE=/var/log/viiper.log\n</code></pre> <p>Then run:</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/configuration/#systemd-service","title":"Systemd Service","text":"<p>Example systemd service file for running VIIPER as a service:</p> <pre><code>[Unit]\nDescription=VIIPER USBIP Server\nAfter=network.target\n\n[Service]\nType=simple\nUser=viiper\nGroup=viiper\nEnvironment=\"VIIPER_LOG_LEVEL=info\"\nEnvironment=\"VIIPER_LOG_FILE=/var/log/viiper/viiper.log\"\nEnvironment=\"VIIPER_USB_ADDR=:3241\"\nEnvironment=\"VIIPER_API_ADDR=:3242\"\nExecStart=/usr/local/bin/viiper server\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"cli/configuration/#configuration-priority","title":"Configuration Priority","text":"<p>When both CLI flags and environment variables are set, CLI flags take precedence:</p> <ol> <li>CLI flags (highest priority)</li> <li>Environment variables</li> <li>Configuration file values</li> <li>Default values (lowest priority)</li> </ol>"},{"location":"cli/configuration/#see-also","title":"See Also","text":"<ul> <li>Server Command</li> <li>Proxy Command</li> </ul>"},{"location":"cli/overview/","title":"CLI Overview","text":"<p>VIIPER provides a command-line interface for running the USBIP server and proxy.</p>"},{"location":"cli/overview/#commands","title":"Commands","text":"<ul> <li><code>server</code> - Start the VIIPER USBIP server</li> <li><code>proxy</code> - Start the VIIPER USBIP proxy</li> <li><code>install</code> - Configure VIIPER to start automatically on system boot (see Installation)</li> <li><code>uninstall</code> - Remove VIIPER from system startup configuration</li> <li><code>codegen</code> - Generate client libraries from source code annotations</li> </ul>"},{"location":"cli/overview/#global-options","title":"Global Options","text":""},{"location":"cli/overview/#logging","title":"Logging","text":"<p>VIIPER supports flexible logging configuration via global flags or environment variables.</p>"},{"location":"cli/overview/#-loglevel","title":"<code>--log.level</code>","text":"<p>Set the logging level.</p> <p>Values: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> Default: <code>info</code> Environment Variable: <code>VIIPER_LOG_LEVEL</code></p> <p>Example:</p> <pre><code>viiper server --log.level=debug\n</code></pre>"},{"location":"cli/overview/#-logfile","title":"<code>--log.file</code>","text":"<p>Log to a file in addition to console output.</p> <p>Default: (none - logs only to console) Environment Variable: <code>VIIPER_LOG_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/overview/#-lograw-file","title":"<code>--log.raw-file</code>","text":"<p>Log raw USB packet data to a file for debugging and reverse engineering.</p> <p>Default: (none) Environment Variable: <code>VIIPER_LOG_RAW_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre> <p>Automatic Raw Logging</p> <p>When <code>--log.level=trace</code> is set without <code>--log.raw-file</code>, raw packets are logged to stdout.</p>"},{"location":"cli/overview/#getting-help","title":"Getting Help","text":"<p>Display help for any command:</p> <pre><code>viiper --help\nviiper server --help\nviiper proxy --help\n</code></pre>"},{"location":"cli/proxy/","title":"Proxy Command","text":"<p>The <code>proxy</code> command starts VIIPER in proxy mode, sitting between a USBIP client and a USBIP server. VIIPER intercepts and logs all USB traffic passing through, without handling the devices directly.</p> <p>This is useful for reverse engineering USB protocols and understanding how devices communicate.</p> <pre><code>USBIP Client  \u2192  VIIPER Proxy  \u2192  USBIP Server (real devices or VIIPER)\n                      \u2193\n              Logs/Captures Traffic\n</code></pre>"},{"location":"cli/proxy/#usage","title":"Usage","text":"<pre><code>viiper proxy --upstream=&lt;address&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/proxy/#options","title":"Options","text":""},{"location":"cli/proxy/#-listen-addr","title":"<code>--listen-addr</code>","text":"<p>Proxy listen address (where clients connect).</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_PROXY_ADDR</code></p>"},{"location":"cli/proxy/#-upstream","title":"<code>--upstream</code>","text":"<p>Required. Upstream USBIP server address (where real devices are).</p> <p>Environment Variable: <code>VIIPER_PROXY_UPSTREAM</code></p>"},{"location":"cli/proxy/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection timeout for proxy operations.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_PROXY_TIMEOUT</code></p>"},{"location":"cli/proxy/#examples","title":"Examples","text":""},{"location":"cli/proxy/#basic-proxy","title":"Basic Proxy","text":"<p>Start proxy between local clients and remote USBIP server:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240\n</code></pre> <p>Clients connect to <code>localhost:3241</code>, traffic is proxied to <code>192.168.1.100:3240</code>.</p>"},{"location":"cli/proxy/#custom-listen-address","title":"Custom Listen Address","text":"<p>Start proxy on a different port:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3240\n</code></pre> <p>Clients connect to <code>localhost:9000</code>, traffic is proxied to <code>192.168.1.100:3240</code>.</p>"},{"location":"cli/proxy/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Capture all USB traffic for reverse engineering:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --log.raw-file=usb-capture.log\n</code></pre> <p>All USB packets will be logged to <code>usb-capture.log</code>.</p>"},{"location":"cli/proxy/#with-debug-logging","title":"With Debug Logging","text":"<p>Enable debug logging to see proxy operations:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3240 --log.level=debug\n</code></pre>"},{"location":"cli/proxy/#use-cases","title":"Use Cases","text":""},{"location":"cli/proxy/#reverse-engineering","title":"Reverse Engineering","text":"<p>Intercept USB traffic between a client and server to understand device protocols:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.raw-file=device-capture.log\n</code></pre>"},{"location":"cli/proxy/#traffic-analysis","title":"Traffic Analysis","text":"<p>Monitor USB communication for debugging:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.level=trace\n</code></pre>"},{"location":"cli/proxy/#network-inspection","title":"Network Inspection","text":"<p>Route USB traffic through VIIPER to inspect and log all operations:</p> <pre><code>viiper proxy --upstream=real-server:3240 --log.level=debug --log.raw-file=traffic.log\n</code></pre>"},{"location":"cli/proxy/#see-also","title":"See Also","text":"<ul> <li>Server Command - Run VIIPER as a USBIP server</li> <li>Configuration - Environment variables and configuration files</li> </ul>"},{"location":"cli/server/","title":"Server Command","text":"<p>Start the VIIPER daemon/server to expose virtual devices. This is the default command you should run when you want to create virtual USB devices using VIIPER.</p>"},{"location":"cli/server/#usage","title":"Usage","text":"<pre><code>viiper server [OPTIONS]\n</code></pre>"},{"location":"cli/server/#description","title":"Description","text":"<p>The <code>server</code> command starts the VIIPER USBIP server, which allows you to create and manage virtual USB devices that appear as real hardware to USBIP clients.</p> <p>The server exposes two interfaces:</p> <ol> <li>USBIP Server - Standard USBIP protocol for device attachment</li> <li>VIIPER API Server - Management API for device/bus control</li> </ol> <p>Automatic Local Attachment</p> <p>By default, VIIPER automatically attaches newly created devices to the local USBIP client (localhost only). This means when you create a device via the API, it will be immediately available on the same machine without manual <code>usbip attach</code> commands. This behavior can be disabled with <code>--api.auto-attach-local-client=false</code> if you prefer manual control or are running on a remote server.</p>"},{"location":"cli/server/#options","title":"Options","text":""},{"location":"cli/server/#-usbaddr","title":"<code>--usb.addr</code>","text":"<p>USBIP server listen address.</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_USB_ADDR</code></p>"},{"location":"cli/server/#-apiaddr","title":"<code>--api.addr</code>","text":"<p>API server listen address.</p> <p>Default: <code>:3242</code> Environment Variable: <code>VIIPER_API_ADDR</code></p>"},{"location":"cli/server/#-apidevice-handler-timeout","title":"<code>--api.device-handler-timeout</code>","text":"<p>Time before auto-cleanup occurs when a device handler has no active connection.</p> <p>Default: <code>5s</code> Environment Variable: <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code></p>"},{"location":"cli/server/#-apiauto-attach-local-client","title":"<code>--api.auto-attach-local-client</code>","text":"<p>Automatically attach newly added devices to a local USBIP client on the same host (localhost only). This is a convenience feature; attachment failures (tool not found, error exit) are logged but do not abort device creation.</p> <p>VIIPER expects the USBIP command-line tool to be in the PATH (should be by default) (<code>usbip</code> on Linux, <code>usbip.exe</code> on Windows). If it is missing, auto-attach will simply log an error.</p> <p>Default: <code>true</code> Environment Variable: <code>VIIPER_API_AUTO_ATTACH_LOCAL_CLIENT</code></p> <p>Disable example:</p> <pre><code>viiper server --api.auto-attach-local-client=false\n</code></pre>"},{"location":"cli/server/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection operation timeout for both USBIP and API servers.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_CONNECTION_TIMEOUT</code></p>"},{"location":"cli/server/#examples","title":"Examples","text":""},{"location":"cli/server/#basic-server","title":"Basic Server","text":"<p>Start server with default settings (USBIP on :3241, API on :3242):</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/server/#custom-addresses","title":"Custom Addresses","text":"<p>Start server on custom ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre>"},{"location":"cli/server/#with-logging","title":"With Logging","text":"<p>Start server with debug logging to file:</p> <pre><code>viiper server --log.level=debug --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/server/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Start server with raw USB packet logging (useful for reverse engineering):</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre>"},{"location":"cli/server/#connect-from-a-client-usbip","title":"Connect from a client (USBIP)","text":"<p>After the server is running and a virtual device has been added to a bus (via the API), attach it from a client using USBIP.</p> <p>Notes:</p> <ul> <li>VIIPER's USBIP server listens on <code>:3241</code> by default (configurable via <code>--usb.addr</code>).</li> <li>The BUSID-DEVICEID you need (e.g. <code>1-1</code>) is returned by the API on device add and also visible via <code>usbip list</code>.</li> </ul> WindowsLinux <p>On Windows, use usbip-win2:</p> <ul> <li>GUI: use the client to add a remote host and attach by busid.</li> <li>CLI (similar flags):</li> </ul> <pre><code>usbip.exe list --remote VIIPER_HOST --tcp-port 3241\nusbip.exe attach --remote VIIPER_HOST --tcp-port 3241 --busid BUSID-DEVICEID\n</code></pre> <pre><code># Load the virtual host controller (only needed once per boot)\nsudo modprobe vhci-hcd\n\n# List exportable devices on the VIIPER host\nusbip list --remote=VIIPER_HOST --tcp-port=3241\n\n# Attach a device by busid (long flags)\nsudo usbip attach --remote=VIIPER_HOST --tcp-port=3241 --busid=BUSID-DEVICEID\n\n# Equivalent short-form flags\nsudo usbip --tcp-port 3241 -r VIIPER_HOST -b BUSID-DEVICEID\n</code></pre> <p>Replace <code>VIIPER_HOST</code> with the server's hostname/IP. If you changed the USBIP port, use that port instead of <code>3241</code>.</p> <p>Once attached, the device will appear to the OS/applications as a local USB device.</p>"},{"location":"cli/server/#see-also","title":"See Also","text":"<ul> <li>Configuration - Environment variables and configuration files</li> <li>API Reference - API server documentation</li> </ul>"},{"location":"clients/c/","title":"C Client Library Documentation","text":"<p>The VIIPER C client library provides a lightweight, dependency-free client library for interacting with VIIPER servers and controlling virtual devices.</p> <p>The C client library features:</p> <ul> <li>Zero dependencies: Pure C99, no external libraries required</li> <li>Cross-platform: Windows (MSVC) and POSIX (GCC/Clang)</li> <li>Type-safe: Generated headers with packed structs and constants</li> <li>Thread-safe: Recommended: one <code>viiper_client_t</code> per thread</li> <li>Device-agnostic streaming API: Uniform interface for all device types</li> </ul> <p>License</p> <p>The C client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/c/#installation","title":"Installation","text":""},{"location":"clients/c/#building-from-source","title":"Building from Source","text":"<p>The C client library is generated from the VIIPER server codebase:</p> <pre><code>go run ./cmd/viiper codegen --lang=c\n</code></pre> <p>Build the client library:</p> <pre><code>cd ../clients/c\ncmake -B build -G \"Visual Studio 17 2022\"  # Windows\ncmake -B build                             # LINUX\ncmake --build build --config Release\n</code></pre>"},{"location":"clients/c/#linking-to-your-project","title":"Linking to Your Project","text":"<p>CMake:</p> <pre><code># Add viiper client library\nadd_subdirectory(path/to/clients/c)\ntarget_link_libraries(your_target PRIVATE viiper)\n\n# Copy DLL on Windows (post-build)\nif(WIN32)\n    add_custom_command(TARGET your_target POST_BUILD\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n        $&lt;TARGET_FILE:viiper&gt;\n        $&lt;TARGET_FILE_DIR:your_target&gt;\n    )\nendif()\n</code></pre> <p>Manual:</p> <ul> <li>Include: <code>clients/c/include/viiper/viiper.h</code></li> <li>Link: <code>clients/c/build/Release/viiper.lib</code> (Windows) or <code>libviiper.a</code> (POSIX)</li> <li>Runtime: Copy <code>viiper.dll</code> next to your executable (Windows)</li> </ul>"},{"location":"clients/c/#example","title":"Example","text":"<pre><code>#include &lt;viiper/viiper.h&gt;\n#include &lt;viiper/viiper_keyboard.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Create new Viiper client\n    viiper_client_t* client = NULL;\n    int err = viiper_client_create(\"127.0.0.1\", 3242, &amp;client);\n    if (err != 0) {\n        fprintf(stderr, \"Failed to connect: %s\\n\", viiper_strerror(err));\n        return 1;\n    }\n\n    // Create or find a bus\n    viiper_bus_list_response_t buses = {0};\n    err = viiper_bus_list(client, &amp;buses);\n    uint32_t bus_id = (buses.BusesCount &gt; 0) ? buses.Buses[0] : 0;\n\n    if (bus_id == 0) {\n        viiper_bus_create_response_t resp = {0};\n        uint32_t desired_id = 1;\n        err = viiper_bus_create(client, &amp;desired_id, &amp;resp); // NULL for auto-assign\n        bus_id = resp.BusID;\n    }\n\n    // Add device and connect (convenience function)\n    const char* device_type = \"keyboard\";\n    viiper_device_create_request_t req = {\n        .Type = &amp;device_type,\n        .IdVendor = NULL,\n        .IdProduct = NULL\n    };\n    viiper_device_info_t dev_info = {0};\n    viiper_device_t* device = NULL;\n    err = viiper_add_device_and_connect(client, bus_id, &amp;req, &amp;dev_info, &amp;device);\n\n    // Send keyboard input\n    viiper_keyboard_input_t input = {\n        .modifiers = 0,\n        .count = 1\n    };\n    uint8_t keys[] = {VIIPER_KEYBOARD_KEY_A};\n    input.keys = keys;\n    input.keys_count = 1;\n\n    err = viiper_device_send(device, &amp;input, sizeof(input.modifiers) + sizeof(input.count) + input.keys_count);\n\n    // Cleanup\n    viiper_device_close(device);\n\n    char bus_id_str[32];\n    snprintf(bus_id_str, sizeof(bus_id_str), \"%u\", bus_id);\n    viiper_device_remove_response_t remove_resp = {0};\n    viiper_bus_device_remove(client, bus_id_str, dev_info.DevId, &amp;remove_resp);\n\n    viiper_client_free(client);\n    return 0;\n}\n</code></pre>"},{"location":"clients/c/#device-controlfeedback-api","title":"Device Control/Feedback API","text":""},{"location":"clients/c/#creating-a-device-controlfeedback-stream","title":"Creating a Device Control/Feedback Stream","text":"<p>Manual (add device, then connect):</p> <pre><code>// Add device first\nconst char* device_type = \"keyboard\";\nviiper_device_create_request_t req = {\n    .Type = &amp;device_type,\n    .IdVendor = NULL,  // Optional: set to specify custom VID\n    .IdProduct = NULL  // Optional: set to specify custom PID\n};\n\nchar bus_id_str[32];\nsnprintf(bus_id_str, sizeof(bus_id_str), \"%u\", bus_id);\n\nviiper_device_info_t dev_info = {0};\nviiper_error_t err = viiper_bus_device_add(client, bus_id_str, &amp;req, &amp;dev_info);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to add device: %s\\n\", viiper_get_error(client));\n}\n\n// Then connect to its stream\nviiper_device_t* device = NULL;\nerr = viiper_open_stream(client, bus_id, dev_info.DevId, &amp;device);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to open device stream: %s\\n\", viiper_get_error(client));\n}\n</code></pre> <p>Convenience approach (add and connect in one call):</p> <pre><code>const char* device_type = \"xbox360\";\nviiper_device_create_request_t req = {\n    .Type = &amp;device_type,\n    .IdVendor = NULL,\n    .IdProduct = NULL\n};\n\nviiper_device_info_t dev_info = {0};\nviiper_device_t* device = NULL;\nviiper_error_t err = viiper_add_device_and_connect(client, bus_id, &amp;req, &amp;dev_info, &amp;device);\nif (err != VIIPER_OK) {\n    fprintf(stderr, \"Failed to add and connect device: %s\\n\", viiper_get_error(client));\n}\n</code></pre>"},{"location":"clients/c/#sending-input","title":"Sending Input","text":"<pre><code>viiper_mouse_input_t input = {\n    .buttons = VIIPER_MOUSE_BTN_LEFT,\n    .dx = 10,\n    .dy = -5,\n    .wheel = 0,\n    .pan = 0\n};\n\nint err = viiper_device_send(device, &amp;input, sizeof(input));\n</code></pre>"},{"location":"clients/c/#receiving-feedback-rumble-leds-etc","title":"Receiving Feedback (Rumble, LEDs, etc.)","text":"<pre><code>void on_led_update(void* user_data, const void* data, size_t len) {\n    if (len &lt; 1) return;\n    uint8_t leds = ((uint8_t*)data)[0];\n    printf(\"LEDs: NumLock=%d CapsLock=%d ScrollLock=%d\\n\",\n           !!(leds &amp; VIIPER_KEYBOARD_LED_NUM_LOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LED_CAPS_LOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LED_SCROLL_LOCK));\n}\n\nviiper_device_on_output(device, on_led_update, NULL);\n</code></pre>"},{"location":"clients/c/#closing-a-stream","title":"Closing a Stream","text":"<pre><code>viiper_device_close(device);\n</code></pre> <p>The VIIPER server automatically removes the device when the stream is closed after a short timeout.</p>"},{"location":"clients/c/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific packet formats, constants, and wire protocols. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The C client library provides generated structs and constants in device-specific headers (e.g., <code>viiper_keyboard.h</code>, <code>viiper_mouse.h</code>, <code>viiper_xbox360.h</code>).</p>"},{"location":"clients/c/#struct-packing","title":"Struct Packing","text":"<p>All device I/O structs use <code>#pragma pack(1)</code> to ensure wire compatibility (no padding).</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t buttons;\n    int8_t dx;\n    // ...\n} viiper_mouse_input_t;\n#pragma pack(pop)\n</code></pre> <p>Compiler compatibility</p> <p>Important: Always ensure your compiler respects packing directives. MSVC and GCC/Clang handle this correctly by default.</p>"},{"location":"clients/c/#troubleshooting","title":"Troubleshooting","text":""},{"location":"clients/c/#missing-dll-on-windows","title":"Missing DLL on Windows","text":"<p>Symptom: Application crashes immediately with \"viiper.dll not found\"</p> <p>Solution: Copy <code>viiper.dll</code> to the same directory as your executable:</p> <pre><code>add_custom_command(TARGET your_target POST_BUILD\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    $&lt;TARGET_FILE:viiper&gt;\n    $&lt;TARGET_FILE_DIR:your_target&gt;\n)\n</code></pre>"},{"location":"clients/c/#repeated-keys-not-working","title":"Repeated Keys Not Working","text":"<p>Symptom: Typing \"Hello\" outputs \"Helo\" (missing duplicate letter)</p> <p>Solution: Add sufficient delays between key press, release, and next action:</p> <pre><code>press_and_release(dev, VIIPER_KEYBOARD_KEY_L, 0);\nSleep(100);\npress_and_release(dev, VIIPER_KEYBOARD_KEY_L, 0);\n</code></pre>"},{"location":"clients/c/#struct-padding-issues","title":"Struct Padding Issues","text":"<p>Symptom: Device input is corrupted or \"spazzing\"</p> <p>Solution: Verify <code>#pragma pack(1)</code> is applied to device structs. All generated headers include this by default.</p>"},{"location":"clients/c/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/c/virtual_keyboard/main.c</code></li> <li>Types \"Hello!\" every 5 seconds</li> <li> <p>Reads LED state (NumLock, CapsLock, ScrollLock)</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/c/virtual_x360_pad/main.c</code></p> </li> <li>Simulates button presses and stick movements</li> <li>Receives rumble feedback</li> </ul> <p>Build and run:</p> <pre><code>cd examples/c\ncmake -B build -G \"Visual Studio 17 2022\"\ncmake --build build --config Release\n./build/Release/virtual_keyboard.exe 127.0.0.1:3242\n</code></pre>"},{"location":"clients/c/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How the C client library is generated</li> <li>Go Client Documentation: Reference implementation</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>C# Client Library Documentation: .NET client library</li> <li>Rust Client Library Documentation: Rust client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"clients/cpp/","title":"C++ Client Library Documentation","text":"<p>The VIIPER C++ client library provides a modern, header-only C++20 client library for interacting with VIIPER servers and controlling virtual devices.</p> <p>The C++ client library features:</p> <ul> <li>Header-only: No separate compilation required, just include and use</li> <li>C++20: Uses concepts, designated initializers, std::optional, smart pointers</li> <li>Type-safe: Generated structs with constants and helper maps</li> <li>Callback-based output: Register lambdas for device feedback (LEDs, rumble)</li> <li>Thread-safe: Separate mutexes for send/recv operations</li> <li>Cross-platform: Windows (MSVC) and POSIX (GCC/Clang)</li> </ul> <p>JSON Parser Required</p> <p>The C++ client library requires a JSON library to be provided by the user. You must define <code>VIIPER_JSON_INCLUDE</code>, <code>VIIPER_JSON_NAMESPACE</code>, and <code>VIIPER_JSON_TYPE</code> before including the client library headers.</p> <p>Recommended: nlohmann/json - a header-only JSON library that can be easily integrated.</p> <p>License</p> <p>The C++ client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/cpp/#installation","title":"Installation","text":""},{"location":"clients/cpp/#1-header-only-integration","title":"1. Header-Only Integration","text":"<p>Copy the <code>clients/cpp/include/viiper</code> directory to your project's include path:</p> <pre><code>cp -r clients/cpp/include/viiper /path/to/your/project/include/\n</code></pre> <p>Or add it as an include directory in your build system.</p>"},{"location":"clients/cpp/#2-cmake-integration","title":"2. CMake Integration","text":"<pre><code># Add viiper include directory\ntarget_include_directories(your_target PRIVATE path/to/clients/cpp/include)\n\n# Also ensure nlohmann/json is available\n# Option A: FetchContent\ninclude(FetchContent)\nFetchContent_Declare(json\n    GIT_REPOSITORY https://github.com/nlohmann/json.git\n    GIT_TAG v3.11.3\n)\nFetchContent_MakeAvailable(json)\ntarget_link_libraries(your_target PRIVATE nlohmann_json::nlohmann_json)\n\n# Option B: Find package (if installed system-wide)\nfind_package(nlohmann_json REQUIRED)\ntarget_link_libraries(your_target PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> <p>The client library will be generated in <code>clients/cpp/include/viiper/</code>.</p>"},{"location":"clients/cpp/#json-parser-configuration","title":"JSON Parser Configuration","text":"<p>Before including the VIIPER client library, you must configure a JSON parser. The client library is designed to work with any JSON library that provides a compatible interface.</p>"},{"location":"clients/cpp/#using-nlohmannjson-recommended","title":"Using nlohmann/json (Recommended)","text":"<pre><code>// Define these BEFORE including viiper headers\n#define VIIPER_JSON_INCLUDE &lt;nlohmann/json.hpp&gt;\n#define VIIPER_JSON_NAMESPACE nlohmann\n#define VIIPER_JSON_TYPE json\n\n#include &lt;viiper/viiper.hpp&gt;\n</code></pre>"},{"location":"clients/cpp/#using-a-custom-json-library","title":"Using a Custom JSON Library","text":"<p>Your JSON type must support:</p> <ul> <li><code>parse(const std::string&amp;)</code> \u2192 JsonType</li> <li><code>dump()</code> \u2192 std::string</li> <li><code>operator[](const std::string&amp;)</code> \u2192 JsonType</li> <li><code>contains(const std::string&amp;)</code> \u2192 bool</li> <li><code>is_number()</code>, <code>is_string()</code>, <code>is_array()</code>, <code>is_object()</code> \u2192 bool</li> <li><code>get&lt;T&gt;()</code> \u2192 T</li> <li><code>size()</code> \u2192 std::size_t (for arrays)</li> </ul> <p>Example with a custom library:</p> <pre><code>#define VIIPER_JSON_INCLUDE \"my_json_lib.hpp\"\n#define VIIPER_JSON_NAMESPACE myjson\n#define VIIPER_JSON_TYPE JsonValue\n\n#include &lt;viiper/viiper.hpp&gt;\n</code></pre>"},{"location":"clients/cpp/#example","title":"Example","text":"<pre><code>#define VIIPER_JSON_INCLUDE &lt;nlohmann/json.hpp&gt;\n#define VIIPER_JSON_NAMESPACE nlohmann\n#define VIIPER_JSON_TYPE json\n\n#include &lt;viiper/viiper.hpp&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Create new Viiper client\n    viiper::ViiperClient client(\"localhost\", 3242);\n\n    // Find or create a bus\n    auto buses_result = client.buslist();\n    if (buses_result.is_error()) {\n        std::cerr &lt;&lt; \"BusList error: \" &lt;&lt; buses_result.error().to_string() &lt;&lt; \"\\n\";\n        return 1;\n    }\n\n    std::uint32_t bus_id;\n    if (buses_result.value().buses.empty()) {\n        auto create_result = client.buscreate(std::nullopt);  // Auto-assign ID\n        if (create_result.is_error()) {\n            std::cerr &lt;&lt; \"BusCreate error: \" &lt;&lt; create_result.error().to_string() &lt;&lt; \"\\n\";\n            return 1;\n        }\n        bus_id = create_result.value().busid;\n    } else {\n        bus_id = buses_result.value().buses[0];\n    }\n\n    // Add device\n    auto device_result = client.busdeviceadd(bus_id, {.type = \"keyboard\"});\n    if (device_result.is_error()) {\n        std::cerr &lt;&lt; \"AddDevice error: \" &lt;&lt; device_result.error().to_string() &lt;&lt; \"\\n\";\n        return 1;\n    }\n    auto device_info = std::move(device_result.value());\n\n    // Connect to device stream\n    auto stream_result = client.connectDevice(device_info.busid, device_info.devid);\n    if (stream_result.is_error()) {\n        std::cerr &lt;&lt; \"Connect error: \" &lt;&lt; stream_result.error().to_string() &lt;&lt; \"\\n\";\n        return 1;\n    }\n    auto stream = std::move(stream_result.value());\n\n    std::cout &lt;&lt; \"Connected to device \" &lt;&lt; device_info.devid\n              &lt;&lt; \" on bus \" &lt;&lt; device_info.busid &lt;&lt; \"\\n\";\n\n    // Send keyboard input\n    viiper::keyboard::Input input = {\n        .modifiers = viiper::keyboard::ModLeftShift,\n        .keys = {viiper::keyboard::KeyH},\n    };\n    stream-&gt;send(input);\n\n    // Cleanup\n    client.busdeviceremove(device_info.busid, device_info.devid);\n\n    return 0;\n}\n</code></pre>"},{"location":"clients/cpp/#device-controlfeedback","title":"Device Control/Feedback","text":""},{"location":"clients/cpp/#creating-a-device-controlfeedback-stream","title":"Creating a Device + Control/Feedback Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>auto [device_info, stream] = client.addDeviceAndConnect(bus_id, {.type = \"xbox360\"}).value();\n</code></pre> <p>Or manually add and connect:</p> <pre><code>auto device_result = client.busdeviceadd(bus_id, {.type = \"keyboard\"});\nauto device_info = device_result.value();\n\nauto stream_result = client.connectDevice(device_info.busid, device_info.devid);\nauto stream = std::move(stream_result.value());\n</code></pre>"},{"location":"clients/cpp/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated structs:</p> <p>Keyboard:</p> <pre><code>viiper::keyboard::Input input = {\n    .modifiers = viiper::keyboard::ModLeftShift,\n    .keys = {viiper::keyboard::KeyH, viiper::keyboard::KeyE},\n};\nstream-&gt;send(input);\n</code></pre> <p>Mouse:</p> <pre><code>viiper::mouse::Input input = {\n    .buttons = viiper::mouse::ButtonLeft,\n    .x = 10,\n    .y = -5,\n    .wheel = 0,\n};\nstream-&gt;send(input);\n</code></pre> <p>Xbox360 Controller:</p> <pre><code>viiper::xbox360::Input input = {\n    .buttons = viiper::xbox360::ButtonA,\n    .lt = 255,           // Left trigger (0-255)\n    .rt = 0,             // Right trigger (0-255)\n    .lx = -32768,        // Left stick X (-32768 to 32767)\n    .ly = 32767,         // Left stick Y\n    .rx = 0,             // Right stick X\n    .ry = 0,             // Right stick Y\n};\nstream-&gt;send(input);\n</code></pre>"},{"location":"clients/cpp/#receiving-feedback","title":"Receiving Feedback","text":"<p>For devices that send feedback (rumble, LEDs), register a callback:</p> <p>Keyboard LEDs:</p> <pre><code>stream-&gt;on_output(viiper::keyboard::OUTPUT_SIZE, [](const std::uint8_t* data, std::size_t len) {\n    if (len &lt; viiper::keyboard::OUTPUT_SIZE) return;\n    auto result = viiper::keyboard::Output::from_bytes(data, len);\n    if (result.is_error()) return;\n\n    auto&amp; leds = result.value();\n    bool num_lock = (leds.leds &amp; viiper::keyboard::LEDNumLock) != 0;\n    bool caps_lock = (leds.leds &amp; viiper::keyboard::LEDCapsLock) != 0;\n    std::cout &lt;&lt; \"LEDs: Num=\" &lt;&lt; num_lock &lt;&lt; \" Caps=\" &lt;&lt; caps_lock &lt;&lt; \"\\n\";\n});\n</code></pre> <p>Xbox360 Rumble:</p> <pre><code>stream-&gt;on_output(viiper::xbox360::OUTPUT_SIZE, [](const std::uint8_t* data, std::size_t len) {\n    if (len &lt; viiper::xbox360::OUTPUT_SIZE) return;\n    auto result = viiper::xbox360::Output::from_bytes(data, len);\n    if (result.is_error()) return;\n\n    auto&amp; rumble = result.value();\n    std::cout &lt;&lt; \"Rumble: Left=\" &lt;&lt; static_cast&lt;int&gt;(rumble.left)\n              &lt;&lt; \", Right=\" &lt;&lt; static_cast&lt;int&gt;(rumble.right) &lt;&lt; \"\\n\";\n});\n</code></pre>"},{"location":"clients/cpp/#event-handlers","title":"Event Handlers","text":"<pre><code>// Called when the server disconnects the device\nstream-&gt;on_disconnect([]() {\n    std::cerr &lt;&lt; \"Device disconnected by server\\n\";\n});\n\n// Called on stream errors\nstream-&gt;on_error([](const viiper::Error&amp; err) {\n    std::cerr &lt;&lt; \"Stream error: \" &lt;&lt; err.to_string() &lt;&lt; \"\\n\";\n});\n</code></pre>"},{"location":"clients/cpp/#stopping-a-device","title":"Stopping a Device","text":"<pre><code>stream-&gt;stop();  // Stops the output thread and closes the connection\n</code></pre> <p>The device is also automatically stopped when the <code>ViiperDevice</code> is destroyed. The VIIPER server automatically removes the device when the stream is closed after a short timeout.</p>"},{"location":"clients/cpp/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The C++ client library automatically generates constants and helper maps for each device type.</p>"},{"location":"clients/cpp/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Codes:</p> <pre><code>auto key = viiper::keyboard::KeyA;           // 0x04\nauto f1 = viiper::keyboard::KeyF1;           // 0x3A\nauto enter = viiper::keyboard::KeyEnter;     // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>std::uint8_t mods = viiper::keyboard::ModLeftShift | viiper::keyboard::ModLeftCtrl;\n</code></pre> <p>LED Flags:</p> <pre><code>bool num_lock = (leds &amp; viiper::keyboard::LEDNumLock) != 0;\nbool caps_lock = (leds &amp; viiper::keyboard::LEDCapsLock) != 0;\n</code></pre>"},{"location":"clients/cpp/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CHAR_TO_KEY Map - Convert ASCII characters to key codes:</p> <pre><code>auto it = viiper::keyboard::CHAR_TO_KEY.find(static_cast&lt;std::uint8_t&gt;('a'));\nif (it != viiper::keyboard::CHAR_TO_KEY.end()) {\n    std::uint8_t key = it-&gt;second;  // KeyA\n}\n</code></pre> <p>KEY_NAME Array - Get human-readable key names:</p> <pre><code>for (const auto&amp; [key, name] : viiper::keyboard::KEY_NAME) {\n    if (key == viiper::keyboard::KeyF1) {\n        std::cout &lt;&lt; \"Key name: \" &lt;&lt; name &lt;&lt; \"\\n\";  // \"F1\"\n        break;\n    }\n}\n</code></pre> <p>SHIFT_CHARS Set - Check if a character requires shift:</p> <pre><code>bool needs_shift = viiper::keyboard::SHIFT_CHARS.contains(static_cast&lt;std::uint8_t&gt;('A'));\n</code></pre>"},{"location":"clients/cpp/#xbox360-constants","title":"Xbox360 Constants","text":"<p>Button Flags:</p> <pre><code>std::uint16_t buttons = viiper::xbox360::ButtonA | viiper::xbox360::ButtonB;\n</code></pre>"},{"location":"clients/cpp/#error-handling","title":"Error Handling","text":"<p>All API methods return <code>Result&lt;T&gt;</code>, which is either a value or an error:</p> <pre><code>auto result = client.buslist();\nif (result.is_error()) {\n    std::cerr &lt;&lt; \"Error: \" &lt;&lt; result.error().to_string() &lt;&lt; \"\\n\";\n    return 1;\n}\nauto buses = result.value();\n</code></pre> <p>Using the value directly (throws on error):</p> <pre><code>// Only use if you're certain the operation succeeded\nauto buses = client.buslist().value();\n</code></pre>"},{"location":"clients/cpp/#resource-management","title":"Resource Management","text":"<p><code>ViiperDevice</code> is managed via <code>std::unique_ptr</code> and automatically cleans up:</p> <pre><code>{\n    auto stream = client.connectDevice(bus_id, device_id).value();\n    // ... use stream ...\n}  // stream-&gt;stop() called automatically\n</code></pre>"},{"location":"clients/cpp/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/cpp/virtual_keyboard.cpp</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/cpp/virtual_mouse.cpp</code></p> </li> <li>Moves cursor in a circle pattern</li> <li> <p>Demonstrates button clicks</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/cpp/virtual_x360_pad.cpp</code></p> </li> <li>Cycles through buttons A, B, X, Y</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/cpp/#building-examples","title":"Building Examples","text":"<pre><code>cd examples/cpp\nmkdir build &amp;&amp; cd build\ncmake .. -DCMAKE_BUILD_TYPE=Release\ncmake --build . --config Release\n</code></pre>"},{"location":"clients/cpp/#running-examples","title":"Running Examples","text":"<pre><code>./virtual_keyboard localhost:3242\n./virtual_mouse localhost:3242\n./virtual_x360_pad localhost:3242\n</code></pre>"},{"location":"clients/cpp/#troubleshooting","title":"Troubleshooting","text":"<p>Error: VIIPER_JSON_INCLUDE must be defined</p> <p>You must define the JSON macros before including any VIIPER headers:</p> <pre><code>#define VIIPER_JSON_INCLUDE &lt;nlohmann/json.hpp&gt;\n#define VIIPER_JSON_NAMESPACE nlohmann\n#define VIIPER_JSON_TYPE json\n\n#include &lt;viiper/viiper.hpp&gt;  // Include AFTER the defines\n</code></pre> <p>Linker errors on Windows</p> <p>Ensure Winsock2 is linked. If not using the auto-link pragma, add:</p> <pre><code>target_link_libraries(your_target PRIVATE Ws2_32)\n</code></pre> <p>Connection refused</p> <p>Verify the VIIPER server is running:</p> <pre><code>viiper server --api-addr localhost:3242\n</code></pre>"},{"location":"clients/cpp/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>C Client Library Documentation: Pure C alternative</li> <li>Rust Client Library Documentation: Rust client library with sync/async support</li> <li>C# Client Library Documentation: .NET client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul>"},{"location":"clients/csharp/","title":"C# Client Library Documentation","text":"<p>The VIIPER C# client library provides a modern, type-safe .NET client library for interacting with VIIPER servers and controlling virtual devices.</p> <p>The C# client library features:</p> <ul> <li>Async/await support: Full async API with cancellation token support</li> <li>Type-safe: Generated classes with enums, structs, and helper maps</li> <li>Event-driven: <code>OnOutput</code> event for device feedback (LEDs, rumble)</li> <li>Modern .NET: Targets .NET 8.0 with nullable reference types</li> <li>Zero external dependencies: Uses only built-in .NET libraries</li> </ul> <p>License</p> <p>The C# client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/csharp/#installation","title":"Installation","text":""},{"location":"clients/csharp/#1-using-the-published-nuget-package-recommended","title":"1. Using the Published NuGet Package (Recommended)","text":"<p>Install the stable package:</p> <pre><code>dotnet add package Viiper.Client\n</code></pre> <p>Package page: Viiper.Client on NuGet</p> <p>Pre-Releases</p> <p>Pre-release / snapshot builds are not published to NuGet. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p> <p>To use a snapshot <code>.nupkg</code> from a GitHub Release:</p> <pre><code># 1. Download viiper-csharp-sdk-nupkg-Release.nupkg (or Snapshot) to ./packages\nmkdir -p packages\ncp /path/to/downloaded/viiper-csharp-sdk-nupkg.nupkg packages/\n\n# 2. Add a temporary local source and install\ndotnet nuget add source ./packages --name viiper-local || true\ndotnet add package Viiper.Client --source viiper-local\n</code></pre> <p>Or add directly in your <code>.csproj</code> (stable only):</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"Viiper.Client\" Version=\"*\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#2-project-reference-for-local-development-against-source","title":"2. Project Reference (For Local Development Against Source)","text":"<p>Use this when modifying the generator or contributing new device types:</p> <pre><code>&lt;ItemGroup&gt;\n    &lt;ProjectReference Include=\"..\\..\\clients\\csharp\\Viiper.Client\\Viiper.Client.csproj\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#example","title":"Example","text":"<pre><code>using Viiper.Client;\nusing Viiper.Client.Devices.Keyboard;\n\n// Create new Viiper client\nvar client = new ViiperClient(\"localhost\", 3242);\n\n// Find or create a bus\nvar buses = await client.BusListAsync();\nuint busId;\nif (buses.Buses.Length == 0)\n{\n    var resp = await client.BusCreateAsync(null); // null = auto-assign ID\n    // Or specify ID: await client.BusCreateAsync(5);\n    busId = resp.BusID;\n}\nelse\n{\n    busId = buses.Buses[0];\n}\n\n// Add device and connect\nvar deviceReq = new DeviceCreateRequest { Type = \"keyboard\" };\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n\nConsole.WriteLine($\"Connected to device {deviceResp.BusID}-{deviceResp.DevId}\");\n\n// Send keyboard input\nvar input = new KeyboardInput\n{\n    Modifiers = (byte)Mod.LeftShift,\n    Count = 1,\n    Keys = new[] { (byte)Key.H }\n};\nawait device.SendAsync(input);\n\n// Cleanup\nawait client.BusDeviceRemoveAsync(busId, deviceResp.DevId);\n</code></pre>"},{"location":"clients/csharp/#device-controlfeedback","title":"Device Control/Feedback","text":""},{"location":"clients/csharp/#creating-a-device-controlfeedback-stream","title":"Creating a Device + Control/Feedback Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>var deviceReq = new DeviceCreateRequest { Type = \"xbox360\" };\nvar deviceResp = await client.BusDeviceAddAsync(busId, deviceReq);\nvar device = await client.ConnectDeviceAsync(busId, deviceResp.DevId);\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>var device = await client.ConnectDeviceAsync(busId, deviceId);\n</code></pre>"},{"location":"clients/csharp/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated structs with async methods:</p> <pre><code>using Viiper.Client.Devices.Xbox360;\n\nvar input = new Xbox360Input\n{\n    Buttons = (uint)Button.A,\n    LeftTrigger = 255,\n    RightTrigger = 0,\n    ThumbLX = -32768,  // Left stick left\n    ThumbLY = 32767,   // Left stick up\n    ThumbRX = 0,\n    ThumbRY = 0\n};\nawait device.SendAsync(input);\n</code></pre>"},{"location":"clients/csharp/#receiving-feedback","title":"Receiving Feedback","text":"<p>For devices that send feedback (rumble, LEDs), subscribe to the <code>OnOutput</code> event:</p> <pre><code>using Viiper.Client.Devices.Keyboard;\n\ndevice.OnOutput += data =&gt;\n{\n    if (data.Length &lt; 1) return;\n    byte leds = data[0];\n\n    Console.WriteLine($\"LEDs: \" +\n        $\"Num={(leds &amp; (byte)LED.NumLock) != 0} \" +\n        $\"Caps={(leds &amp; (byte)LED.CapsLock) != 0} \" +\n        $\"Scroll={(leds &amp; (byte)LED.ScrollLock) != 0}\");\n};\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>using Viiper.Client.Devices.Xbox360;\n\ndevice.OnOutput += data =&gt;\n{\n    if (data.Length &lt; 2) return;\n    byte leftMotor = data[0];\n    byte rightMotor = data[1];\n    Console.WriteLine($\"Rumble: Left={leftMotor} Right={rightMotor}\");\n};\n</code></pre>"},{"location":"clients/csharp/#closing-a-device","title":"Closing a Device","text":"<pre><code>device.Dispose();\n// or\nawait using var device = await client.ConnectDeviceAsync(busId, deviceId);\n</code></pre> <p>The VIIPER server automatically removes the device when the stream is closed after a short timeout.</p>"},{"location":"clients/csharp/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The C# client library automatically generates enums and helper maps for each device type.</p>"},{"location":"clients/csharp/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Enum:</p> <pre><code>using Viiper.Client.Devices.Keyboard;\n\nvar key = Key.A;               // 0x04\nvar f1 = Key.F1;               // 0x3A\nvar enter = Key.Enter;         // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>var mods = (byte)(Mod.LeftShift | Mod.LeftCtrl);  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>bool numLock = (leds &amp; (byte)LED.NumLock) != 0;\nbool capsLock = (leds &amp; (byte)LED.CapsLock) != 0;\n</code></pre>"},{"location":"clients/csharp/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CharToKey Map - Convert ASCII characters to key codes:</p> <pre><code>if (CharToKey.TryGetValue((byte)'A', out var key))\n{\n    Console.WriteLine($\"'A' maps to {key}\");  // Key.A\n}\n</code></pre> <p>KeyName Map - Get human-readable key names:</p> <pre><code>if (KeyName.TryGetValue((byte)Key.F1, out var name))\n{\n    Console.WriteLine($\"Key name: {name}\");  // \"F1\"\n}\n</code></pre> <p>ShiftChars Map - Check if a character requires shift:</p> <pre><code>bool needsShift = ShiftChars.ContainsKey((byte)'A');  // true for uppercase\n</code></pre>"},{"location":"clients/csharp/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/csharp/#custom-timeouts","title":"Custom Timeouts","text":"<pre><code>var client = new ViiperClient(\"localhost\", 3242)\n{\n    Timeout = TimeSpan.FromSeconds(10)\n};\n</code></pre> <p>Default timeout is 5 seconds.</p>"},{"location":"clients/csharp/#cancellation-tokens","title":"Cancellation Tokens","text":"<p>All async methods support cancellation:</p> <pre><code>using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));\n\ntry\n{\n    var buses = await client.BusListAsync(cts.Token);\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Request timed out\");\n}\n</code></pre>"},{"location":"clients/csharp/#error-handling","title":"Error Handling","text":"<p>The server returns errors as JSON. The client throws exceptions:</p> <pre><code>try\n{\n    await client.BusCreateAsync(\"invalid-bus-id\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Request failed: {ex.Message}\");\n}\n</code></pre>"},{"location":"clients/csharp/#resource-management","title":"Resource Management","text":"<p><code>ViiperDevice</code> implements <code>IDisposable</code>:</p> <pre><code>await using var device = await client.ConnectDeviceAsync(busId, deviceId);\n// Device automatically closed when scope exits\n</code></pre> <p>Or manual cleanup:</p> <pre><code>try\n{\n    var device = await client.ConnectDeviceAsync(busId, deviceId);\n    // ... use device ...\n}\nfinally\n{\n    device.Dispose();\n}\n</code></pre>"},{"location":"clients/csharp/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/csharp/virtual_keyboard/Program.cs</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/csharp/virtual_mouse/Program.cs</code></p> </li> <li>Moves cursor in a circle pattern</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/csharp/virtual_x360_pad/Program.cs</code></p> </li> <li>Presses buttons and moves sticks</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/csharp/#running-examples","title":"Running Examples","text":"<pre><code>cd examples/csharp/virtual_keyboard\ndotnet run -- localhost\n</code></pre>"},{"location":"clients/csharp/#troubleshooting","title":"Troubleshooting","text":"<p>Build Errors:</p> <p>Ensure you have .NET 8.0 SDK installed:</p> <pre><code>dotnet --version  # Should be 8.0 or higher\n</code></pre> <p>Nullable Reference Warnings:</p> <p>The generated code uses nullable annotations. You may see warnings like CS8601/CS8625. These are safe to ignore or suppress in your project file:</p> <pre><code>&lt;PropertyGroup&gt;\n    &lt;NoWarn&gt;$(NoWarn);CS8601;CS8625&lt;/NoWarn&gt;\n&lt;/PropertyGroup&gt;\n</code></pre>"},{"location":"clients/csharp/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>Go Client Documentation: Reference implementation patterns</li> <li>Rust Client Library Documentation: Rust client library with sync/async support</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>C Client Library Documentation: Alternative client library for native integration</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul>"},{"location":"clients/generator/","title":"VIIPER Client Generator Documentation","text":""},{"location":"clients/generator/#overview","title":"Overview","text":"<p>The VIIPER client generator scans Go source code to extract API routes, device wire formats, and constants; then emits type-safe client libraries for multiple languages.</p> <p>What it extracts:</p> <ul> <li>API routes and DTOs from management API handlers  </li> <li>Device wire formats from <code>viiper:wire</code> comment tags  </li> <li>All exported constants from device packages (automatic)</li> </ul> <p>Output: Type-safe client libraries for multiple target languages</p> <p>License</p> <p>All generated client libraries are licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/generator/#running-the-generator","title":"Running the Generator","text":"<pre><code>go run ./cmd/viiper codegen --lang=all        # Generate all client libraries\ngo run ./cmd/viiper codegen --lang=c          # Generate C client library only\ngo run ./cmd/viiper codegen --lang=csharp     # Generate C# client library only\ngo run ./cmd/viiper codegen --lang=typescript # Generate TypeScript client library only\n</code></pre> <p>Output directory: <code>clients/</code> (relative to repository root)</p>"},{"location":"clients/generator/#comment-tag-system","title":"Comment Tag System","text":"<p>The generator uses lightweight comment tags placed next to device types and constants.</p>"},{"location":"clients/generator/#viiperwire-device-stream-formats","title":"<code>viiper:wire</code>: Device Stream Formats","text":"<p>Syntax:</p> <pre><code>// viiper:wire &lt;device&gt; &lt;direction&gt; &lt;field1:type&gt; &lt;field2:type&gt; ...\n</code></pre> <p>Directions: </p> <ul> <li><code>c2s</code>: Client to server (input)  </li> <li><code>s2c</code>: Server to client (output, e.g., rumble, LEDs)</li> </ul> <p>Field types: </p> <ul> <li>Fixed: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code> </li> <li>Variable: <code>u8*countField</code> (pointer to count field)</li> </ul> <p>Example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct { ... }\n</code></pre>"},{"location":"clients/generator/#constant-and-map-export","title":"Constant and Map Export","text":"<p>The generator automatically exports all constants and map literals from <code>/device/*/const.go</code> for each device type. No special tags are required. Exported Go constants and maps are emitted with language-appropriate representations:</p> <ul> <li>Constants: Grouped into enums (C#/TS) or <code>#define</code> macros (C) based on common prefixes</li> <li>Maps: Converted to Dictionary/Map/lookup functions with helper methods</li> </ul>"},{"location":"clients/generator/#code-generation-flow","title":"Code Generation Flow","text":"<p>Scan Phase: </p> <ol> <li>Parse API routes from <code>internal/server/api/*.go</code> </li> <li>Reflect response DTOs from <code>/apitypes/*.go</code> </li> <li>Find device types via <code>RegisterDevice()</code> calls  </li> <li>Parse <code>viiper:wire</code> comments for packet layouts  </li> <li>Extract all exported constants and map literals from <code>/device/*/const.go</code> (automatic)</li> </ol> <p>Emit Phase: For each language, generate management client, DTO types, device streams, constants, and build configs.</p> <p>Post-Process: Optional formatting with <code>clang-format</code>, <code>dotnet format</code>, or <code>prettier</code>.</p>"},{"location":"clients/generator/#wire-format-mapping-rules","title":"Wire Format Mapping Rules","text":""},{"location":"clients/generator/#fixed-size-fields","title":"Fixed-Size Fields","text":"<p>Fixed-size fields are mapped to native integer types in each target language:</p> <ul> <li><code>u8</code> / <code>i8</code>: 8-bit unsigned/signed integers</li> <li><code>u16</code> / <code>i16</code>: 16-bit unsigned/signed integers</li> <li><code>u32</code> / <code>i32</code>: 32-bit unsigned/signed integers</li> </ul>"},{"location":"clients/generator/#variable-length-fields","title":"Variable-Length Fields","text":"<p>Variable-length arrays use a pointer + count pattern. The field syntax <code>u8*count</code> references a count field that determines the array length.</p> <p>Wire tag example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\n</code></pre> <p>Each target language emits appropriate types for dynamic arrays (pointers with counts, managed arrays, or typed arrays depending on the language).</p>"},{"location":"clients/generator/#struct-packing","title":"Struct Packing","text":"<p>For wire compatibility, all device I/O structs are tightly packed (no padding).</p> <ul> <li>C: <code>#pragma pack(push, 1)</code> / <code>#pragma pack(pop)</code></li> <li>C#: <code>[StructLayout(LayoutKind.Sequential, Pack = 1)]</code></li> <li>TypeScript: Manual byte-level encoding/decoding</li> </ul>"},{"location":"clients/generator/#example-keyboard-input-variable-length","title":"Example: Keyboard Input (Variable-Length)","text":"<p>Go source with wire tag:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct {\n    Modifiers uint8\n    KeyBitmap [32]uint8  // Internal: 256-bit NKR bitmap\n}\n</code></pre> <p>Emitted C struct:</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t modifiers;\n    uint8_t count;\n    uint8_t* keys;\n    size_t keys_count;\n} viiper_keyboard_input_t;\n#pragma pack(pop)\n</code></pre>"},{"location":"clients/generator/#example-constant-and-map-export","title":"Example: Constant and Map Export","text":"<p>Go source (<code>/device/keyboard/const.go</code>):</p> <pre><code>const (\n    ModLeftCtrl  = 0x01\n    ModLeftShift = 0x02\n    KeyA = 0x04\n    KeyB = 0x05\n    // ...\n)\n\nvar CharToKey = map[byte]byte{\n    'a': KeyA,\n    'b': KeyB,\n    '\\n': KeyEnter,\n    // ...\n}\n</code></pre> <p>Emitted C header (<code>viiper_keyboard.h</code>):</p> <pre><code>#define VIIPER_KEYBOARD_MOD_LEFT_CTRL 0x1\n#define VIIPER_KEYBOARD_MOD_LEFT_SHIFT 0x2\n#define VIIPER_KEYBOARD_KEY_A 0x4\n#define VIIPER_KEYBOARD_KEY_B 0x5\n\n// Map lookup function\nint viiper_keyboard_char_to_key_lookup(uint8_t key, uint8_t* out_value);\n</code></pre> <p>Emitted C# (<code>KeyboardConstants.cs</code>):</p> <pre><code>public enum Mod : uint\n{\n    LeftCtrl = 0x01,\n    LeftShift = 0x02,\n    // ...\n}\n\npublic enum Key : uint\n{\n    A = 0x04,\n    B = 0x05,\n    // ...\n}\n\npublic static class CharToKey\n{\n    private static readonly Dictionary&lt;byte, Key&gt; _map = new()\n    {\n        { (byte)'a', Key.A },\n        { (byte)'b', Key.B },\n        { (byte)'\\n', Key.Enter },\n        // ...\n    };\n\n    public static bool TryGetValue(byte key, out Key value)\n    {\n        return _map.TryGetValue(key, out value);\n    }\n}\n</code></pre>"},{"location":"clients/generator/#regeneration-triggers","title":"Regeneration Triggers","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>/apitypes/*.go</code>: API response structures</li> <li><code>/device/*/inputstate.go</code>: Wire tag annotations</li> <li><code>/device/*/const.go</code>: Exported constants and map literals</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li><code>internal/codegen/generator/**/*.go</code>: Generator templates</li> <li><code>internal/codegen/scanner/**/*.go</code>: Scanner logic (constants, maps, wire tags)</li> </ul>"},{"location":"clients/generator/#language-specific-notes","title":"Language-Specific Notes","text":"<ul> <li>C: <code>#define</code> macros for constants; switch-based lookup functions for maps; manual memory management for variable-length fields; builds with CMake.  </li> <li>C#: Enums for constant groups; <code>Dictionary&lt;K,V&gt;</code> with static helper methods for maps; <code>ViiperDevice</code> class with <code>OnOutput</code> event; async/await for management API; struct packing via attributes.  </li> <li>TypeScript: Enums for constant groups; <code>Record&lt;K, V&gt;</code> objects with <code>Get</code>/<code>Has</code> helper functions for maps; manual byte encoding via <code>BinaryWriter</code>/<code>BinaryReader</code>; <code>ViiperDevice</code> class with EventEmitter for output; <code>addDeviceAndConnect</code> convenience method; builds with <code>tsc</code>.  </li> </ul>"},{"location":"clients/generator/#further-reading","title":"Further Reading","text":"<ul> <li>Go Client Documentation: Go reference client usage</li> <li>C Client Library Documentation: C-specific usage, build, and examples</li> <li>C# Client Library Documentation: C#-specific usage, async patterns, and map helpers</li> <li>TypeScript Client Library Documentation: TypeScript-specific usage, EventEmitter patterns, and examples</li> </ul>"},{"location":"clients/go/","title":"Go Client Documentation","text":"<p>The Go client is the reference implementation for interacting with the VIIPER TCP API. It's included in the repository under <code>/apiclient</code> (and <code>/device</code>).</p> <p>The Go client features:</p> <ul> <li>Type-safe API: Structured request/response types with context support</li> <li>Device Control/Feedback: Bidirectional binary communication</li> <li>Built-in: No code generation needed; part of the main repository</li> <li>Flexible timeouts: Configurable connection and I/O timeouts</li> </ul>"},{"location":"clients/go/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n  \"context\"\n  \"log\"\n  \"time\"\n\n  apiclient \"github.com/Alia5/VIIPER/apiclient\"\n  \"github.com/Alia5/VIIPER/device\"\n  \"github.com/Alia5/VIIPER/device/keyboard\"\n)\n\nfunc main() {\n  // Create new Viiper client\n  client := apiclient.New(\"127.0.0.1:3242\")\n  ctx := context.Background()\n\n  // Create or find a bus\n  buses, err := client.BusList()\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  var busID uint32\n  if len(buses) &gt; 0 {\n    busID = buses[0]\n  } else {\n    resp, err := client.BusCreate(nil)\n    if err != nil {\n      log.Fatal(err)\n    }\n    busID = resp.BusID\n  }\n\n  // Add device and connect (optional CreateOptions parameter for VID/PID)\n  // Pass nil to use default VID/PID for the device type.\n  stream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"keyboard\", nil)\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer stream.Close()\n\n  log.Printf(\"Connected to device %s\", resp.ID)\n\n  // Send keyboard input\n  input := &amp;keyboard.InputState{\n    Modifiers: keyboard.ModLeftShift,\n  }\n  input.SetKey(keyboard.KeyH, true)\n\n  if err := stream.WriteBinary(input); err != nil {\n    log.Fatal(err)\n  }\n\n  time.Sleep(100 * time.Millisecond)\n\n  // Release\n  input = &amp;keyboard.InputState{}\n  stream.WriteBinary(input)\n}\n</code></pre>"},{"location":"clients/go/#device-controlfeedback-api","title":"Device Control/Feedback API","text":""},{"location":"clients/go/#creating-and-connecting","title":"Creating and Connecting","text":"<p>The simplest way to add a device and open its control stream (nil opts):</p> <pre><code>// Use default VID/PID for the device type\nstream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"xbox360\", nil)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream.Close()\n\nlog.Printf(\"Connected to device %s\", resp.ID)\n</code></pre>"},{"location":"clients/go/#sending-input","title":"Sending Input","text":"<p>Device input is sent using structs that implement <code>encoding.BinaryMarshaler</code>. Every device package (e.g. <code>device/xbox360</code>) provides type-safe input state structs.  </p> <pre><code>import \"github.com/Alia5/VIIPER/device/xbox360\"\n\ninput := &amp;xbox360.InputState{\n  Buttons: xbox360.ButtonA,\n  LX:      -32768, // Left stick left\n  LY:      32767,  // Left stick up\n}\nif err := stream.WriteBinary(input); err != nil {\n  log.Fatal(err)\n}\n</code></pre>"},{"location":"clients/go/#receiving-feedback","title":"Receiving Feedback","text":"<p>For devices that send feedback (rumble, LEDs), use <code>StartReading</code> with a decode function:</p> <pre><code>import (\n  \"bufio\"\n  \"encoding\"\n  \"io\"\n  \"github.com/Alia5/VIIPER/device/xbox360\"\n)\n\n// Start async reading for rumble commands\nrumbleCh, errCh := stream.StartReading(ctx, 10, func(r *bufio.Reader) (encoding.BinaryUnmarshaler, error) {\n  var b [2]byte\n  if _, err := io.ReadFull(r, b[:]); err != nil { return nil, err }\n  msg := new(xbox360.XRumbleState)\n  if err := msg.UnmarshalBinary(b[:]); err != nil { return nil, err }\n  return msg, nil\n})\n\ngo func() {\n  for {\n    select {\n    case msg := &lt;-rumbleCh:\n      rumble := msg.(*xbox360.XRumbleState)\n      fmt.Printf(\"Rumble: Left=%d Right=%d\\n\", rumble.LeftMotor, rumble.RightMotor)\n    case err := &lt;-errCh:\n      if err != nil { log.Printf(\"Stream error: %v\", err) }\n      return\n    }\n  }\n}()\n</code></pre>"},{"location":"clients/go/#closing-a-stream-removing-a-device","title":"Closing a Stream / Removing a Device","text":"<pre><code>stream.Close()\n</code></pre> <p>The VIIPER server automatically removes the device when the stream is closed after a short timeout.</p>"},{"location":"clients/go/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific wire formats and helper methods. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The Go client provides device packages under <code>/device/</code> with type-safe structs and constants (e.g., <code>keyboard.InputState</code>, <code>keyboard.KeyA</code>, <code>mouse.Btn_Left</code>).</p>"},{"location":"clients/go/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/go/#custom-timeouts","title":"Custom Timeouts","text":"<pre><code>cfg := &amp;apiclient.Config{\n  DialTimeout:  2 * time.Second,\n  ReadTimeout:  3 * time.Second,\n  WriteTimeout: 3 * time.Second,\n}\nclient := apiclient.NewWithConfig(\"127.0.0.1:3242\", cfg)\n</code></pre> <p>Default timeouts are: Dial 3s, Read/Write 5s.</p>"},{"location":"clients/go/#context-aware-calls","title":"Context-Aware Calls","text":"<p>All methods have context-aware variants ending with <code>Ctx</code>:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\nbuses, err := client.BusListCtx(ctx)\n</code></pre>"},{"location":"clients/go/#error-handling","title":"Error Handling","text":"<p>The server returns errors as <code>{ \"error\": \"message\" }</code> JSON. The client wraps these as Go errors:</p> <pre><code>if err != nil {\n  log.Printf(\"request failed: %v\", err)\n}\n</code></pre>"},{"location":"clients/go/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Mouse: <code>examples/go/virtual_mouse/main.go</code></li> <li>Virtual Keyboard: <code>examples/go/virtual_keyboard/main.go</code></li> <li>Virtual Xbox360 Controller: <code>examples/go/virtual_x360_pad/main.go</code></li> <li>More examples are always being added!</li> </ul>"},{"location":"clients/go/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>C Client Library Documentation: Generated C client library usage</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>C# Client Library Documentation: .NET client library</li> <li>Rust Client Library Documentation: Rust client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"clients/rust/","title":"Rust Client Library Documentation","text":"<p>The VIIPER Rust client library provides a type-safe, zero-cost abstraction client library for interacting with VIIPER servers and controlling virtual devices.</p> <p>The Rust client library features:</p> <ul> <li>Sync and Async APIs: Choose between blocking <code>ViiperClient</code> or async <code>AsyncViiperClient</code> (with <code>async</code> feature)</li> <li>Type-safe: Generated structs with constants, helper maps, and <code>DeviceInput</code> trait implementations</li> <li>Callback-based output: Register closures for device feedback (LEDs, rumble)</li> <li>Zero external dependencies (sync): Uses only <code>std</code> for the synchronous client</li> <li>Tokio-based async: Optional <code>async</code> feature for async/await support with Tokio runtime</li> </ul> <p>License</p> <p>The Rust client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/rust/#installation","title":"Installation","text":""},{"location":"clients/rust/#1-using-the-published-crate-recommended","title":"1. Using the Published Crate (Recommended)","text":"<p>Install the client library using Cargo:</p> <pre><code>cargo add viiper-client\n</code></pre> <p>For async support:</p> <pre><code>cargo add viiper-client --features async\ncargo add tokio --features full\n</code></pre> <p>Package page: viiper-client on crates.io</p> <p>Pre-release / snapshot builds are not published to crates.io. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p>"},{"location":"clients/rust/#2-path-dependency-for-local-development-against-source","title":"2. Path Dependency (For Local Development Against Source)","text":"<p>Use this when modifying the generator or contributing new device types:</p> <pre><code>[dependencies]\nviiper-client = { path = \"../../clients/rust\" }\n</code></pre>"},{"location":"clients/rust/#example","title":"Example","text":"SyncAsync <pre><code>use viiper_client::{ViiperClient, devices::keyboard::*};\nuse std::net::ToSocketAddrs;\n\nfn main() {\n    // Create new Viiper client\n    let addr = \"localhost:3242\"\n        .to_socket_addrs()\n        .expect(\"Invalid address\")\n        .next()\n        .expect(\"No address resolved\");\n    let client = ViiperClient::new(addr);\n\n    // Find or create a bus\n    let bus_id = match client.bus_list() {\n        Ok(resp) if resp.buses.is_empty() =&gt; {\n            client.bus_create(None).expect(\"Failed to create bus\").bus_id\n        }\n        Ok(resp) =&gt; *resp.buses.first().unwrap(),\n        Err(e) =&gt; panic!(\"BusList error: {}\", e),\n    };\n\n    // Add device\n    let device_info = client.bus_device_add(\n        bus_id,\n        &amp;viiper_client::types::DeviceCreateRequest {\n            r#type: Some(\"keyboard\".to_string()),\n            id_vendor: None,\n            id_product: None,\n        },\n    ).expect(\"Failed to add device\");\n\n    // Connect to device stream\n    let mut stream = client\n        .connect_device(device_info.bus_id, &amp;device_info.dev_id)\n        .expect(\"Failed to connect\");\n\n    println!(\"Connected to device {} on bus {}\", device_info.dev_id, device_info.bus_id);\n\n    // Send keyboard input\n    let input = KeyboardInput {\n        modifiers: MOD_LEFT_SHIFT,\n        count: 1,\n        keys: vec![KEY_H],\n    };\n    stream.send(&amp;input).expect(\"Failed to send input\");\n\n    // Cleanup\n    let _ = client.bus_device_remove(device_info.bus_id, Some(&amp;device_info.dev_id));\n}\n</code></pre> <pre><code>use tokio::time::{sleep, Duration};\nuse viiper_client::{AsyncViiperClient, devices::keyboard::*};\nuse std::net::ToSocketAddrs;\n\n#[tokio::main]\nasync fn main() {\n    // Create new Viiper client\n    let addr = \"localhost:3242\"\n        .to_socket_addrs()\n        .expect(\"Invalid address\")\n        .next()\n        .expect(\"No address resolved\");\n    let client = AsyncViiperClient::new(addr);\n\n    // Find or create a bus\n    let bus_id = match client.bus_list().await {\n        Ok(resp) if resp.buses.is_empty() =&gt; {\n            client.bus_create(None).await.expect(\"Failed to create bus\").bus_id\n        }\n        Ok(resp) =&gt; *resp.buses.first().unwrap(),\n        Err(e) =&gt; panic!(\"BusList error: {}\", e),\n    };\n\n    // Add device\n    let device_info = client.bus_device_add(\n        bus_id,\n        &amp;viiper_client::types::DeviceCreateRequest {\n            r#type: Some(\"keyboard\".to_string()),\n            id_vendor: None,\n            id_product: None,\n        },\n    ).await.expect(\"Failed to add device\");\n\n    // Connect to device stream\n    let mut stream = client\n        .connect_device(device_info.bus_id, &amp;device_info.dev_id)\n        .await\n        .expect(\"Failed to connect\");\n\n    println!(\"Connected to device {} on bus {}\", device_info.dev_id, device_info.bus_id);\n\n    // Send keyboard input\n    let input = KeyboardInput {\n        modifiers: MOD_LEFT_SHIFT,\n        count: 1,\n        keys: vec![KEY_H],\n    };\n    stream.send(&amp;input).await.expect(\"Failed to send input\");\n\n    // Cleanup\n    let _ = client.bus_device_remove(device_info.bus_id, Some(&amp;device_info.dev_id)).await;\n}\n</code></pre>"},{"location":"clients/rust/#device-controlfeedback","title":"Device Control/Feedback","text":""},{"location":"clients/rust/#creating-a-device-controlfeedback-stream","title":"Creating a Device + Control/Feedback Stream","text":"Sync <pre><code>use viiper_client::{ViiperClient, types::DeviceCreateRequest};\nuse std::net::ToSocketAddrs;\n\nlet addr = \"localhost:3242\"\n    .to_socket_addrs()\n    .expect(\"Invalid address\")\n    .next()\n    .expect(\"No address resolved\");\nlet client = ViiperClient::new(addr);\n\n// Add device first\nlet device_info = client.bus_device_add(\n    bus_id,\n    &amp;DeviceCreateRequest {\n        r#type: Some(\"xbox360\".to_string()),\n        id_vendor: None,\n        id_product: None,\n    },\n).expect(\"Failed to add device\");\n\n// Then connect to its stream\nlet mut stream = client\n    .connect_device(device_info.bus_id, &amp;device_info.dev_id)\n    .expect(\"Failed to connect\");\n</code></pre>"},{"location":"clients/rust/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated structs that implement the <code>DeviceInput</code> trait:</p> <pre><code>use viiper_client::devices::xbox360::*;\n\nlet input = Xbox360Input {\n    buttons: BUTTON_A as u32,\n    lt: 255,\n    rt: 0,\n    lx: -32768,  // Left stick left\n    ly: 32767,   // Left stick up\n    rx: 0,\n    ry: 0,\n};\nstream.send(&amp;input).expect(\"Failed to send\");\n</code></pre>"},{"location":"clients/rust/#receiving-feedback","title":"Receiving Feedback","text":"<p>For devices that send feedback (rumble, LEDs), register a callback with <code>on_output</code>:</p> SyncAsync <pre><code>use viiper_client::devices::keyboard::OUTPUT_SIZE;\n\nstream.on_output(|reader| {\n    let mut buf = [0u8; OUTPUT_SIZE];\n    reader.read_exact(&amp;mut buf)?;\n    let leds = buf[0];\n\n    let num_lock = (leds &amp; 0x01) != 0;\n    let caps_lock = (leds &amp; 0x02) != 0;\n    let scroll_lock = (leds &amp; 0x04) != 0;\n\n    println!(\"LEDs: Num={} Caps={} Scroll={}\", num_lock, caps_lock, scroll_lock);\n    Ok(())\n}).expect(\"Failed to register callback\");\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>stream.on_output(|reader| {\n    let mut buf = [0u8; 2];\n    reader.read_exact(&amp;mut buf)?;\n    let left_motor = buf[0];\n    let right_motor = buf[1];\n    println!(\"Rumble: Left={} Right={}\", left_motor, right_motor);\n    Ok(())\n}).expect(\"Failed to register callback\");\n</code></pre> <pre><code>use tokio::io::AsyncReadExt;\nuse viiper_client::devices::keyboard::OUTPUT_SIZE;\n\nstream.on_output(|stream| async move {\n    let mut buf = [0u8; OUTPUT_SIZE];\n    let mut guard = stream.lock().await;\n    guard.read_exact(&amp;mut buf).await?;\n    drop(guard);\n\n    let leds = buf[0];\n    let num_lock = (leds &amp; 0x01) != 0;\n    let caps_lock = (leds &amp; 0x02) != 0;\n\n    println!(\"LEDs: Num={} Caps={}\", num_lock, caps_lock);\n    Ok(())\n}).expect(\"Failed to register callback\");\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>stream.on_output(|reader| async move {\n    let mut buf = [0u8; 2];\n    reader.read_exact(&amp;mut buf)?;\n    let left_motor = buf[0];\n    let right_motor = buf[1];\n    println!(\"Rumble: Left={} Right={}\", left_motor, right_motor);\n    Ok(())\n}).expect(\"Failed to register callback\");\n</code></pre>"},{"location":"clients/rust/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The Rust client library generates constants and lazy-static maps for each device type.</p>"},{"location":"clients/rust/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Constants:</p> <pre><code>use viiper_client::devices::keyboard::*;\n\nlet key = KEY_A;           // 0x04\nlet f1 = KEY_F1;           // 0x3A\nlet enter = KEY_ENTER;     // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>use viiper_client::devices::keyboard::*;\n\nlet mods = MOD_LEFT_SHIFT | MOD_LEFT_CTRL;  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>use viiper_client::devices::keyboard::*;\n\nlet num_lock = (leds &amp; LED_NUM_LOCK) != 0;\nlet caps_lock = (leds &amp; LED_CAPS_LOCK) != 0;\n</code></pre>"},{"location":"clients/rust/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CHAR_TO_KEY - Convert ASCII characters to key codes:</p> <pre><code>use viiper_client::devices::keyboard::CHAR_TO_KEY;\n\nif let Some(&amp;key) = CHAR_TO_KEY.get(&amp;b'a') {\n    println!(\"'a' maps to key code {}\", key);  // KEY_A\n}\n</code></pre> <p>KEY_NAME - Get human-readable key names:</p> <pre><code>use viiper_client::devices::keyboard::KEY_NAME;\n\nif let Some(name) = KEY_NAME.get(&amp;KEY_F1) {\n    println!(\"Key name: {}\", name);  // \"F1\"\n}\n</code></pre> <p>SHIFT_CHARS - Check if a character requires shift:</p> <pre><code>use viiper_client::devices::keyboard::SHIFT_CHARS;\n\nlet needs_shift = SHIFT_CHARS.contains(&amp;b'A');  // true for uppercase\n</code></pre>"},{"location":"clients/rust/#error-handling","title":"Error Handling","text":"<p>The client library uses a custom <code>ViiperError</code> type for all errors:</p> <pre><code>use viiper_client::ViiperError;\n\nmatch client.bus_list() {\n    Ok(buses) =&gt; println!(\"Found {} buses\", buses.buses.len()),\n    Err(ViiperError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ViiperError::Protocol(problem)) =&gt; eprintln!(\"API error: {}\", problem),\n    Err(e) =&gt; eprintln!(\"Other error: {}\", e),\n}\n</code></pre> <p>The server returns errors as RFC 7807 Problem inspired JSON. The client parses these into <code>ProblemJson</code>:</p> <pre><code>use viiper_client::ProblemJson;\n\nif let Err(ViiperError::Protocol(problem)) = result {\n    println!(\"Status: {}\", problem.status);\n    println!(\"Title: {}\", problem.title);\n    println!(\"Detail: {}\", problem.detail);\n}\n</code></pre>"},{"location":"clients/rust/#features","title":"Features","text":"<p>The Rust client library supports optional features:</p> Feature Description Dependencies (default) Synchronous blocking client None <code>async</code> Async client with Tokio runtime <code>tokio</code>, <code>tokio-util</code> <p>Enable async support:</p> <pre><code>[dependencies]\nviiper-client = { version = \"0.1\", features = [\"async\"] }\n</code></pre>"},{"location":"clients/rust/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard (sync): <code>examples/rust/sync/virtual_keyboard/</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Keyboard (async): <code>examples/rust/async/virtual_keyboard/</code></p> </li> <li> <p>Async version using Tokio runtime</p> </li> <li> <p>Virtual Mouse (sync/async): <code>examples/rust/sync/virtual_mouse/</code>, <code>examples/rust/async/virtual_mouse/</code></p> </li> <li>Moves cursor diagonally</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller (sync/async): <code>examples/rust/sync/virtual_x360_pad/</code>, <code>examples/rust/async/virtual_x360_pad/</code></p> </li> <li>Cycles through buttons</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/rust/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>Go Client Documentation: Reference implementation patterns</li> <li>C# Client Library Documentation: Alternative managed language client library</li> <li>TypeScript Client Library Documentation: Node.js client library</li> <li>C Client Library Documentation: Native C client library</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul>"},{"location":"clients/typescript/","title":"TypeScript Client Library Documentation","text":"<p>The VIIPER TypeScript client library provides a modern, type-safe Node.js client library for interacting with VIIPER servers and controlling virtual devices.</p> <p>The TypeScript client library features:</p> <ul> <li>Type-safe API: Structured request/response types with proper TypeScript definitions</li> <li>Event-driven: EventEmitter-based output handling for device feedback (LEDs, rumble)</li> <li>Zero external dependencies: Uses only built-in Node.js libraries</li> </ul> <p>License</p> <p>The TypeScript client library is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/typescript/#installation","title":"Installation","text":""},{"location":"clients/typescript/#1-using-the-published-package","title":"1. Using the Published Package","text":"<p>Install the client library from the public npm registry:</p> <pre><code>npm install viiperclient\n</code></pre> <p>The latest stable version is tagged as <code>latest</code>.</p> <p>!!! \"Pre-Releases\"     Pre-release / snapshot builds are not published to npm. They are only available as GitHub Release artifacts (e.g. <code>dev-latest</code>) or by building from source.</p> <p>To use a snapshot artifact from GitHub:</p> <ol> <li>Download <code>viiperclient-typescript-sdk-Snapshot.tgz</code> (or a versioned tarball) from the appropriate Release.</li> <li>Install it directly:</li> </ol> <pre><code>npm install ./viiperclient-typescript-sdk-Snapshot.tgz\n</code></pre> <p>Package page: npm: viiperclient</p>"},{"location":"clients/typescript/#2-local-project-reference-for-development-against-source","title":"2. Local Project Reference (For Development Against Source)","text":"<p>If you are actively modifying VIIPER or the code generator, link directly:</p> <pre><code>{\n  \"dependencies\": {\n    \"viiperclient\": \"file:../../clients/typescript\"\n  }\n}\n</code></pre> <p>Then build locally after regeneration:</p> <pre><code>cd clients/typescript\nnpm install\nnpm run build\n</code></pre>"},{"location":"clients/typescript/#example","title":"Example","text":"<pre><code>import { ViiperClient, Keyboard } from \"viiperclient\";\n\nconst { KeyboardInput, Key, Mod } = Keyboard;\n\n// Create new Viiper client\nconst client = new ViiperClient(\"localhost\", 3242);\n\n// Find or create a bus\nconst busesResp = await client.buslist();\nlet busID: number;\nif (busesResp.buses.length === 0) {\n  const resp = await client.buscreate(); // Auto-assign ID\n  // Or specify ID: await client.buscreate(5);\n  busID = resp.busId;\n} else {\n  busID = busesResp.buses[0];\n}\n\n// Add device and connect\nconst deviceReq = { type: \"keyboard\" };\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n\nconsole.log(`Connected to device ${response.busId}-${response.devId}`);\n\n// Send keyboard input\nconst input = new KeyboardInput({\n  Modifiers: Mod.LeftShift,\n  Count: 1,\n  Keys: [Key.H]\n});\nawait device.send(input);\n\n// Cleanup\nawait client.busdeviceremove(busID, response.devId);\n</code></pre>"},{"location":"clients/typescript/#device-controlfeedback","title":"Device Control/Feedback","text":""},{"location":"clients/typescript/#creating-a-device-controlfeedback-stream","title":"Creating a Device + Control/Feedback Stream","text":"<p>The simplest way to add a device and connect:</p> <pre><code>const deviceReq = { type: \"xbox360\" };\nconst { device, response } = await client.addDeviceAndConnect(busID, deviceReq);\n</code></pre> <p>Or manually add and connect:</p> <pre><code>const deviceResp = await client.busdeviceadd(busId, { type: \"keyboard\" });\nconst device = await client.connectDevice(busId, deviceResp.devId);\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>const device = await client.connectDevice(busId, deviceId);\n</code></pre>"},{"location":"clients/typescript/#sending-input","title":"Sending Input","text":"<p>Device input is sent using generated classes:</p> <pre><code>import { Xbox360 } from \"viiperclient\";\n\nconst { Xbox360Input, Button } = Xbox360;\n\nconst input = new Xbox360Input({\n  Buttons: Button.A,\n  Lt: 255,\n  Rt: 0,\n  Lx: -32768,  // Left stick left\n  Ly: 32767,   // Left stick up\n  Rx: 0,\n  Ry: 0\n});\nawait device.send(input);\n</code></pre>"},{"location":"clients/typescript/#receiving-feedback","title":"Receiving Feedback","text":"<p>For devices that send feedback (rumble, LEDs), subscribe to the <code>output</code> event:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { LED } = Keyboard;\n\ndevice.on(\"output\", (data: Buffer) =&gt; {\n  if (data.length &lt; 1) return;\n  const leds = data.readUInt8(0);\n\n  console.log(`LEDs: ` +\n    `Num=${(leds &amp; LED.NumLock) !== 0} ` +\n    `Caps=${(leds &amp; LED.CapsLock) !== 0} ` +\n    `Scroll=${(leds &amp; LED.ScrollLock) !== 0}`);\n});\n</code></pre> <p>For Xbox360 rumble:</p> <pre><code>device.on(\"output\", (data: Buffer) =&gt; {\n  if (data.length &lt; 2) return;\n  const leftMotor = data.readUInt8(0);\n  const rightMotor = data.readUInt8(1);\n  console.log(`Rumble: Left=${leftMotor} Right=${rightMotor}`);\n});\n</code></pre>"},{"location":"clients/typescript/#closing-a-device","title":"Closing a Device","text":"<pre><code>device.close();\n</code></pre> <p>The VIIPER server automatically removes the device when the stream is closed after a short timeout.</p>"},{"location":"clients/typescript/#error-handling-and-events","title":"Error Handling and Events","text":"<p>Device streams emit <code>error</code> and <code>end</code> events that should be handled:</p> <pre><code>device.on(\"error\", async (err: Error) =&gt; {\n  console.error(`Stream error: ${err}`);\n  // Handle error and cleanup\n});\n\ndevice.on(\"end\", async () =&gt; {\n  console.log(\"Stream ended by server\");\n  // Handle disconnection and cleanup\n});\n</code></pre> <p>For long-running applications with intervals or timers, stop them before cleanup:</p> <pre><code>let running = true;\nconst interval = setInterval(async () =&gt; {\n  if (!running) return;\n\n  try {\n    await device.send(input);\n  } catch (err) {\n    console.error(`Send error: ${err}`);\n    running = false;\n    clearInterval(interval);\n    // Cleanup...\n  }\n}, 16);\n\n// Handle Ctrl+C gracefully\nprocess.on(\"SIGINT\", async () =&gt; {\n  console.log(\"Stopping...\");\n  running = false;\n  clearInterval(interval);\n  device.close();\n  await client.busdeviceremove(busId, deviceId);\n  process.exit(0);\n});\n</code></pre>"},{"location":"clients/typescript/#generated-constants-and-maps","title":"Generated Constants and Maps","text":"<p>The TypeScript SDK automatically generates enums and helper maps for each device type.</p>"},{"location":"clients/typescript/#keyboard-constants","title":"Keyboard Constants","text":"<p>Key Enum:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { Key } = Keyboard;\n\nconst key = Key.A;               // 0x04\nconst f1 = Key.F1;               // 0x3A\nconst enter = Key.Enter;         // 0x28\n</code></pre> <p>Modifier Flags:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { Mod } = Keyboard;\n\nconst mods = Mod.LeftShift | Mod.LeftCtrl;  // 0x03\n</code></pre> <p>LED Flags:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst numLock = (leds &amp; LED.NumLock) !== 0;\nconst capsLock = (leds &amp; LED.CapsLock) !== 0;\n</code></pre>"},{"location":"clients/typescript/#helper-maps","title":"Helper Maps","text":"<p>The client library generates useful lookup maps for working with keyboard input:</p> <p>CharToKey Map - Convert ASCII characters to key codes:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { CharToKeyGet } = Keyboard;\n\nconst key = CharToKeyGet('A'.codePointAt(0)!);\nif (key !== undefined) {\n  console.log(`'A' maps to ${key}`);  // Key.A\n}\n</code></pre> <p>KeyName Map - Get human-readable key names:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { KeyNameGet } = Keyboard;\n\nconst name = KeyNameGet(Key.F1);\nif (name !== undefined) {\n  console.log(`Key name: ${name}`);  // \"F1\"\n}\n</code></pre> <p>ShiftChars Map - Check if a character requires shift:</p> <pre><code>import { Keyboard } from \"viiperclient\";\n\nconst { ShiftCharsHas } = Keyboard;\n\nconst needsShift = ShiftCharsHas('A'.codePointAt(0)!);  // true for uppercase\n</code></pre>"},{"location":"clients/typescript/#error-handling","title":"Error Handling","text":"<p>The server returns errors as JSON. The client throws exceptions:</p> <pre><code>try {\n  await client.buscreate(\"invalid-bus-id\");\n} catch (err) {\n  console.error(`Request failed: ${err}`);\n}\n</code></pre> <p>Device Control/Feedback stream errors are surfaced through the EventEmitter error event:</p> <pre><code>device.on('error', (err) =&gt; {\n  console.error(`Stream error: ${err}`);\n});\n</code></pre>"},{"location":"clients/typescript/#resource-management","title":"Resource Management","text":"<p>Always close devices when done:</p> <pre><code>try {\n  const device = await client.connectDevice(busId, deviceId);\n  // ... use device ...\n} finally {\n  device.close();\n}\n</code></pre>"},{"location":"clients/typescript/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/typescript/virtual_keyboard.ts</code></li> <li>Types \"Hello!\" every 5 seconds using generated maps</li> <li> <p>Displays LED feedback in console</p> </li> <li> <p>Virtual Mouse: <code>examples/typescript/virtual_mouse.ts</code></p> </li> <li>Moves cursor diagonally</li> <li> <p>Demonstrates button clicks and scroll wheel</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/typescript/virtual_x360_pad.ts</code></p> </li> <li>Runs at 60fps with cycling buttons and animated triggers</li> <li>Handles rumble feedback</li> </ul>"},{"location":"clients/typescript/#running-examples","title":"Running Examples","text":"<pre><code>cd examples/typescript\nnpm install\nnpm run build\n\nnode dist/virtual_keyboard.js localhost:3242\n</code></pre>"},{"location":"clients/typescript/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated client libraries work</li> <li>Go Client Documentation: Reference implementation patterns</li> <li>C# Client Library Documentation: Alternative managed language client library</li> <li>Rust Client Library Documentation: Rust client library with sync/async support</li> <li>C Client Library Documentation: Alternative client library for native integration</li> <li>C++ Client Library Documentation: Header-only C++ client library</li> <li>API Overview: Management API reference</li> <li>Device Documentation: Wire formats and device-specific details</li> </ul>"},{"location":"devices/dualshock4/","title":"DualShock 4 Controller","text":"<p>The DualShock 4 virtual gamepad emulates a complete PlayStation 4 Controller (V1)  connected via USB. It supports sticks, triggers, D-pad, face/shoulder buttons, PS button,  touchpad click, IMU (gyro + accelerometer), and touchpad finger coordinates.</p> <p>Use <code>dualshock4</code> as the device type when adding a device via the API or client libraries.</p>"},{"location":"devices/dualshock4/#client-library-support","title":"Client Library Support","text":"<p>The wire protocol is abstracted by client libraries. The Go client includes built-in types (<code>/device/dualshock4</code>), and generated client libraries provide equivalent structures with proper packing.  </p> <p>You don't need to manually construct packets, just use the provided types and send/receive them via the device control and feedback stream.</p> <p>See: API Reference</p>"},{"location":"devices/dualshock4/#raw-streaming-protocol","title":"(RAW) Streaming protocol","text":"<p>The device stream is a bidirectional, raw TCP connection with fixed-size packets.</p>"},{"location":"devices/dualshock4/#input-state","title":"Input State","text":"<ul> <li>31-byte packets, little-endian layout:<ul> <li>Sticks: StickLX, StickLY, StickRX, StickRY: int8 each (4 bytes)   -128 to 127 per axis (-128=min, 0=center, 127=max)</li> <li>Buttons: uint16 (2 bytes, bitfield)</li> <li>DPad: uint8 (1 byte, bitfield)</li> <li>Triggers: TriggerL2, TriggerR2: uint8, uint8 (2 bytes)   0-255 (0=not pressed, 255=fully pressed)</li> <li>Touch1: Touch1X, Touch1Y: uint16 each, Touch1Active: bool (5 bytes)</li> <li>Touch2: Touch2X, Touch2Y: uint16 each, Touch2Active: bool (5 bytes)</li> <li>Gyroscope: GyroX, GyroY, GyroZ: int16 each (6 bytes, fixed-point \u00b0/s)</li> <li>Accelerometer: AccelX, AccelY, AccelZ: int16 each (6 bytes, fixed-point m/s\u00b2)</li> </ul> </li> </ul> <p>See <code>/device/dualshock4/inputstate.go</code> for details.</p>"},{"location":"devices/dualshock4/#feedback-rumble-led","title":"Feedback (Rumble &amp; LED)","text":"<ul> <li>7-byte packets:<ul> <li>RumbleSmall: uint8, RumbleLarge: uint8 (2 bytes)   0-255 intensity values</li> <li>LED Color: LedRed, LedGreen, LedBlue: uint8 each (3 bytes)   0-255 per channel</li> <li>LED Flash: FlashOn, FlashOff: uint8 each (2 bytes)   Units of 2.5ms per value</li> </ul> </li> </ul> <p>See <code>/device/dualshock4/inputstate.go</code> for the <code>OutputState</code> wire definition.</p>"},{"location":"devices/dualshock4/#reference","title":"Reference","text":""},{"location":"devices/dualshock4/#button-constants","title":"Button Constants","text":"Button Hex Value Square button 0x0010 Cross (X) button 0x0020 Circle button 0x0040 Triangle button 0x0080 L1 (Left bumper) 0x0100 R1 (Right bumper) 0x0200 L2 button 0x0400 R2 button 0x0800 Share button 0x1000 Options button 0x2000 L3 (Left stick button) 0x4000 R3 (Right stick button) 0x8000 PS button 0x0001 Touchpad click 0x0002"},{"location":"devices/dualshock4/#d-pad-constants","title":"D-Pad Constants","text":"D-Pad Direction Hex Value Up 0x01 Down 0x02 Left 0x04 Right 0x08"},{"location":"devices/dualshock4/#touchpad-coordinates","title":"Touchpad Coordinates","text":"<p>Touch coordinates are sent as <code>Touch{1,2}X: uint16</code> and <code>Touch{1,2}Y: uint16</code> plus an explicit boolean <code>Touch{1,2}Active</code>.</p> <p>VIIPER clamps touch coordinates to the DS4 range:</p> <ul> <li>X: 0..1920</li> <li>Y: 0..942</li> </ul> <p>These are the bounds used by VIIPER\u2019s DS4 implementation; see <code>/device/dualshock4/const.go</code>.</p>"},{"location":"devices/dualshock4/#imu-gyro-accelerometer","title":"IMU (Gyro + Accelerometer)","text":""},{"location":"devices/dualshock4/#fixed-point-physical-units","title":"Fixed-Point Physical Units","text":"<p>VIIPER uses fixed-point physical units for IMU values on the wire (still stored as <code>int16</code>), to avoid float serialization differences across client languages.</p> <p>Constants (see <code>/device/dualshock4/const.go</code>):</p> <ul> <li><code>GyroCountsPerDps = 16</code></li> <li><code>AccelCountsPerMS2 = 512</code></li> </ul>"},{"location":"devices/dualshock4/#conversion-formulas","title":"Conversion Formulas","text":"<p>Gyro (degrees/second):</p> <pre><code>raw_gyro = round(gyro_dps * GyroCountsPerDps)\ngyro_dps = raw_gyro / GyroCountsPerDps\n</code></pre> <p>Accelerometer (m/s\u00b2):</p> <pre><code>raw_accel = round(accel_ms2 * AccelCountsPerMS2)\naccel_ms2 = raw_accel / AccelCountsPerMS2\n</code></pre>"},{"location":"devices/dualshock4/#resolution-and-range","title":"Resolution and range","text":"<p>With the default scales:</p> <ul> <li>Gyro (<code>GyroCountsPerDps = 16</code>):<ul> <li>Resolution: <code>1/16 = 0.0625 \u00b0/s</code></li> <li>Approx max magnitude: <code>32767/16 \u2248 2048 \u00b0/s</code></li> </ul> </li> <li>Accelerometer (<code>AccelCountsPerMS2 = 512</code>):<ul> <li>Resolution: <code>1/512 \u2248 0.001953125 m/s\u00b2</code></li> <li>Approx max magnitude: <code>32767/512 \u2248 64 m/s\u00b2</code> (\u2248 6.5 g)</li> </ul> </li> </ul> <p>Conversions saturate to the <code>int16</code> range if inputs exceed representable values.</p>"},{"location":"devices/dualshock4/#default-neutral-report-gravity","title":"Default (Neutral) Report Gravity","text":"<p>On device creation, VIIPER initializes the accelerometer to represent a controller lying flat on a table, with gravity \"downwards\":</p> <ul> <li><code>g = 9.81 m/s\u00b2</code></li> <li>Default accel is: <code>(0, 0, -g)</code></li> </ul> <p>In raw fixed-point units, this means:</p> <ul> <li><code>AccelX = 0</code></li> <li><code>AccelY = 0</code></li> <li><code>AccelZ = round(-9.81 * 512) = -5023</code></li> </ul> <p>Helpers for converting between physical units and raw values are provided in <code>/device/dualshock4/helpers.go</code>.</p>"},{"location":"devices/keyboard/","title":"HID Keyboard","text":"<p>A full-featured HID keyboard with N-key rollover using a 256-bit key bitmap, plus LED status feedback (NumLock, CapsLock, ScrollLock).</p> <p>Use keyboard as the device type when adding a device via the API or client libraries.</p>"},{"location":"devices/keyboard/#client-library-support","title":"Client Library Support","text":"<p>The wire protocol is abstracted by client libraries. The Go client includes built-in types (/device/keyboard), and generated client libraries provide equivalent structures with proper packing.  </p> <p>You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: API Reference</p>"},{"location":"devices/keyboard/#raw-streaming-protocol","title":"(RAW) Streaming protocol","text":"<p>The device stream is a bidirectional, raw TCP connection with variable-size packets.</p>"},{"location":"devices/keyboard/#input-state","title":"Input State","text":"<ul> <li>Variable-length packets:<ul> <li>Header: Modifiers (1 byte), KeyCount (1 byte)</li> <li>Followed by KeyCount bytes of HID Usage IDs for currently pressed non-modifier keys</li> </ul> </li> </ul>"},{"location":"devices/keyboard/#led-feedback","title":"LED Feedback","text":"<ul> <li>1-byte packets: LEDs bitfield<ul> <li>Bit 0: NumLock</li> <li>Bit 1: CapsLock</li> <li>Bit 2: ScrollLock</li> </ul> </li> </ul> <p>See <code>/device/keyboard/inputstate.go</code> for details.</p>"},{"location":"devices/keyboard/#reference","title":"Reference","text":""},{"location":"devices/keyboard/#modifiers","title":"Modifiers","text":"Modifier Hex Value LeftCtrl 0x01 LeftShift 0x02 LeftAlt 0x04 LeftGUI 0x08 RightCtrl 0x10 RightShift 0x20 RightAlt 0x40 RightGUI 0x80"},{"location":"devices/keyboard/#keycodes","title":"Keycodes","text":"<p>HID Usage IDs for keys are available in <code>/device/keyboard/const.go</code>, including standard alphanumeric keys (0x04\u20130x63) and media keys (Mute, VolumeUp/Down, PlayPause, Stop, Next, Previous).</p> <p>Helper functions for common operations are in <code>/device/keyboard/helpers.go</code>.</p>"},{"location":"devices/mouse/","title":"HID Mouse","text":"<p>A standard 5-button mouse with vertical and horizontal scroll wheels. Reports relative motion deltas.</p> <p>Use <code>mouse</code> as the device type when adding a device via the API or client libraries.</p>"},{"location":"devices/mouse/#client-library-support","title":"Client Library Support","text":"<p>The wire protocol is abstracted by client libraries. The Go client includes built-in types (/device/mouse), and generated client libraries provide equivalent structures with proper packing.  </p> <p>You don't need to manually construct packets, just use the provided types and send them via the device stream.</p> <p>See: API Reference</p>"},{"location":"devices/mouse/#raw-streaming-protocol","title":"(RAW) Streaming protocol","text":"<p>The device stream is a bidirectional, raw TCP connection with fixed-size packets.</p>"},{"location":"devices/mouse/#input-state","title":"Input State","text":"<ul> <li>9-byte packets, little-endian layout:<ul> <li>Buttons: uint8 (1 byte, bitfield) \u2014 bits 0..4 for buttons 1..5</li> <li>X delta: int16 (2 bytes)    -32768 to +32767</li> <li>Y delta: int16 (2 bytes)    -32768 to +32767</li> <li>Vertical wheel: int16 (2 bytes)   positive = up</li> <li>Horizontal wheel/pan: int16 (2 bytes)    positive = right</li> </ul> </li> </ul> <p>Motion and wheel deltas are consumed after each report and reset; buttons persist until changed.</p> <p>See <code>/device/mouse/inputstate.go</code> for details.</p>"},{"location":"devices/xbox360/","title":"Xbox 360 Controller","text":"<p>The Xbox 360 virtual gamepad emulates an XInput-compatible controller that most operating systems and games understand out of the box.</p> <p>Use <code>xbox360</code> as the device type when adding a device via the API or client libraries.</p>"},{"location":"devices/xbox360/#client-library-support","title":"Client Library Support","text":"<p>The wire protocol is abstracted by client libraries. The Go client includes built-in types (<code>/device/xbox360</code>), and generated client libraries provide equivalent structures with proper packing.  </p> <p>You don't need to manually construct packets, just use the provided types and send/receive them via the device control and feedback stream.  </p> <p>See: API Reference</p>"},{"location":"devices/xbox360/#raw-streaming-protocol","title":"(RAW) Streaming protocol","text":"<p>The device stream is a bidirectional, raw TCP connection with fixed-size packets.</p>"},{"location":"devices/xbox360/#input-state","title":"Input State","text":"<ul> <li>14-byte packets, little-endian layout:  <ul> <li>Buttons: uint32 (4 bytes, bitfield)  </li> <li>Triggers: LT, RT: uint8, uint8 (2 bytes)   0-255 (0=not pressed, 255=fully pressed)</li> <li>Sticks: LX, LY, RX, RY: int16 each (8 bytes)   0 is center, -32768 is min, 32767 is max</li> </ul> </li> </ul>"},{"location":"devices/xbox360/#rumble-feedback","title":"Rumble Feedback","text":"<ul> <li>2-byte packets:  <ul> <li>LeftMotor: uint8, RightMotor: uint8   0-255 intensity values</li> </ul> </li> </ul> <p>See <code>/device/xbox360/inputstate.go</code> for details.</p>"},{"location":"devices/xbox360/#button-constants","title":"Button constants","text":"Button Hex Value D-Pad Up 0x0001 D-Pad Down 0x0002 D-Pad Left 0x0004 D-Pad Right 0x0008 Start button 0x0010 Back button 0x0020 Left stick button 0x0040 Right stick button 0x0080 Left bumper 0x0100 Right bumper 0x0200 Xbox/Guide button 0x0400 A button 0x1000 B button 0x2000 X button 0x4000 Y button 0x8000"},{"location":"getting-started/installation/","title":"Installation","text":"<p>VIIPER currently comes in a single flavor:</p> <ul> <li>a standalone executable that exposes an API over TCP.</li> <li>There will eventually be a shared-library version (libVIIPER) that you can link against directly from your application. For more information, see FAQ</li> </ul>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":""},{"location":"getting-started/installation/#usbip","title":"USBIP","text":"<p>VIIPER relies on USBIP. You must have a USBIP-Client implementation available on your system to use VIIPER's virtual devices.</p> WindowsLinux <p>usbip-win2 is by far the most complete implementation of USBIP for Windows (comes with a SIGNED kernel mode driver).</p> <p>Install and done \ud83d\ude09</p> <p>USBIP-Win2 security issue</p> <p>The releases of usbip-win2 currently (at the time of writing) install the publicly available test signing CA as a trusted root CA on your system. You can safely remove this CA after installation using <code>certmgr.msc</code> (run as admin) and removing the \"USBIP\" from the \"Trusted Root Certification Authorities\" -&gt; \"Certificates\" list.</p> <p>Alternativly, you can download and istall the latest pre-release driver manually from the OSSign repository, which has this issue fixed already. Note that the installer does not work, only the driver <code>.cat,.inf,.sys</code> files.</p>"},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt install linux-tools-generic\n</code></pre> <p>Ubuntu USBIP Manual</p>"},{"location":"getting-started/installation/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S usbip\n</code></pre> <p>Arch Wiki: USBIP</p>"},{"location":"getting-started/installation/#linux-kernel-module-setup","title":"Linux Kernel Module Setup","text":"<p>USBIP Client Requirement</p> <p>USBIP requires the <code>vhci-hcd</code> (Virtual Host Controller Interface) kernel module on Linux for client operations. This includes VIIPER's auto-attach feature and manual device attachment.</p> <p>Most Linux distributions include this module but don't load it automatically.</p>"},{"location":"getting-started/installation/#one-time-setup","title":"One-Time Setup","text":"<p>To load the module automatically on boot:</p> <pre><code>echo \"vhci-hcd\" | sudo tee /etc/modules-load.d/vhci-hcd.conf\nsudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/installation/#manual-loading","title":"Manual Loading","text":"<p>To load the module for the current session only:</p> <pre><code>sudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Check if the module is loaded:</p> <pre><code>lsmod | grep vhci_hcd\n</code></pre>"},{"location":"getting-started/installation/#installing-viiper","title":"Installing VIIPER","text":"<p>VIIPER does not require system-wide installation. The <code>viiper</code> executable is completely self-contained (and fully portable without any dependencies, except USBIP) and can be:</p> <ul> <li>Placed in any directory</li> <li>Shipped alongside your application</li> <li>Run directly without installation</li> <li>Bundled with your application's distribution</li> </ul> <p>This makes VIIPER ideal for embedding in applications or distributing as part of a software package.</p> <p>Daemon/Service Conflicts</p> <p>If VIIPER is already running as a system service or daemon on the target machine, be aware of potential port conflicts. Applications should: - Check if VIIPER is already running before starting their own instance   - use the <code>ping</code> API endpoint to check for VIIPER presence and version - Connect to the existing VIIPER instance (if accessible) - Use a custom port via <code>--api.addr</code> flag to run a separate instance</p> <p>Linux Permissions</p> <p>On Linux, attaching devices via USBIP requires root permissions. You can run VIIPER with <code>sudo</code>, or configure appropriate udev rules to allow non-root users to attach devices.</p>"},{"location":"getting-started/installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release from the GitHub Releases page. Pre-built binaries are available for:</p> <ul> <li>Windows (x64, ARM64)</li> <li>Linux (x64, ARM64)</li> </ul>"},{"location":"getting-started/installation/#automated-install-script","title":"Automated Install Script","text":"<p>Regardless of portability, it can be convenient to have VIIPER start automatically on system boot, especially if end users want to use your application through a network or you want to enable that possibility.  </p> <p>The following scripts will download a VIIPER release, install it to a system location, and configure it to start automatically on boot.  </p> <p>For Application Developers</p> <p>The installation scripts are intended for end-users setting up a permanent VIIPER service on their system.  </p> <p>If you're developing an application that uses VIIPER, I strongly encourage you to not install a permanent VIIPER service on your users machines. </p> <p>Instead, bundle the (no dependencies, portable) VIIPER binary with your application and start/stop the server directly from your application as needed. You may need to check for existing VIIPER instances or use a custom port via <code>--api.addr</code> to avoid conflicts.   </p> <p>USBIP installed by scripts</p> <p>The install scripts install and configure USBIP for you:</p> <ul> <li>Windows: installs the usbip-win2 driver (admin prompt) and prompts for a reboot when drivers were added.</li> <li>Linux: installs USBIP via the distro package manager (when available), loads <code>vhci_hcd</code>, and configures it to autoload.</li> </ul> <p>If the automated USBIP setup fails, follow the USBIP guide to finish manually.</p> WindowsLinux <pre><code>irm https://alia5.github.io/VIIPER/stable/install.ps1 | iex\n</code></pre> <p>Installs to: <code>%LOCALAPPDATA%\\VIIPER\\viiper.exe</code></p> <p>The scripts will:</p> <ol> <li>Download the specified VIIPER binary version</li> <li>Install it to the system location</li> <li>Install and configure USBIP (driver on Windows; packages/modules on Linux)</li> <li>Configure automatic startup (Registry RunKey on Windows, systemd service on Linux)</li> <li>Start/restart the VIIPER service</li> </ol> <pre><code>curl -fsSL https://alia5.github.io/VIIPER/stable/install.sh | sh\n</code></pre> <p>Installs to: <code>/usr/local/bin/viiper</code></p> <p>The scripts will:</p> <ol> <li>Download the specified VIIPER binary version</li> <li>Install it to the system location</li> <li>Attempt to install and configure USBIP </li> <li>Load the <code>vhci_hcd</code> kernel module and configure it to autoload on boot</li> <li>Configure and run a systemd service</li> </ol> <p>Version-Specific Installation:</p> <p>The install scripts are version-aware based on where you download them from:</p> <ul> <li> <p>Latest stable release: <code>curl -fsSL https://alia5.github.io/VIIPER/stable/install.sh | sh</code></p> </li> <li> <p>Specific version (e.g., v0.2.2): <code>curl -fsSL https://alia5.github.io/VIIPER/0.2.2/install.sh | sh</code></p> </li> <li> <p>Latest pre-release (development snapshot): <code>curl -fsSL https://alia5.github.io/VIIPER/main/install.sh | sh</code></p> </li> </ul>"},{"location":"getting-started/installation/#system-startup-configuration","title":"System Startup Configuration","text":"<p>The <code>install</code> and <code>uninstall</code> commands configure automatic startup for the VIIPER binary.</p> <p>What These Commands Do</p> <p>These commands do not copy or move the VIIPER binary. They configure your system to automatically run the binary from its current location when the system boots.</p> <p>Make sure the binary is in a permanent location before running <code>viiper install</code>!</p>"},{"location":"getting-started/installation/#viiper-install","title":"<code>viiper install</code>","text":"<p>Configures VIIPER to start automatically on system boot:</p> <pre><code>viiper install\n</code></pre> <ul> <li>Windows:  </li> <li>Adds entry to Registry RunKey: <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\VIIPER</code></li> <li>Value: <code>\"&lt;current-exe-path&gt;\" server</code></li> <li>Kills any previous autorun instances</li> <li> <p>Starts the server</p> </li> <li> <p>Linux:  </p> </li> <li>Creates systemd service: <code>/etc/systemd/system/viiper.service</code></li> <li>Service ExecStart points to current binary path</li> <li>Enables and starts the service</li> </ul>"},{"location":"getting-started/installation/#viiper-uninstall","title":"<code>viiper uninstall</code>","text":"<p>Removes VIIPER from system startup and stops any running instance:</p> <pre><code>viiper uninstall\n</code></pre> <ul> <li>Windows:  </li> <li>Removes Registry RunKey entry</li> <li> <p>Kills any running autorun instances</p> </li> <li> <p>Linux:  </p> </li> <li>Stops and disables the systemd service</li> <li>Removes <code>/etc/systemd/system/viiper.service</code></li> </ul>"},{"location":"getting-started/installation/#building-from-source","title":"Building from Source","text":"<p>Building from source is only necessary if you need to modify VIIPER or target an unsupported platform.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or newer</li> <li>USBIP installed</li> <li>(Optional) Make</li> <li>Linux/macOS: Usually pre-installed</li> <li>Windows: <code>winget install ezwinports.make</code></li> </ul>"},{"location":"getting-started/installation/#build-steps","title":"Build Steps","text":"<pre><code>git clone https://github.com/Alia5/VIIPER.git\ncd VIIPER\nmake build\n</code></pre> <p>The compiled binary will be in <code>dist/viiper</code> (or <code>dist/viiper.exe</code> on Windows).</p> <p>Additional build targets:</p> <pre><code>make help          # Show all available make targets\nmake test          # Run tests\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Ensure you have:</p> <ol> <li>USBIP installed on your system (see Installation)</li> <li>VIIPER binary downloaded from GitHub Releases or built from source</li> </ol>"},{"location":"getting-started/quickstart/#starting-the-server","title":"Starting the Server","text":"<p>Start VIIPER with default settings:</p> <pre><code>viiper server\n</code></pre> <p>This starts two services:</p> <ul> <li>USBIP Server on port <code>3241</code> (standard USBIP protocol)</li> <li>VIIPER API Server on port <code>3242</code> (management and device interactions)</li> </ul> <p>Auto-attach Feature</p> <p>By default, VIIPER automatically attaches newly created devices to the local machine. You can disable this with <code>--api.auto-attach-local-client=false</code>. Linux users: Auto-attach requires running VIIPER with <code>sudo</code> as USBIP attach operations need elevated permissions.</p> <p>Custom Ports</p> <p>To use different ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre> <p>See CLI Reference for all available options.</p>"},{"location":"getting-started/quickstart/#creating-your-first-virtual-device","title":"\ud83c\udfae Creating Your First Virtual Device","text":"<p>VIIPER provides multiple ways to interact with the API. Choose the method that works best for you.</p>"},{"location":"getting-started/quickstart/#option-1-using-client-libraries-recommended","title":"Option 1: Using Client Libraries (Recommended)","text":"<p>Client libraries are (at time of writing) available for C, C++, C#, Go, Rust, and TypeScript. They handle the protocol details automatically, providing type-safe interfaces and device-specific helpers.</p> <p>For complete client library documentation and code examples, see:</p> <ul> <li>C Client Library Documentation</li> <li>C++ Client Library Documentation</li> <li>C# Client Library Documentation</li> <li>TypeScript Client Library Documentation</li> <li>Go Client Documentation</li> <li>Rust Client Documentation</li> </ul> <p>Full working examples for all device types are available in the <code>examples/</code> directory of the repository.</p>"},{"location":"getting-started/quickstart/#example","title":"Example","text":"<p>For a minimal example, we'll be using TypeScript (as there are more Javascript devs than Insects on this planet), but you can checkout any of the examples provided in the API Reference</p> <p>This minimal example creates a virtual Xbox 360 controller and sends an input state to press the \"A\" button, left bumper, half-press the left trigger, and push the left analog-stick to the right.  </p> <p>Error handling is omitted for brevity.</p> <pre><code>import { ViiperClient, ViiperDevice, Xbox360, Types } from \"viiperclient\";\nconst { Xbox360Input, Button } = Xbox360;\n\nconst client = new ViiperClient(\"localhost\", 3242);\nconst bus_create_response = await client.buscreate();\n\nconst { device, response: addResp } = await client.addDeviceAndConnect(\n    bus_create_response.busId,\n    { type: \"xbox360\"}\n);\n\ndevice.send(new Xbox360Input({\n        Buttons: Button.A | Button.LB,\n        // Left trigger half-pressed\n        Lt: 128,\n        Rt: 0,\n        // Left joystick pushed to the right\n        Lx: 32768,\n        Ly: 0,\n        Rx: 0,\n        Ry: 0,\n}));\n</code></pre>"},{"location":"getting-started/quickstart/#option-2-using-raw-tcp","title":"Option 2: Using Raw TCP","text":"<p>VIIPER provides a lightweight TCP API for direct interaction. See: API Reference for complete documentation.</p> <p>For quick testing you can use <code>netcat</code> on Linux or the provided PowerShell helper script on Windows.</p> NetcatPowerShell <pre><code># Create a bus\nprintf \"bus/create\\0\" | nc localhost 3242\n# Response: {\"busId\":1}\n\n# Add a keyboard device\nprintf 'bus/1/add {\"type\":\"keyboard\"}\\0' | nc localhost 3242\n# Response: {\"busId\":1,\"devId\":\"1\",\"vid\":\"0x2e8a\",\"pid\":\"0x0010\",\"type\":\"keyboard\"}\n\n# List devices on the bus\nprintf \"bus/1/list\\0\" | nc localhost 3242\n</code></pre> <p>Protocol Details</p> <p>The API uses TCP with null-byte (<code>\\0</code>) terminated requests. See API Reference for complete protocol documentation.</p> <p>VIIPER includes a PowerShell helper script for Windows users:</p> <pre><code># Load the helper script\n. .\\scripts\\viiper-api.ps1\n\n# Create a bus\nInvoke-ViiperAPI \"bus/create\"\n\n# Add a device\nInvoke-ViiperAPI 'bus/1/add {\"type\":\"keyboard\"}'\n</code></pre>"},{"location":"getting-started/quickstart/#attaching-devices-usbip","title":"\ud83d\udd0c Attaching Devices (USBIP)","text":"<p>After creating a device via the API, attach it using your system's USBIP client.</p> <p>Automatic Attachment</p> <p>If you're running VIIPER on the same machine where you want to use the device, it's likely already attached automatically! Check the Windows device manager or <code>lsusb</code> to confirm.</p>"},{"location":"getting-started/quickstart/#manual-attachment","title":"Manual Attachment","text":"<p>If auto-attach is disabled or you're connecting from a remote machine:</p> LinuxWindows <pre><code># Load kernel module (once per boot)\nsudo modprobe vhci-hcd\n\n# List available devices\nusbip list --remote=localhost --tcp-port=3241\n\n# Attach device (use busid from API response, e.g., \"1-1\")\nsudo usbip attach --remote=localhost --tcp-port=3241 --busid=1-1\n\n# Verify attachment\nlsusb | grep \"Raspberry Pi\"  # For keyboard/mouse\nlsusb | grep \"Microsoft\"     # For Xbox 360 controller\n</code></pre> <p>Using usbip-win2:</p> <pre><code># List available devices\nusbip.exe list --remote localhost --tcp-port 3241\n\n# Attach device\nusbip.exe attach --remote localhost --tcp-port 3241 --busid 1-1\n\n# Check Device Manager to verify attachment\n</code></pre>"},{"location":"getting-started/quickstart/#available-device-types","title":"\ud83e\uddf0 Available Device Types","text":"<p>VIIPER supports multiple virtual device types including keyboards, mice, and game controllers. Each device type has its own protocol and capabilities.</p> <p>For a complete list of supported devices, their specifications, and wire protocols, see the Devices documentation.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"\u27a1\ufe0f Next Steps","text":"<p>Now that you have a working setup:</p> <ol> <li>Explore Examples: Check the <code>examples/</code> directory for complete working programs in C, C#, Go, and TypeScript</li> <li>Read API Documentation: Learn about all available API commands</li> <li>Choose a Client Library: Pick a client library for your preferred language</li> <li>Review Device Specs: Understand device-specific protocols in Devices</li> </ol>"},{"location":"getting-started/quickstart/#troubleshooting","title":"\ud83c\udd98 Troubleshooting","text":""},{"location":"getting-started/quickstart/#server-wont-start","title":"Server Won't Start","text":"<p>Port already in use:</p> <pre><code># Use custom ports\nviiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre> <p>Permission denied (Linux):</p> <pre><code># Use ports above 1024 or run with sudo\nviiper server --usb.addr=:3241 --api.addr=:3242\n</code></pre>"},{"location":"getting-started/quickstart/#auto-attach-not-working","title":"Auto-Attach Not Working","text":"<p>VIIPER will check prerequisites at startup when auto-attach is enabled and log warnings if requirements are missing.</p> <p>Linux - USBIP tool not found:</p> <pre><code># Ubuntu/Debian\nsudo apt install linux-tools-generic\n\n# Arch Linux\nsudo pacman -S usbip\n</code></pre> <p>Linux - Kernel module not loaded:</p> <pre><code># Load for current session\nsudo modprobe vhci-hcd\n\n# Or configure persistent loading (see Installation guide)\n</code></pre> <p>See Linux Kernel Module Setup for detailed setup instructions.</p> <p>Windows - USBIP tool not found:</p> <p>Download and install usbip-win2 and ensure <code>usbip.exe</code> is in your PATH.</p>"},{"location":"getting-started/quickstart/#device-not-attaching","title":"Device Not Attaching","text":"<p>USBIP tool not found:</p> <p>Make sure USBIP is installed and in your PATH (see Installation requirements).</p> <p>Connection refused:</p> <p>Verify the VIIPER server is running and listening on the expected ports.</p>"},{"location":"getting-started/quickstart/#device-not-working","title":"Device Not Working","text":"<p>No input response:</p> <p>Ensure the device is attached via USBIP AND you've opened a device stream via the API to send input data.</p> <p>Multiple VIIPER instances:</p> <p>If you have VIIPER running as a service, your application's instance may conflict. Either connect to the existing instance or use different ports.</p>"},{"location":"getting-started/quickstart/#linux-permission-denied-when-attaching-devices","title":"Linux: Permission Denied When Attaching Devices","text":"<p>On Linux, USBIP attach operations require root permissions.</p> <p>Run VIIPER with <code>sudo</code>:</p> <pre><code>sudo viiper server\n</code></pre> <p>Or if manually attaching devices, use <code>sudo</code> with the <code>usbip attach</code> command:</p> <pre><code>sudo usbip attach --remote=localhost --tcp-port=3241 --busid=1-1\n</code></pre>"},{"location":"getting-started/quickstart/#see-also","title":"\ud83d\udd17 See Also","text":"<ul> <li>CLI Reference - Complete command documentation</li> <li>API Reference - Management API protocol</li> <li>Client Libraries - Language-specific client libraries</li> <li>Configuration - Environment variables and config files</li> </ul>"},{"location":"getting-started/usbip/","title":"\ud83d\udd0c USBIP","text":"\ud83e\ude9f Windows\ud83d\udc27 Linux <p>usbip-win2 is by far the most complete implementation of USBIP for Windows (comes with a SIGNED kernel mode driver).</p> <p>Install and done \ud83d\ude09</p> <p>USBIP-Win2 security issue</p> <p>The releases of usbip-win2 currently (at the time of writing) install the publicly available test signing CA as a trusted root CA on your system. You can safely remove this CA after installation using <code>certmgr.msc</code> (run as admin) and removing the \"USBIP\" from the \"Trusted Root Certification Authorities\" -&gt; \"Certificates\" list.</p> <p>Alternativly, you can download and istall the latest pre-release driver manually from the OSSign repository, which has this issue fixed already. Note that the installer does not work, only the driver <code>.cat,.inf,.sys</code> files.</p>"},{"location":"getting-started/usbip/#arch-linux","title":"\ud83c\udff9 Arch Linux","text":"<pre><code>sudo pacman -S usbip\n</code></pre> <p>Arch Wiki: USBIP</p> Steam OS users <p>If you are installing SISR on Steam OS, you have to switch to the desktop mode and enable write access to the root filesystem first:</p> <pre><code>sudo steamos-readonly disable\n</code></pre>"},{"location":"getting-started/usbip/#ubuntudebian","title":"\ud83d\udfe0 Ubuntu/Debian","text":"<pre><code>sudo apt install linux-tools-generic\n</code></pre> <p>Ubuntu USBIP Manual</p>"},{"location":"getting-started/usbip/#linux-kernel-module-setup","title":"\ud83e\udde9 Linux Kernel Module Setup","text":"<p>USBIP Client Requirement</p> <p>USBIP requires the <code>vhci-hcd</code> (Virtual Host Controller Interface) kernel module on Linux. Most Linux distributions include this module but don't load it automatically.</p>"},{"location":"getting-started/usbip/#one-time-setup","title":"\ud83e\uddf7 One-Time Setup","text":"<p>To load the module automatically on boot:</p> <pre><code>echo \"vhci-hcd\" | sudo tee /etc/modules-load.d/vhci-hcd.conf\nsudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/usbip/#manual-loading","title":"\ud83d\udd04 Manual Loading","text":"<p>To load the module for the current session only:</p> <pre><code>sudo modprobe vhci-hcd\n</code></pre>"},{"location":"getting-started/usbip/#verification","title":"\ud83d\udd0e Verification","text":"<p>Check if the module is loaded:</p> <pre><code>lsmod | grep vhci_hcd\n</code></pre>"},{"location":"testing/e2e_latency/","title":"E2E Latency Benchmarks","text":"<p>The script <code>viiper/_testing/e2e/scripts/lat_bench.go</code> runs (or parses) end\u2011to\u2011end input latency benchmarks and produces enriched output (table, markdown, or JSON).</p> <p>It groups repeated cycles when <code>-count &gt; 1</code> and uses the single press E2E measurement (<code>E2E-InputDelay</code>) as the 100% baseline.</p>"},{"location":"testing/e2e_latency/#output","title":"Output","text":"Column Meaning Benchmark Name of the sub benchmark Count Iterations performed (from Go bench output; affected by <code>-benchtime</code>) ns/op Nanoseconds per operation (direct Go benchmark figure) % of Full Relative to <code>E2E-InputDelay</code> (single press baseline) Client Share % Portion attributed to the (go) client write phase (for E2E rows) Latency Share % Remainder attributed to transport + virtual device/host stack + tight device polling loop <p><code>E2E-PressAndRelease</code> includes both press and release cycles, so it is expected to be ~2\u00d7 the single press and thus can exceed 100% in <code>% of Full</code>.</p>"},{"location":"testing/e2e_latency/#scope-methodology","title":"Scope / Methodology","text":"<ul> <li>All benchmarks included here are executed against a VIIPER server on the same host (localhost).   They therefore measure in-process client emission plus local USBIP stack + emulated device processing only.   Remote/network USBIP attachment will add network RTT and jitter which is intentionally excluded from these baseline figures.</li> <li>Benchmarks use a single emulated Xbox360 controller device.   Other devices might produce slightly different results depending on USB report size and VIIPER-InputState size.</li> <li>Benchmarks use a single button press, which is enough as clients/VIIPER always produce a full report of the devices state.  </li> </ul>"},{"location":"testing/e2e_latency/#benchtime-mode","title":"Benchtime Mode","text":"<p>Runs use a fixed-iteration benchtime (e.g. <code>-benchtime=1000x</code>, <code>-benchtime=10000x</code>) rather than time-based (e.g. <code>2s</code>).  </p>"},{"location":"testing/e2e_latency/#running","title":"Running","text":"<p>From repository root:</p> <pre><code>cd testing/e2e\n# Single run, 1000 fixed iterations per sub benchmark\ngo run ./scripts/lat_bench.go -benchtime=1000x -count=1 -format markdown\n</code></pre> <p>Results (Arch Linux / SteamDeck Kernel / Steam Deck LCD / Go 1.25+, 10k iterations):</p> Benchmark Count ns/op % of Full Client Share % Latency Share % 1_Go-Client-Write 10000 10668 11.98 100.00 0.00 2_InputDelay-Without-Client 10000 74154 83.25 0.00 100.00 3_E2E-InputDelay 10000 89078 100.00 11.98 88.02 4_E2E-PressAndRelease 10000 184870 207.54 11.54 88.46 <p>Example output (Windows / AMD Ryzen 9 3900X / Go 1.25+, 10k iterations):</p> Benchmark Count ns/op % of Full Client Share % Latency Share % 1_Go-Client-Write 10000 27933 16.60 100.00 0.00 2_InputDelay-Without-Client 10000 133724 79.45 0.00 100.00 3_E2E-InputDelay 10000 168307 100.00 16.60 83.40 4_E2E-PressAndRelease 10000 331439 196.93 16.86 83.14 <p>Variability across repeated measurement runs has been negligible. Use a larger <code>-count</code> if you want to increase the number of runs.</p>"},{"location":"testing/e2e_latency/#notes","title":"Notes","text":"<ul> <li>Memory statistics from Go benchmarks are intentionally omitted.</li> <li><code>% of Full</code> falls back to the largest ns/op if the baseline row is missing.</li> <li>All benchmarking must run with parallelism 1 in underlying benches.</li> <li>Benchmarks use a tight polling loop using SDL3 to detect input state changes on the emulated device.</li> <li>Benchmarks must be run without an already running VIIPER server instance.</li> </ul>"}]}