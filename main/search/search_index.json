{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#viiper-documentation","title":"VIIPER Documentation","text":"<p>Welcome to the VIIPER documentation!</p> <p>VIIPER is a tool to create virtual input devices using USBIP.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>CLI Reference</li> <li>API Reference</li> <li>GitHub Repository</li> </ul>"},{"location":"#what-is-viiper","title":"What is VIIPER?","text":"<p>VIIPER creates virtual USB input devices using the USBIP protocol. These virtual devices appear as real hardware to the operating system and applications, allowing you to emulate controllers, keyboards, and other input devices without physical hardware.</p> <p>Beyond device emulation, VIIPER can proxy real USB devices for traffic inspection and reverse engineering. All devices can and must be controlled programmatically via an API.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Virtual input device emulation over IP using USBIP<ul> <li>\u2705 Xbox 360 controller emulation (virtual device);  see Devices \u203a Xbox 360 Controller</li> <li>\u2705 HID Keyboard with N-key rollover and LED feedback; see Devices \u203a Keyboard</li> <li>\u2705 HID Mouse with 5 buttons and horizontal/vertical wheel; see Devices \u203a Mouse</li> <li>\ud83d\udea7 Extensible architecture allows for more device types (other gamepads, specialized HID)</li> </ul> </li> <li>\u2705 USBIP server mode: expose virtual devices to remote clients</li> <li>\u2705 Proxy mode: forward real USB devices and inspect/record traffic</li> <li>\u2705 Cross-platform: works on Linux and Windows</li> <li>\u2705 Flexible logging (including raw USB packet logs)</li> <li>\u2705 API server for device/bus management and controlling virtual devices programmatically</li> <li>\u2705 Multiple client SDKs for easy integration; see Client SDKs</li> </ul>"},{"location":"mkdocs-readme/","title":"MkDocs Documentation","text":"<p>This directory contains the MkDocs-based documentation for VIIPER.</p>"},{"location":"mkdocs-readme/#setup","title":"Setup","text":"<p>Install MkDocs with Material theme:</p> <pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"mkdocs-readme/#development","title":"Development","text":"<p>Run the documentation server locally:</p> <pre><code>cd doc\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000/ in your browser.</p>"},{"location":"mkdocs-readme/#building","title":"Building","text":"<p>Build the static documentation site:</p> <pre><code>cd doc\nmkdocs build\n</code></pre> <p>The built site will be in the <code>site/</code> directory.</p>"},{"location":"mkdocs-readme/#deployment","title":"Deployment","text":"<p>Deploy to GitHub Pages:</p> <pre><code>cd doc\nmkdocs gh-deploy\n</code></pre>"},{"location":"mkdocs-readme/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - MkDocs configuration</li> <li><code>docs/</code> - Documentation source files (Markdown)<ul> <li><code>index.md</code> - Home page</li> <li><code>getting-started/</code> - Installation and quick start</li> <li><code>cli/</code> - CLI reference</li> <li><code>api/</code> - API reference</li> </ul> </li> </ul>"},{"location":"api/overview/","title":"API Reference","text":"<p>VIIPER ships a lightweight TCP API for managing virtual buses/devices and for device-specific streaming. It's designed to be trivial to drive from any language that can open a TCP socket and send newline-terminated commands.</p> <p>Client SDKs Available</p> <p>Generated client libraries are available that abstract away the protocol details described below. For most use cases, you should use one of the provided SDKs rather than implementing the raw protocol yourself:</p> <ul> <li>C SDK: Generated C library with type-safe device streams</li> <li>Go Client: Reference implementation included in the repository</li> <li>Generator Documentation: Information about code generation for additional languages</li> </ul> <p>The documentation below is provided for reference and for implementing clients in languages not yet supported by the generator.</p>"},{"location":"api/overview/#protocol-overview","title":"Protocol overview","text":"<ul> <li>Transport: TCP</li> <li>Default listen address: <code>:3242</code> (configurable via <code>--api.addr</code>)</li> <li>Request format: a single ASCII/UTF\u20118 line terminated by <code>\\n</code></li> <li>Routing: first token is the path (e.g. <code>bus/list</code>), remaining tokens are arguments (space-separated)</li> <li>Success response: a single line containing a JSON payload (or an empty line for commands that have no payload)</li> <li>Error response: a single line JSON object <code>{ \"error\": \"message\" }</code></li> </ul> <p>Tip: You can experiment with <code>nc</code>/<code>ncat</code> or PowerShell\u2019s <code>tcpclient</code> to send lines and read JSON back.</p> <p>Connection timing and auto\u2011cleanup</p> <p>After you add a device with <code>bus/{id}/add</code>, you must connect to its streaming endpoint within the configured <code>DeviceHandlerConnectTimeout</code> (default: 5s). If no stream connection is established in time, the device is automatically removed. Likewise, when a stream disconnects, a reconnection timer with the same timeout starts; if the client doesn\u2019t reconnect before it expires, the device is removed.</p>"},{"location":"api/overview/#commands","title":"Commands","text":"<p>The server registers the following commands and streams:</p> <ul> <li> <p><code>bus/list</code></p> <ul> <li>List all virtual bus IDs.</li> <li>Response: <code>{ \"buses\": [1, 2, ...] }</code></li> </ul> </li> <li> <p><code>bus/create [busId]</code></p> <ul> <li>Create a new bus. If <code>busId</code> is provided, VIIPER attempts to create the bus with that id; otherwise it picks the next free id.</li> <li>Response: <code>{ \"busId\": &lt;id&gt; }</code></li> </ul> </li> <li> <p><code>bus/remove &lt;busId&gt;</code></p> <ul> <li>Remove a bus and all devices on it.</li> <li>Response: <code>{ \"busId\": &lt;id&gt; }</code></li> </ul> </li> <li> <p><code>bus/{id}/list</code></p> <ul> <li>List devices on a bus.</li> <li>Response: <code>{ \"devices\": [{ \"busId\": 1, \"devId\": \"1\", \"vid\": \"0x045e\", \"pid\": \"0x028e\", \"type\": \"xbox360\" }, ...] }</code></li> </ul> </li> <li> <p><code>bus/{id}/add &lt;deviceType&gt;</code></p> <ul> <li>Add a device to a bus. <code>deviceType</code> is a registered device name (e.g., <code>xbox360</code>).</li> <li>Response: <code>{ \"id\": \"&lt;busId&gt;-&lt;devId&gt;\" }</code> where the id is the USBIP busid string you will attach to.</li> <li>Important: After add, the server starts a connect timer (default <code>5s</code>). You must open a device stream (see below) before the timeout expires, otherwise the device is auto-removed.</li> </ul> </li> <li> <p><code>bus/{id}/remove &lt;deviceId&gt;</code></p> <ul> <li>Remove a device by its device number on that bus (the part after the dash in the busid string).</li> <li>Response: <code>{ \"busId\": &lt;id&gt;, \"devId\": \"&lt;dev&gt;\" }</code></li> </ul> </li> </ul>"},{"location":"api/overview/#streaming-endpoint","title":"Streaming endpoint","text":"<ul> <li>Path: <code>bus/{busId}/{deviceid}</code></li> <li>Type: long-lived TCP connection (no line protocol once established)</li> <li>Purpose: device-specific, bidirectional stream. The API server hands the socket to the device\u2019s registered stream handler.</li> <li>Timeout behavior: When a stream ends, a reconnect timer is started (same <code>DeviceHandlerConnectTimeout</code>). If the client doesn\u2019t reconnect in time, the device is removed.</li> </ul>"},{"location":"api/overview/#xbox-360-controller-stream-device-type-xbox360","title":"Xbox 360 controller stream (device type: <code>xbox360</code>)","text":"<p>Direction: client \u279c server (input state)</p> <ul> <li>Fixed 14-byte packets, little-endian layout:<ul> <li><code>Buttons</code> uint32 (4 bytes)</li> <li><code>LT</code> uint8, <code>RT</code> uint8 (2 bytes)</li> <li><code>LX, LY, RX, RY</code> int16 each (8 bytes)</li> </ul> </li> </ul> <p>Direction: server \u279c client (rumble)</p> <ul> <li>Fixed 2-byte packets:<ul> <li><code>LeftMotor</code> uint8, <code>RightMotor</code> uint8</li> </ul> </li> </ul> <p>See <code>pkg/device/xbox360/protocol.go</code> for full details.</p>"},{"location":"api/overview/#hid-keyboard-stream-device-type-keyboard","title":"HID keyboard stream (device type: <code>keyboard</code>)","text":"<p>Direction: client \u279c server (keys pressed)</p> <ul> <li>Variable-length packets per frame:<ul> <li>Header: Modifiers uint8, KeyCount uint8</li> <li>Body: KeyCount bytes of HID Usage IDs for currently pressed (non-modifier) keys</li> </ul> </li> </ul> <p>Direction: server \u279c client (LED state)</p> <ul> <li>1-byte packets whenever host LED state changes:<ul> <li>Bit 0 NumLock, Bit 1 CapsLock, Bit 2 ScrollLock</li> </ul> </li> </ul> <p>Host-facing HID input report is 34 bytes: [Modifiers (1), Reserved (1), 256-bit key bitmap (32)].</p> <p>See <code>pkg/device/keyboard/</code> for helpers and constants.</p>"},{"location":"api/overview/#hid-mouse-stream-device-type-mouse","title":"HID mouse stream (device type: <code>mouse</code>)","text":"<p>Direction: client \u279c server (motion/buttons)</p> <ul> <li>Fixed 5-byte packets per frame:<ul> <li>Buttons uint8 (bits 0..4)</li> <li>dX int8, dY int8</li> <li>Wheel int8, Pan int8</li> </ul> </li> </ul> <p>Direction: server \u279c client</p> <ul> <li>None (mouse is input-only)</li> </ul> <p>Note: Motion and wheel deltas are consumed after each IN report so movement is relative.</p> <p>Note on protocol compatibility:</p> <ul> <li>The wire format is modeled after the XInput gamepad state (XINPUT_GAMEPAD) but is not byte\u2011for\u2011byte identical. Key differences:<ul> <li>Buttons are encoded as a 32\u2011bit little\u2011endian field (XInput uses a 16\u2011bit bitmask), making the packet 14 bytes instead of 12.</li> <li>No header or framing: packets are fixed\u2011length and back\u2011to\u2011back on the TCP stream.</li> <li>Endianness is little\u2011endian for all multi\u2011byte fields.</li> </ul> </li> </ul>"},{"location":"api/overview/#example-sessions","title":"Example sessions","text":""},{"location":"api/overview/#using-netcat-linuxmacos","title":"Using netcat (Linux/macOS)","text":"<pre><code># List buses\nprintf \"bus/list\\n\" | nc localhost 3242\n\n# Create a bus\nprintf \"bus/create\\n\" | nc localhost 3242\n# \u2192 {\"busId\":1}\n\n# Add a virtual Xbox 360 controller to bus 1\nprintf \"bus/1/add xbox360\\n\" | nc localhost 3242\n# \u2192 {\"id\":\"1-1\"}\n\n# List devices on bus 1\nprintf \"bus/1/list\\n\" | nc localhost 3242\n</code></pre> <p>Then, open a second TCP connection for streaming to <code>bus/1/1</code> (the API port, not the USBIP port). You\u2019ll write 14\u2011byte input packets and read 2\u2011byte rumble packets. Any language with raw TCP support works.</p>"},{"location":"api/overview/#windows-powershell","title":"WIndows (PowerShell)","text":"<p>VIIPER includes convenience scripts for quick testing and automation:</p> <pre><code># Source the script to load helper functions\n. .\\scripts\\viiper-api.ps1\n\n# Use the Invoke-ViiperApi function (or 'viiper' alias)\nviiper \"bus/list\"\nviiper \"bus/create\"\nviiper \"bus/1/add xbox360\" -Port 3242 -Hostname localhost\n</code></pre> <p>The script provides <code>Invoke-ViiperApi</code> (alias: <code>viiper</code>) for sending commands and <code>Connect-ViiperDevice</code> for testing persistent device connections.</p>"},{"location":"api/overview/#go-snippet-raw","title":"Go snippet (raw)","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"net\"\n)\n\nfunc main() {\n    conn, _ := net.Dial(\"tcp\", \"localhost:3242\")\n    defer conn.Close()\n    fmt.Fprintln(conn, \"bus/create\")\n    r := bufio.NewReader(conn)\n    line, _ := r.ReadString('\\n')\n    fmt.Println(line) // {\"busId\":1}\n}\n</code></pre> <p>For a higher-level experience, see the Go client in <code>pkg/apiclient/</code>.</p>"},{"location":"api/overview/#how-this-relates-to-usbip","title":"How this relates to USBIP","text":"<p>The API controls which virtual devices exist and exposes a device stream for live input/feedback. Separately, the USBIP server (default <code>:3241</code>) makes these devices attachable from clients. Typical flow:</p> <p>1) Create a bus \u279c 2) Add a device \u279c 3) Connect the device stream \u279c 4) From a client, attach using USBIP by <code>busid</code> (see the Server command page for exact <code>usbip</code> syntax).</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This section lists version-specific changelogs.</p> <ul> <li>Unreleased (main)</li> </ul>"},{"location":"changelog/main/","title":"Changelog for Development Version","text":"<p>This page shows unreleased changes in the development version.</p> <p>Changes since v0.0.2:</p>"},{"location":"changelog/main/#fixes","title":"\ud83d\udc1b Fixes","text":"<ul> <li>Fix client using incorrect path</li> </ul>"},{"location":"changelog/main/#miscellaneous","title":"\ud83d\udd27 Miscellaneous","text":"<ul> <li>Improve go api-client.</li> <li>Support file based configs</li> </ul>"},{"location":"cli/codegen/","title":"Code Generation Command","text":"<p>The <code>codegen</code> command generates type-safe client SDKs from Go source code annotations.</p>"},{"location":"cli/codegen/#usage","title":"Usage","text":"<pre><code>viiper codegen [flags]\n</code></pre>"},{"location":"cli/codegen/#description","title":"Description","text":"<p>Scans the VIIPER server codebase to extract: - API routes and response DTOs - Device wire formats from <code>viiper:wire</code> comment tags - Device constants (keycodes, modifiers, button masks)</p> <p>Then generates client SDKs for C, C#, and TypeScript with: - Management API clients - Device-agnostic stream wrappers - Per-device encode/decode functions - Typed constants and enums</p>"},{"location":"cli/codegen/#flags","title":"Flags","text":""},{"location":"cli/codegen/#-output","title":"<code>--output</code>","text":"<p>Output directory for generated SDKs (relative to repository root).</p> <p>Default: <code>../clients</code> Environment Variable: <code>VIIPER_CODEGEN_OUTPUT</code></p> <p>Example:</p> <pre><code>viiper codegen --output=../sdk-output\n</code></pre>"},{"location":"cli/codegen/#-lang","title":"<code>--lang</code>","text":"<p>Target language to generate.</p> <p>Values: <code>c</code>, <code>csharp</code>, <code>typescript</code>, <code>all</code> Default: <code>all</code> Environment Variable: <code>VIIPER_CODEGEN_LANG</code></p> <p>Examples:</p> <pre><code># Generate all SDKs\nviiper codegen --lang=all\n\n# Generate C SDK only\nviiper codegen --lang=c\n\n# Generate C# SDK only\nviiper codegen --lang=csharp\n\n# Generate TypeScript SDK only\nviiper codegen --lang=typescript\n</code></pre>"},{"location":"cli/codegen/#output-structure","title":"Output Structure","text":"<p>Generated files are organized by language:</p> <pre><code>clients/\n\u251c\u2500\u2500 c/\n\u2502   \u251c\u2500\u2500 include/viiper/\n\u2502   \u2502   \u251c\u2500\u2500 viiper.h\n\u2502   \u2502   \u251c\u2500\u2500 viiper_keyboard.h\n\u2502   \u2502   \u251c\u2500\u2500 viiper_mouse.h\n\u2502   \u2502   \u2514\u2500\u2500 viiper_xbox360.h\n\u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 viiper.c\n\u2502   \u2502   \u251c\u2500\u2500 viiper_keyboard.c\n\u2502   \u2502   \u251c\u2500\u2500 viiper_mouse.c\n\u2502   \u2502   \u2514\u2500\u2500 viiper_xbox360.c\n\u2502   \u2514\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 csharp/\n\u2502   \u2514\u2500\u2500 Viiper.Client/\n\u2502       \u2514\u2500\u2500 (generated C# files)\n\u2514\u2500\u2500 ts/\n    \u2514\u2500\u2500 viiperclient/\n        \u2514\u2500\u2500 (generated TypeScript files)\n</code></pre>"},{"location":"cli/codegen/#examples","title":"Examples","text":""},{"location":"cli/codegen/#generate-all-sdks","title":"Generate All SDKs","text":"<pre><code>cd viiper\ngo run ./cmd/viiper codegen\n</code></pre>"},{"location":"cli/codegen/#generate-c-sdk-and-rebuild-examples","title":"Generate C SDK and Rebuild Examples","text":"<pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=c\ncd ../examples/c\ncmake --build build --config Release\n</code></pre>"},{"location":"cli/codegen/#cicd-integration","title":"CI/CD Integration","text":"<pre><code>- name: Generate Client SDKs\n  run: |\n    cd viiper\n    go run ./cmd/viiper codegen --lang=all\n</code></pre>"},{"location":"cli/codegen/#when-to-regenerate","title":"When to Regenerate","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>pkg/apitypes/*.go</code>: API response structures</li> <li><code>pkg/device/*/inputstate.go</code>: Wire format annotations</li> <li><code>pkg/device/*/const.go</code>: Exported constants</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li>Generator templates in <code>internal/codegen/generator/</code></li> </ul>"},{"location":"cli/codegen/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: Detailed explanation of tagging system and code generation flow</li> <li>C SDK Documentation: C-specific usage and build instructions</li> <li>Configuration: Global configuration options</li> </ul>"},{"location":"cli/configuration/","title":"Configuration","text":"<p>VIIPER can be configured via:</p> <ul> <li>Command-line flags</li> <li>Environment variables</li> <li>Configuration files (JSON/YAML/TOML)</li> </ul>"},{"location":"cli/configuration/#environment-variables","title":"Environment Variables","text":"<p>All command-line flags have corresponding environment variables for easier deployment and configuration management.</p>"},{"location":"cli/configuration/#global-configuration","title":"Global Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_LOG_LEVEL</code> <code>--log.level</code> <code>info</code> Logging level: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> <code>VIIPER_LOG_FILE</code> <code>--log.file</code> (none) Log file path (logs only to console if not set) <code>VIIPER_LOG_RAW_FILE</code> <code>--log.raw-file</code> (none) Raw packet log file path"},{"location":"cli/configuration/#server-configuration","title":"Server Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_USB_ADDR</code> <code>--usb.addr</code> <code>:3241</code> USBIP server listen address <code>VIIPER_API_ADDR</code> <code>--api.addr</code> <code>:3242</code> API server listen address (empty = disabled) <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code> <code>--api.device-handler-timeout</code> <code>5s</code> Device handler auto-cleanup timeout <code>VIIPER_CONNECTION_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection operation timeout"},{"location":"cli/configuration/#proxy-configuration","title":"Proxy Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_PROXY_ADDR</code> <code>--listen-addr</code> <code>:3241</code> Proxy listen address <code>VIIPER_PROXY_UPSTREAM</code> <code>--upstream</code> (required) Upstream USBIP server address <code>VIIPER_PROXY_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection timeout"},{"location":"cli/configuration/#configuration-files","title":"Configuration Files","text":"<p>VIIPER supports JSON, YAML, and TOML configuration files. Generate a starter file with:</p> <pre><code>viiper config init server --format=json   # or yaml|toml\n</code></pre> <p>If no output path is provided, the file is written to the current working directory (e.g., server.json, proxy.yaml).</p> <p>You can also specify a custom location:</p> <pre><code>viiper config init server --format=json --output ./server.json\n</code></pre> <p>To use a specific configuration file when starting VIIPER, pass the --config flag (or set VIIPER_CONFIG):</p> <pre><code>viiper --config ./server.json server\n</code></pre> <p>If --config is not provided, VIIPER will search for configuration in this order and first-found is used for each format:</p> <ol> <li>Working directory: server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), viiper.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Platform config directory (see above): server.(json|yaml|yml|toml), proxy.(json|yaml|yml|toml), config.(json|yaml|yml|toml)</li> <li>Linux system-wide: /etc/viiper/server.(json|yaml|yml|toml), /etc/viiper/proxy.(json|yaml|yml|toml), /etc/viiper/config.(json|yaml|yml|toml)</li> </ol> <p>Example JSON configurations:</p> <p>Server:</p> <pre><code>{\n  \"api\": {\n    \"addr\": \":3242\",\n    \"device-handler-connect-timeout\": \"5s\"\n  },\n  \"usb\": {\n    \"addr\": \":3241\"\n  },\n  \"connection-timeout\": \"30s\"\n}\n</code></pre> <p>Proxy:</p> <pre><code>{\n  \"listen-addr\": \":3241\",\n  \"upstream-addr\": \"127.0.0.1:3242\",\n  \"connection-timeout\": \"30s\"\n}\n</code></pre> <p>Notes:</p> <ul> <li>The configuration file never contains secrets; environment variables or external secret stores are recommended for sensitive values.</li> </ul>"},{"location":"cli/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"cli/configuration/#using-environment-variables","title":"Using Environment Variables","text":"<p>Create a <code>.env</code> file or export variables:</p> <pre><code>export VIIPER_LOG_LEVEL=debug\nexport VIIPER_USB_ADDR=:3241\nexport VIIPER_API_ADDR=:3242\nexport VIIPER_LOG_FILE=/var/log/viiper.log\n</code></pre> <p>Then run:</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/configuration/#systemd-service","title":"Systemd Service","text":"<p>Example systemd service file for running VIIPER as a service:</p> <pre><code>[Unit]\nDescription=VIIPER USBIP Server\nAfter=network.target\n\n[Service]\nType=simple\nUser=viiper\nGroup=viiper\nEnvironment=\"VIIPER_LOG_LEVEL=info\"\nEnvironment=\"VIIPER_LOG_FILE=/var/log/viiper/viiper.log\"\nEnvironment=\"VIIPER_USB_ADDR=:3241\"\nEnvironment=\"VIIPER_API_ADDR=:3242\"\nExecStart=/usr/local/bin/viiper server\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"cli/configuration/#configuration-priority","title":"Configuration Priority","text":"<p>When both CLI flags and environment variables are set, CLI flags take precedence:</p> <ol> <li>CLI flags (highest priority)</li> <li>Environment variables</li> <li>Configuration file values</li> <li>Default values (lowest priority)</li> </ol>"},{"location":"cli/configuration/#see-also","title":"See Also","text":"<ul> <li>Server Command</li> <li>Proxy Command</li> </ul>"},{"location":"cli/overview/","title":"CLI Overview","text":"<p>VIIPER provides a command-line interface for running the USBIP server and proxy.</p>"},{"location":"cli/overview/#commands","title":"Commands","text":"<ul> <li><code>server</code> - Start the VIIPER USBIP server</li> <li><code>proxy</code> - Start the VIIPER USBIP proxy</li> <li><code>codegen</code> - Generate client SDKs from source code annotations</li> </ul>"},{"location":"cli/overview/#global-options","title":"Global Options","text":""},{"location":"cli/overview/#logging","title":"Logging","text":"<p>VIIPER supports flexible logging configuration via global flags or environment variables.</p>"},{"location":"cli/overview/#-loglevel","title":"<code>--log.level</code>","text":"<p>Set the logging level.</p> <p>Values: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> Default: <code>info</code> Environment Variable: <code>VIIPER_LOG_LEVEL</code></p> <p>Example:</p> <pre><code>viiper server --log.level=debug\n</code></pre>"},{"location":"cli/overview/#-logfile","title":"<code>--log.file</code>","text":"<p>Log to a file in addition to console output.</p> <p>Default: (none - logs only to console) Environment Variable: <code>VIIPER_LOG_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/overview/#-lograw-file","title":"<code>--log.raw-file</code>","text":"<p>Log raw USB packet data to a file for debugging and reverse engineering.</p> <p>Default: (none) Environment Variable: <code>VIIPER_LOG_RAW_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre> <p>Automatic Raw Logging</p> <p>When <code>--log.level=trace</code> is set without <code>--log.raw-file</code>, raw packets are logged to stdout.</p>"},{"location":"cli/overview/#getting-help","title":"Getting Help","text":"<p>Display help for any command:</p> <pre><code>viiper --help\nviiper server --help\nviiper proxy --help\n</code></pre>"},{"location":"cli/proxy/","title":"Proxy Command","text":"<p>Start the VIIPER USBIP proxy for traffic inspection and logging.</p>"},{"location":"cli/proxy/#usage","title":"Usage","text":"<pre><code>viiper proxy --upstream=&lt;address&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/proxy/#description","title":"Description","text":"<p>The <code>proxy</code> command starts VIIPER in proxy mode, sitting between a USBIP client and a USBIP server. VIIPER intercepts and logs all USB traffic passing through, without handling the devices directly.</p> <p>This is useful for reverse engineering USB protocols and understanding how devices communicate.</p>"},{"location":"cli/proxy/#options","title":"Options","text":""},{"location":"cli/proxy/#-listen-addr","title":"<code>--listen-addr</code>","text":"<p>Proxy listen address (where clients connect).</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_PROXY_ADDR</code></p> <p>Example:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3241\n</code></pre>"},{"location":"cli/proxy/#-upstream","title":"<code>--upstream</code>","text":"<p>Required. Upstream USBIP server address (where real devices are).</p> <p>Environment Variable: <code>VIIPER_PROXY_UPSTREAM</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241\n</code></pre>"},{"location":"cli/proxy/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection timeout for proxy operations.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_PROXY_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241 --connection-timeout=60s\n</code></pre>"},{"location":"cli/proxy/#examples","title":"Examples","text":""},{"location":"cli/proxy/#basic-proxy","title":"Basic Proxy","text":"<p>Start proxy between local clients and remote USBIP server:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241\n</code></pre> <p>Clients connect to <code>localhost:3241</code>, traffic is proxied to <code>192.168.1.100:3241</code>.</p>"},{"location":"cli/proxy/#custom-listen-address","title":"Custom Listen Address","text":"<p>Start proxy on a different port:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3241\n</code></pre> <p>Clients connect to <code>localhost:9000</code>, traffic is proxied to <code>192.168.1.100:3241</code>.</p>"},{"location":"cli/proxy/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Capture all USB traffic for reverse engineering:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241 --log.raw-file=usb-capture.log\n</code></pre> <p>All USB packets will be logged to <code>usb-capture.log</code>.</p>"},{"location":"cli/proxy/#with-debug-logging","title":"With Debug Logging","text":"<p>Enable debug logging to see proxy operations:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241 --log.level=debug\n</code></pre>"},{"location":"cli/proxy/#use-cases","title":"Use Cases","text":""},{"location":"cli/proxy/#reverse-engineering","title":"Reverse Engineering","text":"<p>Intercept USB traffic between a client and server to understand device protocols:</p> <pre><code>viiper proxy --upstream=real-server:3241 --log.raw-file=device-capture.log\n</code></pre>"},{"location":"cli/proxy/#traffic-analysis","title":"Traffic Analysis","text":"<p>Monitor USB communication for debugging:</p> <pre><code>viiper proxy --upstream=real-server:3241 --log.level=trace\n</code></pre>"},{"location":"cli/proxy/#network-inspection","title":"Network Inspection","text":"<p>Route USB traffic through VIIPER to inspect and log all operations:</p> <pre><code>viiper proxy --upstream=real-server:3241 --log.level=debug --log.raw-file=traffic.log\n</code></pre>"},{"location":"cli/proxy/#proxy-architecture","title":"Proxy Architecture","text":"<pre><code>USBIP Client  \u2192  VIIPER Proxy  \u2192  USBIP Server (real devices)\n                      \u2193\n              Logs/Captures Traffic\n</code></pre> <p>VIIPER sits in the middle, forwarding all traffic while logging packets for inspection.</p>"},{"location":"cli/proxy/#see-also","title":"See Also","text":"<ul> <li>Server Command - Run VIIPER as a USBIP server</li> <li>Configuration - Environment variables and configuration files</li> </ul>"},{"location":"cli/server/","title":"Server Command","text":"<p>Start the VIIPER USBIP server to expose virtual devices.</p>"},{"location":"cli/server/#usage","title":"Usage","text":"<pre><code>viiper server [OPTIONS]\n</code></pre>"},{"location":"cli/server/#description","title":"Description","text":"<p>The <code>server</code> command starts the VIIPER USBIP server, which allows you to create and manage virtual USB devices that appear as real hardware to USBIP clients.</p> <p>The server exposes two interfaces:</p> <ol> <li>USBIP Server - Standard USBIP protocol for device attachment</li> <li>API Server (optional) - Management API for device/bus control</li> </ol>"},{"location":"cli/server/#options","title":"Options","text":""},{"location":"cli/server/#-usbaddr","title":"<code>--usb.addr</code>","text":"<p>USBIP server listen address.</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_USB_ADDR</code></p> <p>Example:</p> <pre><code>viiper server --usb.addr=0.0.0.0:3241\n</code></pre>"},{"location":"cli/server/#-apiaddr","title":"<code>--api.addr</code>","text":"<p>API server listen address. If empty, the API server is disabled.</p> <p>Default: <code>:3242</code> Environment Variable: <code>VIIPER_API_ADDR</code></p> <p>Example:</p> <pre><code># Enable API on custom port\nviiper server --api.addr=:8080\n\n# Disable API server\nviiper server --api.addr=\n</code></pre>"},{"location":"cli/server/#-apidevice-handler-timeout","title":"<code>--api.device-handler-timeout</code>","text":"<p>Time before auto-cleanup occurs when a device handler has no active connection.</p> <p>Default: <code>5s</code> Environment Variable: <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --api.device-handler-timeout=10s\n</code></pre>"},{"location":"cli/server/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection operation timeout for both USBIP and API servers.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_CONNECTION_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --connection-timeout=60s\n</code></pre>"},{"location":"cli/server/#examples","title":"Examples","text":""},{"location":"cli/server/#basic-server","title":"Basic Server","text":"<p>Start server with default settings (USBIP on :3241, API on :3242):</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/server/#server-without-api","title":"Server Without API","text":"<p>Start only the USBIP server (no API):</p> <pre><code>viiper server --api.addr=\n</code></pre>"},{"location":"cli/server/#custom-addresses","title":"Custom Addresses","text":"<p>Start server on custom ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre>"},{"location":"cli/server/#with-logging","title":"With Logging","text":"<p>Start server with debug logging to file:</p> <pre><code>viiper server --log.level=debug --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/server/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Start server with raw USB packet logging (useful for reverse engineering):</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre>"},{"location":"cli/server/#connect-from-a-client-usbip","title":"Connect from a client (USBIP)","text":"<p>After the server is running and a virtual device has been added to a bus (via the API), attach it from a client using USBIP.</p> <p>Notes: - VIIPER's USBIP server listens on <code>:3241</code> by default (configurable via <code>--usb.addr</code>). - The BUSID-DEVICEID you need (e.g. <code>1-1</code>) is returned by the API on device add and also visible via <code>usbip list</code>.</p>"},{"location":"cli/server/#linux","title":"Linux","text":"<pre><code># Load the virtual host controller (only needed once per boot)\nsudo modprobe vhci-hcd\n\n# List exportable devices on the VIIPER host\nusbip list --remote=VIIPER_HOST --tcp-port=3241\n\n# Attach a device by busid (long flags)\nsudo usbip attach --remote=VIIPER_HOST --tcp-port=3241 --busid=BUSID-DEVICEID\n\n# Equivalent short-form flags\nsudo usbip --tcp-port 3241 -r VIIPER_HOST -b BUSID-DEVICEID\n</code></pre> <p>Replace <code>VIIPER_HOST</code> with the server's hostname/IP. If you changed the USBIP port, use that port instead of <code>3241</code>.</p>"},{"location":"cli/server/#windows","title":"Windows","text":"<p>On Windows, use usbip-win2:</p> <ul> <li>GUI: use the client to add a remote host and attach by busid.</li> <li>CLI (similar flags):</li> </ul> <pre><code>usbip.exe list --remote VIIPER_HOST --tcp-port 3241\nusbip.exe attach --remote VIIPER_HOST --tcp-port 3241 --busid BUSID-DEVICEID\n</code></pre> <p>Once attached, the device will appear to the OS/applications as a local USB device.</p>"},{"location":"cli/server/#see-also","title":"See Also","text":"<ul> <li>Configuration - Environment variables and configuration files</li> <li>API Reference - API server documentation</li> </ul>"},{"location":"clients/c/","title":"C SDK Documentation","text":"<p>The VIIPER C SDK provides a lightweight, dependency-free client library for interacting with VIIPER servers and controlling virtual devices.</p>"},{"location":"clients/c/#overview","title":"Overview","text":"<p>The C SDK features:</p> <ul> <li>Device-agnostic streaming API: Uniform interface for all device types</li> <li>Zero dependencies: Pure C99, no external libraries required</li> <li>Cross-platform: Windows (MSVC) and POSIX (GCC/Clang)</li> <li>Type-safe: Generated headers with packed structs and constants</li> <li>Thread-safe: Recommended: one <code>viiper_client_t</code> per thread</li> </ul> <p>License</p> <p>The C SDK is licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/c/#installation","title":"Installation","text":""},{"location":"clients/c/#building-from-source","title":"Building from Source","text":"<p>The C SDK is generated from the VIIPER server codebase:</p> <pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=c\n</code></pre> <p>Build the SDK:</p> <pre><code>cd ../clients/c\ncmake -B build -G \"Visual Studio 17 2022\"  # Windows\ncmake -B build                              # POSIX\ncmake --build build --config Release\n</code></pre>"},{"location":"clients/c/#linking-to-your-project","title":"Linking to Your Project","text":"<p>CMake:</p> <pre><code># Add viiper SDK\nadd_subdirectory(path/to/clients/c)\ntarget_link_libraries(your_target PRIVATE viiper)\n\n# Copy DLL on Windows (post-build)\nif(WIN32)\n    add_custom_command(TARGET your_target POST_BUILD\n        COMMAND ${CMAKE_COMMAND} -E copy_if_different\n        $&lt;TARGET_FILE:viiper&gt;\n        $&lt;TARGET_FILE_DIR:your_target&gt;\n    )\nendif()\n</code></pre> <p>Manual:</p> <ul> <li>Include: <code>clients/c/include/viiper/viiper.h</code></li> <li>Link: <code>clients/c/build/Release/viiper.lib</code> (Windows) or <code>libviiper.a</code> (POSIX)</li> <li>Runtime: Copy <code>viiper.dll</code> next to your executable (Windows)</li> </ul>"},{"location":"clients/c/#quick-start","title":"Quick Start","text":"<pre><code>#include &lt;viiper/viiper.h&gt;\n#include &lt;viiper/viiper_keyboard.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Connect to management API\n    viiper_client_t* client = NULL;\n    int err = viiper_client_create(\"127.0.0.1\", 3242, &amp;client);\n    if (err != 0) {\n        fprintf(stderr, \"Failed to connect: %s\\n\", viiper_strerror(err));\n        return 1;\n    }\n\n    // Create or find a bus\n    viiper_bus_list_t buses = {0};\n    err = viiper_bus_list(client, &amp;buses);\n    uint32_t bus_id = (buses.count &gt; 0) ? buses.buses[0] : 0;\n\n    if (bus_id == 0) {\n        viiper_bus_create_response_t resp = {0};\n        err = viiper_bus_create(client, 1, &amp;resp);\n        bus_id = resp.bus_id;\n    }\n\n    // Add device\n    viiper_device_add_response_t dev_resp = {0};\n    err = viiper_device_add(client, bus_id, \"keyboard\", &amp;dev_resp);\n\n    // Open device stream\n    viiper_device_t* device = NULL;\n    err = viiper_device_create(client, bus_id, dev_resp.id, &amp;device);\n\n    // Send keyboard input\n    viiper_keyboard_input_t input = {\n        .modifiers = 0,\n        .count = 1\n    };\n    uint8_t keys[] = {VIIPER_KEYBOARD_KEYA};\n    input.keys = keys;\n    input.keys_count = 1;\n\n    err = viiper_device_send(device, &amp;input, sizeof(input.modifiers) + sizeof(input.count) + input.keys_count);\n\n    // Cleanup\n    viiper_device_close(device);\n    viiper_device_remove(client, bus_id, dev_resp.id);\n    viiper_client_destroy(client);\n    return 0;\n}\n</code></pre>"},{"location":"clients/c/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/c/#creating-a-device-stream","title":"Creating a Device Stream","text":"<pre><code>viiper_device_t* device = NULL;\nint err = viiper_device_create(client, bus_id, device_id, &amp;device);\nif (err != 0) {\n    fprintf(stderr, \"Failed to open device stream: %s\\n\", viiper_strerror(err));\n}\n</code></pre>"},{"location":"clients/c/#sending-input","title":"Sending Input","text":"<pre><code>viiper_mouse_input_t input = {\n    .buttons = VIIPER_MOUSE_BTN_LEFT,\n    .dx = 10,\n    .dy = -5,\n    .wheel = 0,\n    .pan = 0\n};\n\nint err = viiper_device_send(device, &amp;input, sizeof(input));\n</code></pre>"},{"location":"clients/c/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<pre><code>void on_led_update(void* user_data, const void* data, size_t len) {\n    if (len &lt; 1) return;\n    uint8_t leds = ((uint8_t*)data)[0];\n    printf(\"LEDs: NumLock=%d CapsLock=%d ScrollLock=%d\\n\",\n           !!(leds &amp; VIIPER_KEYBOARD_LEDNUMLOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LEDCAPSLOCK),\n           !!(leds &amp; VIIPER_KEYBOARD_LEDSCROLLLOCK));\n}\n\nviiper_device_on_output(device, on_led_update, NULL);\n</code></pre>"},{"location":"clients/c/#closing-a-stream","title":"Closing a Stream","text":"<pre><code>viiper_device_close(device);\n</code></pre>"},{"location":"clients/c/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific packet formats, constants, and wire protocols. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The C SDK provides generated structs and constants in device-specific headers (e.g., <code>viiper_keyboard.h</code>, <code>viiper_mouse.h</code>, <code>viiper_xbox360.h</code>).</p>"},{"location":"clients/c/#struct-packing","title":"Struct Packing","text":"<p>All device I/O structs use <code>#pragma pack(1)</code> to ensure wire compatibility (no padding).</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t buttons;\n    int8_t dx;\n    // ...\n} viiper_mouse_input_t;\n#pragma pack(pop)\n</code></pre> <p>Important: Always ensure your compiler respects packing directives. MSVC and GCC/Clang handle this correctly by default.</p>"},{"location":"clients/c/#troubleshooting","title":"Troubleshooting","text":""},{"location":"clients/c/#missing-dll-on-windows","title":"Missing DLL on Windows","text":"<p>Symptom: Application crashes immediately with \"viiper.dll not found\"</p> <p>Solution: Copy <code>viiper.dll</code> to the same directory as your executable:</p> <pre><code>add_custom_command(TARGET your_target POST_BUILD\n    COMMAND ${CMAKE_COMMAND} -E copy_if_different\n    $&lt;TARGET_FILE:viiper&gt;\n    $&lt;TARGET_FILE_DIR:your_target&gt;\n)\n</code></pre>"},{"location":"clients/c/#repeated-keys-not-working","title":"Repeated Keys Not Working","text":"<p>Symptom: Typing \"Hello\" outputs \"Helo\" (missing duplicate letter)</p> <p>Solution: Add sufficient delays between key press, release, and next action:</p> <pre><code>press_and_release(dev, VIIPER_KEYBOARD_KEYL, 0);\nSleep(100);\npress_and_release(dev, VIIPER_KEYBOARD_KEYL, 0);\n</code></pre>"},{"location":"clients/c/#struct-padding-issues","title":"Struct Padding Issues","text":"<p>Symptom: Device input is corrupted or \"spazzing\"</p> <p>Solution: Verify <code>#pragma pack(1)</code> is applied to device structs. All generated headers include this by default.</p>"},{"location":"clients/c/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Keyboard: <code>examples/c/virtual_keyboard/main.c</code></li> <li>Types \"Hello!\" every 5 seconds</li> <li> <p>Reads LED state (NumLock, CapsLock, ScrollLock)</p> </li> <li> <p>Virtual Xbox360 Controller: <code>examples/c/virtual_x360_pad/main.c</code></p> </li> <li>Simulates button presses and stick movements</li> <li>Receives rumble feedback</li> </ul> <p>Build and run:</p> <pre><code>cd examples/c\ncmake -B build -G \"Visual Studio 17 2022\"\ncmake --build build --config Release\n./build/Release/virtual_keyboard.exe 127.0.0.1:3242\n</code></pre>"},{"location":"clients/c/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How the C SDK is generated</li> <li>Go Client Documentation: Reference implementation</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"clients/generator/","title":"VIIPER Client Generator Documentation","text":""},{"location":"clients/generator/#overview","title":"Overview","text":"<p>The VIIPER client generator scans Go source code to extract API routes, device wire formats, and constants; then emits type-safe client SDKs for multiple languages.</p> <p>What it extracts:</p> <ul> <li>API routes and DTOs from management API handlers  </li> <li>Device wire formats from <code>viiper:wire</code> comment tags  </li> <li>All exported constants from device packages (automatic)</li> </ul> <p>Output: Type-safe client SDKs for multiple target languages</p> <p>License</p> <p>All generated client SDKs are licensed under the MIT License, providing maximum flexibility for integration into your projects. The core VIIPER server remains under its original license.</p>"},{"location":"clients/generator/#running-the-generator","title":"Running the Generator","text":"<pre><code>cd viiper\ngo run ./cmd/viiper codegen --lang=all     # Generate all SDKs\ngo run ./cmd/viiper codegen --lang=c       # Generate C SDK only\ngo run ./cmd/viiper codegen --lang=csharp  # Generate C# SDK only\ngo run ./cmd/viiper codegen --lang=typescript # Generate TypeScript SDK only\n</code></pre> <p>Output directory: <code>clients/</code> (relative to repository root)</p>"},{"location":"clients/generator/#comment-tag-system","title":"Comment Tag System","text":"<p>The generator uses lightweight comment tags placed next to device types and constants.</p>"},{"location":"clients/generator/#viiperwire-device-stream-formats","title":"<code>viiper:wire</code>: Device Stream Formats","text":"<p>Syntax:</p> <pre><code>// viiper:wire &lt;device&gt; &lt;direction&gt; &lt;field1:type&gt; &lt;field2:type&gt; ...\n</code></pre> <p>Directions: </p> <ul> <li><code>c2s</code>: Client to server (input)  </li> <li><code>s2c</code>: Server to client (output, e.g., rumble, LEDs)</li> </ul> <p>Field types: </p> <ul> <li>Fixed: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code> </li> <li>Variable: <code>u8*countField</code> (pointer to count field)</li> </ul> <p>Example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct { ... }\n</code></pre>"},{"location":"clients/generator/#constant-export","title":"Constant Export","text":"<p>The generator automatically exports all constants from <code>pkg/device/*/const.go</code> for each device type. No special tags are required. Exported Go constants are emitted with language-appropriate representations and prefixes.</p>"},{"location":"clients/generator/#code-generation-flow","title":"Code Generation Flow","text":"<p>Scan Phase: </p> <ol> <li>Parse API routes from <code>internal/server/api/*.go</code> </li> <li>Reflect response DTOs from <code>pkg/apitypes/*.go</code> </li> <li>Find device types via <code>RegisterDevice()</code> calls  </li> <li>Parse <code>viiper:wire</code> comments for packet layouts  </li> <li>Extract all exported constants from <code>pkg/device/*/const.go</code> (automatic)</li> </ol> <p>Emit Phase: For each language, generate management client, DTO types, device streams, constants, and build configs.</p> <p>Post-Process: Optional formatting with <code>clang-format</code>, <code>dotnet format</code>, or <code>prettier</code>.</p>"},{"location":"clients/generator/#wire-format-mapping-rules","title":"Wire Format Mapping Rules","text":""},{"location":"clients/generator/#fixed-size-fields","title":"Fixed-Size Fields","text":"<p>Fixed-size fields are mapped to native integer types in each target language:</p> <ul> <li><code>u8</code> / <code>i8</code>: 8-bit unsigned/signed integers</li> <li><code>u16</code> / <code>i16</code>: 16-bit unsigned/signed integers</li> <li><code>u32</code> / <code>i32</code>: 32-bit unsigned/signed integers</li> </ul>"},{"location":"clients/generator/#variable-length-fields","title":"Variable-Length Fields","text":"<p>Variable-length arrays use a pointer + count pattern. The field syntax <code>u8*count</code> references a count field that determines the array length.</p> <p>Wire tag example:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\n</code></pre> <p>Each target language emits appropriate types for dynamic arrays (pointers with counts, managed arrays, or typed arrays depending on the language).</p>"},{"location":"clients/generator/#struct-packing","title":"Struct Packing","text":"<p>For wire compatibility, all device I/O structs are tightly packed (no padding).</p> <ul> <li>C: <code>#pragma pack(push, 1)</code> / <code>#pragma pack(pop)</code></li> <li>C#: <code>[StructLayout(LayoutKind.Sequential, Pack = 1)]</code></li> <li>TypeScript: Manual byte-level encoding/decoding</li> </ul>"},{"location":"clients/generator/#example-keyboard-input-variable-length","title":"Example: Keyboard Input (Variable-Length)","text":"<p>Go source with wire tag:</p> <pre><code>// viiper:wire keyboard c2s modifiers:u8 count:u8 keys:u8*count\ntype InputState struct {\n    Modifiers uint8\n    KeyBitmap [32]uint8  // Internal: 256-bit NKR bitmap\n}\n</code></pre> <p>Emitted C struct:</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    uint8_t modifiers;\n    uint8_t count;\n    uint8_t* keys;\n    size_t keys_count;\n} viiper_keyboard_input_t;\n#pragma pack(pop)\n</code></pre>"},{"location":"clients/generator/#example-constant-export","title":"Example: Constant Export","text":"<p>Go source (<code>pkg/device/keyboard/const.go</code>):</p> <pre><code>const (\n    ModLeftCtrl  = 0x01\n    ModLeftShift = 0x02\n    KeyA = 0x04\n    KeyB = 0x05\n    // ...\n)\n</code></pre> <p>Emitted C header (<code>viiper_keyboard.h</code>):</p> <pre><code>#define VIIPER_KEYBOARD_MODLEFTCTRL 0x1\n#define VIIPER_KEYBOARD_MODLEFTSHIFT 0x2\n#define VIIPER_KEYBOARD_KEYA 0x4\n#define VIIPER_KEYBOARD_KEYB 0x5\n// ...\n</code></pre>"},{"location":"clients/generator/#regeneration-triggers","title":"Regeneration Triggers","text":"<p>Run codegen when any of these change:</p> <ul> <li><code>pkg/apitypes/*.go</code>: API response structures</li> <li><code>pkg/device/*/inputstate.go</code>: Wire tag annotations</li> <li><code>pkg/device/*/const.go</code>: Exported constants</li> <li><code>internal/server/api/*.go</code>: Route registrations</li> <li><code>internal/codegen/generator/**/*.go</code>: Generator templates</li> </ul>"},{"location":"clients/generator/#language-specific-notes","title":"Language-Specific Notes","text":"<ul> <li>C: manual memory management for variable-length fields; builds with CMake.  </li> <li>C#: <code>ViiperDevice</code> class with <code>OnOutput</code> event; async/await for management API; struct packing via attributes.  </li> <li>TypeScript: manual byte encoding; ESM/CJS compatible.  </li> </ul>"},{"location":"clients/generator/#current-sdk-status","title":"Current SDK Status","text":"<ul> <li>C: \u2705 Complete</li> <li>C#: \ud83d\udea7 Planned</li> <li>TypeScript: \ud83d\udea7 Planned</li> </ul>"},{"location":"clients/generator/#further-reading","title":"Further Reading","text":"<ul> <li>Design Document: Architectural rationale and detailed generation strategy</li> <li>C SDK Documentation: C-specific usage, build, and examples</li> <li>Go Client Documentation: Go reference client usage</li> </ul> <p>For questions or contributions, see the main VIIPER repository.</p>"},{"location":"clients/go/","title":"Go Client Documentation","text":"<p>The Go client is the reference implementation for interacting with VIIPER servers. It's included in the repository under <code>pkg/apiclient</code> and <code>pkg/device</code>.</p>"},{"location":"clients/go/#overview","title":"Overview","text":"<p>The Go client features:</p> <ul> <li>Type-safe API: Structured request/response types with context support</li> <li>Device streams: Bidirectional communication using <code>encoding.BinaryMarshaler</code>/<code>BinaryUnmarshaler</code></li> <li>Built-in: No code generation needed; part of the main repository</li> <li>Flexible timeouts: Configurable connection and I/O timeouts</li> </ul>"},{"location":"clients/go/#quick-start","title":"Quick Start","text":"<pre><code>package main\n\nimport (\n  \"context\"\n  \"log\"\n  \"time\"\n\n  apiclient \"viiper/pkg/apiclient\"\n  \"viiper/pkg/device/keyboard\"\n)\n\nfunc main() {\n  // Connect to management API\n  client := apiclient.New(\"127.0.0.1:3242\")\n  ctx := context.Background()\n\n  // Create or find a bus\n  buses, err := client.BusList()\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  var busID uint32\n  if len(buses) &gt; 0 {\n    busID = buses[0]\n  } else {\n    resp, err := client.BusCreate(nil)\n    if err != nil {\n      log.Fatal(err)\n    }\n    busID = resp.BusID\n  }\n\n  // Add device and connect\n  stream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"keyboard\")\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer stream.Close()\n\n  log.Printf(\"Connected to device %s\", resp.ID)\n\n  // Send keyboard input\n  input := &amp;keyboard.InputState{\n    Modifiers: keyboard.ModLeftShift,\n  }\n  input.SetKey(keyboard.KeyH, true)\n\n  if err := stream.WriteBinary(input); err != nil {\n    log.Fatal(err)\n  }\n\n  time.Sleep(100 * time.Millisecond)\n\n  // Release\n  input = &amp;keyboard.InputState{}\n  stream.WriteBinary(input)\n}\n</code></pre>"},{"location":"clients/go/#device-stream-api","title":"Device Stream API","text":""},{"location":"clients/go/#creating-and-connecting","title":"Creating and Connecting","text":"<p>The simplest way to add a device and open its stream:</p> <pre><code>stream, resp, err := client.AddDeviceAndConnect(ctx, busID, \"xbox360\")\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream.Close()\n\nlog.Printf(\"Connected to device %s\", resp.ID)\n</code></pre> <p>Or connect to an existing device:</p> <pre><code>stream, err := client.OpenStream(ctx, busID, deviceID)\nif err != nil {\n  log.Fatal(err)\n}\ndefer stream.Close()\n</code></pre>"},{"location":"clients/go/#sending-input","title":"Sending Input","text":"<p>Device input is sent using structs that implement <code>encoding.BinaryMarshaler</code>:</p> <pre><code>import \"viiper/pkg/device/xbox360\"\n\ninput := &amp;xbox360.InputState{\n  Buttons: xbox360.ButtonA,\n  LX:      -32768, // Left stick left\n  LY:      32767,  // Left stick up\n}\nif err := stream.WriteBinary(input); err != nil {\n  log.Fatal(err)\n}\n</code></pre>"},{"location":"clients/go/#receiving-output-callbacks","title":"Receiving Output (Callbacks)","text":"<p>For devices that send feedback (rumble, LEDs), use <code>StartReading</code> with a decode function:</p> <pre><code>import (\n  \"bufio\"\n  \"encoding\"\n  \"io\"\n  \"viiper/pkg/device/xbox360\"\n)\n\n// Start async reading for rumble commands\nrumbleCh, errCh := stream.StartReading(ctx, 10, func(r *bufio.Reader) (encoding.BinaryUnmarshaler, error) {\n  var b [2]byte\n  if _, err := io.ReadFull(r, b[:]); err != nil { return nil, err }\n  msg := new(xbox360.XRumbleState)\n  if err := msg.UnmarshalBinary(b[:]); err != nil { return nil, err }\n  return msg, nil\n})\n\ngo func() {\n  for {\n    select {\n    case msg := &lt;-rumbleCh:\n      rumble := msg.(*xbox360.XRumbleState)\n      fmt.Printf(\"Rumble: Left=%d Right=%d\\n\", rumble.LeftMotor, rumble.RightMotor)\n    case err := &lt;-errCh:\n      if err != nil { log.Printf(\"Stream error: %v\", err) }\n      return\n    }\n  }\n}()\n</code></pre>"},{"location":"clients/go/#closing-a-stream","title":"Closing a Stream","text":"<pre><code>stream.Close()\n</code></pre>"},{"location":"clients/go/#device-specific-notes","title":"Device-Specific Notes","text":"<p>Each device type has specific wire formats and helper methods. For wire format details and usage patterns, see the Devices section of the documentation.</p> <p>The Go client provides device packages under <code>pkg/device/</code> with type-safe structs and constants (e.g., <code>keyboard.InputState</code>, <code>keyboard.KeyA</code>, <code>mouse.Btn_Left</code>).</p>"},{"location":"clients/go/#configuration-and-advanced-usage","title":"Configuration and Advanced Usage","text":""},{"location":"clients/go/#custom-timeouts","title":"Custom Timeouts","text":"<pre><code>cfg := &amp;apiclient.Config{\n  DialTimeout:  2 * time.Second,\n  ReadTimeout:  3 * time.Second,\n  WriteTimeout: 3 * time.Second,\n}\nclient := apiclient.NewWithConfig(\"127.0.0.1:3242\", cfg)\n</code></pre> <p>Default timeouts are: Dial 3s, Read/Write 5s.</p>"},{"location":"clients/go/#context-aware-calls","title":"Context-Aware Calls","text":"<p>All methods have context-aware variants ending with <code>Ctx</code>:</p> <pre><code>ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\ndefer cancel()\n\nbuses, err := client.BusListCtx(ctx)\n</code></pre>"},{"location":"clients/go/#error-handling","title":"Error Handling","text":"<p>The server returns errors as <code>{ \"error\": \"message\" }</code> JSON. The client wraps these as Go errors:</p> <pre><code>if err != nil {\n  log.Printf(\"request failed: %v\", err)\n}\n</code></pre>"},{"location":"clients/go/#examples","title":"Examples","text":"<p>Full working examples are available in the repository:</p> <ul> <li>Virtual Mouse: <code>examples/virtual_mouse/main.go</code></li> <li>Virtual Keyboard: <code>examples/virtual_keyboard/main.go</code></li> <li>Virtual Xbox360 Controller: <code>examples/virtual_x360_pad/main.go</code></li> </ul>"},{"location":"clients/go/#see-also","title":"See Also","text":"<ul> <li>Generator Documentation: How generated SDKs work</li> <li>C SDK Documentation: Generated C SDK usage</li> <li>API Overview: Management API reference</li> </ul>"},{"location":"devices/keyboard/","title":"HID Keyboard (virtual)","text":"<p>A full-featured HID keyboard with N-key rollover using a 256-bit key bitmap, plus LED status feedback (NumLock, CapsLock, ScrollLock) via an OUT report.</p> <ul> <li>USB IDs: VID 0x2E8A (Raspberry Pi), PID 0x0010</li> <li>Interfaces/Endpoints:</li> <li>IN: 0x81 (keyboard input report)</li> <li>OUT: 0x01 (LED output report)</li> <li>Device type id (for API add): <code>keyboard</code></li> </ul>"},{"location":"devices/keyboard/#hid-report-format-host-facing","title":"HID report format (host-facing)","text":"<p>Input (device \u2192 host): 34 bytes</p> <ul> <li>Byte 0: Modifiers bitfield (LeftCtrl, LeftShift, LeftAlt, LeftGUI, RightCtrl, RightShift, RightAlt, RightGUI)</li> <li>Byte 1: Reserved (0)</li> <li>Bytes 2..33: 256-bit key bitmap (least-significant bit = usage ID 0)</li> </ul> <p>Output (host \u2192 device): 1 byte LEDs</p> <ul> <li>Bit 0 NumLock, Bit 1 CapsLock, Bit 2 ScrollLock (remaining bits reserved)</li> </ul> <p>Note: The HID descriptor uses a long-item Report Count (0x96) to encode 256 for the bitmap.</p>"},{"location":"devices/keyboard/#device-stream-protocol-client-facing","title":"Device stream protocol (client-facing)","text":"<p>Wire format from your client into VIIPER:</p> <ul> <li>Variable-length packets</li> <li>Header: [Modifiers (1 byte), KeyCount (1 byte)]</li> <li>Followed by KeyCount bytes of HID Usage IDs for the currently pressed non-modifier keys</li> </ul> <p>VIIPER converts this to the bitmap report for the host, so you don\u2019t need to manage the 256-bit array yourself.</p> <p>Example wire packet to press \u201cA\u201d with LeftShift:</p> <ul> <li>Modifiers = 0x02 (LeftShift)</li> <li>Count = 1</li> <li>Keys = [0x04]  // HID usage for \u201cA\u201d</li> </ul>"},{"location":"devices/keyboard/#leds-feedback","title":"LEDs feedback","text":"<p>The device sends the current LED state (1 byte) back on the same stream whenever the host changes it. You can use this to update indicators in your client.</p>"},{"location":"devices/keyboard/#helpers-and-keycodes","title":"Helpers and keycodes","text":"<p>Convenience helpers and key constants are available in the Go package:</p> <ul> <li><code>pkg/device/keyboard/helpers.go</code>: TypeString, TypeChar, PressKey, Release, etc.</li> <li><code>pkg/device/keyboard/const.go</code>: Modifiers, LED bits, and HID usage IDs, including media keys (Mute, VolumeUp/Down, PlayPause, Stop, Next, Previous)</li> </ul>"},{"location":"devices/keyboard/#adding-the-device","title":"Adding the device","text":"<pre><code>bus/create\nbus/1/add keyboard\n</code></pre>"},{"location":"devices/keyboard/#examples","title":"Examples","text":"<p>A runnable example that types \u201cHello!\u201d followed by Enter every few seconds is provided in <code>examples/virtual_keyboard/</code>.</p>"},{"location":"devices/mouse/","title":"HID Mouse (virtual)","text":"<p>A standard 5-button mouse with vertical and horizontal scroll wheels. Reports relative motion deltas and supports up to five buttons.</p> <ul> <li>USB IDs: VID 0x2E8A (Raspberry Pi), PID 0x0011</li> <li>Interface/Endpoint: IN 0x81 (mouse input report)</li> <li>Device type id (for API add): <code>mouse</code></li> </ul>"},{"location":"devices/mouse/#hid-report-format-host-facing","title":"HID report format (host-facing)","text":"<p>Input (device \u2192 host): 5 bytes</p> <ul> <li>Byte 0: Buttons bitfield (bits 0..4 for buttons 1..5)</li> <li>Byte 1: X delta (int8)</li> <li>Byte 2: Y delta (int8)</li> <li>Byte 3: Vertical wheel (int8; positive up)</li> <li>Byte 4: Horizontal wheel/pan (int8; positive right)</li> </ul> <p>Deltas are consumed after each IN report so motion is truly relative and not repeated across host polls.</p>"},{"location":"devices/mouse/#device-stream-protocol-client-facing","title":"Device stream protocol (client-facing)","text":"<p>Wire format from your client into VIIPER:</p> <ul> <li>Fixed 5-byte packets matching the HID report layout:   [Buttons, dX, dY, Wheel, Pan]</li> </ul> <p>Buttons persist until changed; motion/wheel deltas are applied once and reset.</p>"},{"location":"devices/mouse/#adding-the-device","title":"Adding the device","text":"<pre><code>bus/create\nbus/1/add mouse\n</code></pre>"},{"location":"devices/mouse/#examples","title":"Examples","text":"<p>A runnable example that periodically moves the mouse a short distance, clicks, and scrolls is provided in <code>examples/virtual_mouse/</code>.</p>"},{"location":"devices/xbox360/","title":"Xbox 360 Controller (virtual)","text":"<p>The Xbox 360 virtual gamepad emulates an XInput-compatible controller that most operating systems and games understand out of the box.</p> <ul> <li>USB IDs: VID 0x045E (Microsoft), PID 0x028E (Xbox 360 Controller)</li> <li>Interfaces/Endpoints: single HID interface with one IN interrupt endpoint and one OUT interrupt endpoint for rumble</li> <li>Device type id (for API add): <code>xbox360</code></li> </ul>"},{"location":"devices/xbox360/#adding-the-device","title":"Adding the device","text":"<p>Use the API to create a bus and add an Xbox 360 controller:</p> <pre><code>bus/create\nbus/1/add xbox360\n</code></pre> <p>The API returns a <code>busid</code> like <code>1-1</code>. Attach it from a USB/IP client, then open a stream to drive input and receive rumble.</p>"},{"location":"devices/xbox360/#streaming-protocol","title":"Streaming protocol","text":"<p>The device stream is a bidirectional, raw TCP connection with fixed-size packets.</p> <p>Direction: client \u2192 server (input state)</p> <ul> <li>14-byte packets, little-endian layout:</li> <li>Buttons: uint32 (4 bytes)</li> <li>LT, RT: uint8, uint8 (2 bytes)</li> <li>LX, LY, RX, RY: int16 each (8 bytes)</li> </ul> <p>Direction: server \u2192 client (rumble feedback)</p> <ul> <li>2-byte packets:</li> <li>LeftMotor: uint8, RightMotor: uint8</li> </ul> <p>See <code>pkg/device/xbox360/inputstate.go</code> for details.</p>"},{"location":"devices/xbox360/#example","title":"Example","text":"<p>A minimal example program that sends input and reads rumble is provided in <code>examples/</code>.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>VIIPER relies on USBIP. You must have USBIP installed on your system.</p>"},{"location":"getting-started/installation/#linux","title":"Linux","text":""},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt install linux-tools-generic\n</code></pre> <p>Ubuntu USBIP Manual</p>"},{"location":"getting-started/installation/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S usbip\n</code></pre> <p>Arch Wiki: USBIP</p>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>usbip-win2 is by far the most complete implementation of USBIP for Windows (comes with a SIGNED kernel mode driver).</p>"},{"location":"getting-started/installation/#installing-viiper","title":"Installing VIIPER","text":""},{"location":"getting-started/installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release from the GitHub Releases page.</p>"},{"location":"getting-started/installation/#building-from-source","title":"Building from Source","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or newer</li> <li>USBIP installed</li> <li>(Optional) Make<ul> <li>Linux/macOS: Usually pre-installed</li> <li>Windows: <code>winget install ezwinports.make</code></li> </ul> </li> </ul>"},{"location":"getting-started/installation/#build-steps","title":"Build Steps","text":"<pre><code>git clone https://github.com/Alia5/VIIPER.git\ncd VIIPER\nmake build\n</code></pre> <p>The compiled binary will be in <code>dist/viiper</code> (or <code>dist/viiper.exe</code> on Windows).</p> <p>Additional build targets:</p> <pre><code>make help          # Show all available make targets\nmake test          # Run tests\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>\ud83d\udea7 Documentation in progress \ud83d\udea7</p> <p>This section will cover basic usage examples for getting started with VIIPER.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<p>Check the CLI Reference for detailed command documentation.</p>"}]}