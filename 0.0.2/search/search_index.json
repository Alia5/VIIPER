{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#viiper-documentation","title":"VIIPER Documentation","text":"<p>Welcome to the VIIPER documentation!</p> <p>VIIPER is a tool to create virtual input devices using USBIP.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>CLI Reference</li> <li>API Reference</li> <li>GitHub Repository</li> </ul>"},{"location":"#what-is-viiper","title":"What is VIIPER?","text":"<p>VIIPER creates virtual USB input devices using the USBIP protocol. These virtual devices appear as real hardware to the operating system and applications, allowing you to emulate controllers, keyboards, and other input devices without physical hardware.</p> <p>Beyond device emulation, VIIPER can proxy real USB devices for traffic inspection and reverse engineering. All devices can and must be controlled programmatically via an API.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Virtual input device emulation over IP using USBIP    <ul> <li>\u2705 Xbox 360 controller emulation (virtual device)</li> <li>\ud83d\udd1c Keyboard and mouse emulation</li> <li>\ud83d\udd1c ???     \ud83d\udea7 Architecture allows for more device types (keyboard, mouse, other gamepads), but only Xbox 360 controller is implemented so far</li> </ul> </li> <li>\u2705 USBIP server mode: expose virtual devices to remote clients</li> <li>\u2705 Proxy mode: forward real USB devices and inspect/record traffic</li> <li>\u2705 Cross-platform: works on Linux and Windows</li> <li>\u2705 Flexible logging (including raw USB packet logs)</li> <li>\u2705 API server for device/bus management and controlling virtual devices programmatically</li> </ul>"},{"location":"mkdocs-readme/","title":"MkDocs Documentation","text":"<p>This directory contains the MkDocs-based documentation for VIIPER.</p>"},{"location":"mkdocs-readme/#setup","title":"Setup","text":"<p>Install MkDocs with Material theme:</p> <pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"mkdocs-readme/#development","title":"Development","text":"<p>Run the documentation server locally:</p> <pre><code>cd doc\nmkdocs serve\n</code></pre> <p>Then open http://127.0.0.1:8000/ in your browser.</p>"},{"location":"mkdocs-readme/#building","title":"Building","text":"<p>Build the static documentation site:</p> <pre><code>cd doc\nmkdocs build\n</code></pre> <p>The built site will be in the <code>site/</code> directory.</p>"},{"location":"mkdocs-readme/#deployment","title":"Deployment","text":"<p>Deploy to GitHub Pages:</p> <pre><code>cd doc\nmkdocs gh-deploy\n</code></pre>"},{"location":"mkdocs-readme/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>mkdocs.yml</code> - MkDocs configuration</li> <li><code>docs/</code> - Documentation source files (Markdown)<ul> <li><code>index.md</code> - Home page</li> <li><code>getting-started/</code> - Installation and quick start</li> <li><code>cli/</code> - CLI reference</li> <li><code>api/</code> - API reference</li> </ul> </li> </ul>"},{"location":"api/overview/","title":"API Reference","text":"<p>VIIPER ships a lightweight TCP API (not REST) for managing virtual buses/devices and for device-specific streaming. It\u2019s designed to be trivial to drive from any language that can open a TCP socket and send newline-terminated commands.</p>"},{"location":"api/overview/#protocol-overview","title":"Protocol overview","text":"<ul> <li>Transport: TCP</li> <li>Default listen address: <code>:3242</code> (configurable via <code>--api.addr</code>)</li> <li>Request format: a single ASCII/UTF\u20118 line terminated by <code>\\n</code></li> <li>Routing: first token is the path (e.g. <code>bus/list</code>), remaining tokens are arguments (space-separated)</li> <li>Success response: a single line containing a JSON payload (or an empty line for commands that have no payload)</li> <li>Error response: a single line JSON object <code>{ \"error\": \"message\" }</code></li> </ul> <p>Tip: You can experiment with <code>nc</code>/<code>ncat</code> or PowerShell\u2019s <code>tcpclient</code> to send lines and read JSON back.</p> <p>Connection timing and auto\u2011cleanup</p> <p>After you add a device with <code>bus/{id}/add</code>, you must connect to its streaming endpoint within the configured <code>DeviceHandlerConnectTimeout</code> (default: 5s). If no stream connection is established in time, the device is automatically removed. Likewise, when a stream disconnects, a reconnection timer with the same timeout starts; if the client doesn\u2019t reconnect before it expires, the device is removed.</p>"},{"location":"api/overview/#commands","title":"Commands","text":"<p>The server registers the following commands and streams:</p> <ul> <li> <p><code>bus/list</code></p> <ul> <li>List all virtual bus IDs.</li> <li>Response: <code>{ \"buses\": [1, 2, ...] }</code></li> </ul> </li> <li> <p><code>bus/create [busId]</code></p> <ul> <li>Create a new bus. If <code>busId</code> is provided, VIIPER attempts to create the bus with that id; otherwise it picks the next free id.</li> <li>Response: <code>{ \"busId\": &lt;id&gt; }</code></li> </ul> </li> <li> <p><code>bus/remove &lt;busId&gt;</code></p> <ul> <li>Remove a bus and all devices on it.</li> <li>Response: <code>{ \"busId\": &lt;id&gt; }</code></li> </ul> </li> <li> <p><code>bus/{id}/list</code></p> <ul> <li>List devices on a bus.</li> <li>Response: <code>{ \"devices\": [{ \"busId\": 1, \"devId\": \"1\", \"vid\": \"0x045e\", \"pid\": \"0x028e\", \"type\": \"xbox360\" }, ...] }</code></li> </ul> </li> <li> <p><code>bus/{id}/add &lt;deviceType&gt;</code></p> <ul> <li>Add a device to a bus. <code>deviceType</code> is a registered device name (e.g., <code>xbox360</code>).</li> <li>Response: <code>{ \"id\": \"&lt;busId&gt;-&lt;devId&gt;\" }</code> where the id is the USBIP busid string you will attach to.</li> <li>Important: After add, the server starts a connect timer (default <code>5s</code>). You must open a device stream (see below) before the timeout expires, otherwise the device is auto-removed.</li> </ul> </li> <li> <p><code>bus/{id}/remove &lt;deviceId&gt;</code></p> <ul> <li>Remove a device by its device number on that bus (the part after the dash in the busid string).</li> <li>Response: <code>{ \"busId\": &lt;id&gt;, \"devId\": \"&lt;dev&gt;\" }</code></li> </ul> </li> </ul>"},{"location":"api/overview/#streaming-endpoint","title":"Streaming endpoint","text":"<ul> <li>Path: <code>bus/{busId}/{deviceid}</code></li> <li>Type: long-lived TCP connection (no line protocol once established)</li> <li>Purpose: device-specific, bidirectional stream. The API server hands the socket to the device\u2019s registered stream handler.</li> <li>Timeout behavior: When a stream ends, a reconnect timer is started (same <code>DeviceHandlerConnectTimeout</code>). If the client doesn\u2019t reconnect in time, the device is removed.</li> </ul>"},{"location":"api/overview/#xbox-360-controller-stream-device-type-xbox360","title":"Xbox 360 controller stream (device type: <code>xbox360</code>)","text":"<p>Direction: client \u279c server (input state)</p> <ul> <li>Fixed 14-byte packets, little-endian layout:<ul> <li><code>Buttons</code> uint32 (4 bytes)</li> <li><code>LT</code> uint8, <code>RT</code> uint8 (2 bytes)</li> <li><code>LX, LY, RX, RY</code> int16 each (8 bytes)</li> </ul> </li> </ul> <p>Direction: server \u279c client (rumble)</p> <ul> <li>Fixed 2-byte packets:<ul> <li><code>LeftMotor</code> uint8, <code>RightMotor</code> uint8</li> </ul> </li> </ul> <p>See <code>pkg/device/xbox360/protocol.go</code> for full details.</p> <p>Note on protocol compatibility:</p> <ul> <li>The wire format is modeled after the XInput gamepad state (XINPUT_GAMEPAD) but is not byte\u2011for\u2011byte identical. Key differences:<ul> <li>Buttons are encoded as a 32\u2011bit little\u2011endian field (XInput uses a 16\u2011bit bitmask), making the packet 14 bytes instead of 12.</li> <li>No header or framing: packets are fixed\u2011length and back\u2011to\u2011back on the TCP stream.</li> <li>Endianness is little\u2011endian for all multi\u2011byte fields.</li> </ul> </li> </ul>"},{"location":"api/overview/#example-sessions","title":"Example sessions","text":""},{"location":"api/overview/#using-netcat-linuxmacos","title":"Using netcat (Linux/macOS)","text":"<pre><code># List buses\nprintf \"bus/list\\n\" | nc localhost 3242\n\n# Create a bus\nprintf \"bus/create\\n\" | nc localhost 3242\n# \u2192 {\"busId\":1}\n\n# Add a virtual Xbox 360 controller to bus 1\nprintf \"bus/1/add xbox360\\n\" | nc localhost 3242\n# \u2192 {\"id\":\"1-1\"}\n\n# List devices on bus 1\nprintf \"bus/1/list\\n\" | nc localhost 3242\n</code></pre> <p>Then, open a second TCP connection for streaming to <code>bus/1/1</code> (the API port, not the USBIP port). You\u2019ll write 14\u2011byte input packets and read 2\u2011byte rumble packets. Any language with raw TCP support works.</p>"},{"location":"api/overview/#windows-powershell","title":"WIndows (PowerShell)","text":"<p>VIIPER includes convenience scripts for quick testing and automation:</p> <pre><code># Source the script to load helper functions\n. .\\scripts\\viiper-api.ps1\n\n# Use the Invoke-ViiperApi function (or 'viiper' alias)\nviiper \"bus/list\"\nviiper \"bus/create\"\nviiper \"bus/1/add xbox360\" -Port 3242 -Hostname localhost\n</code></pre> <p>The script provides <code>Invoke-ViiperApi</code> (alias: <code>viiper</code>) for sending commands and <code>Connect-ViiperDevice</code> for testing persistent device connections.</p>"},{"location":"api/overview/#go-snippet-raw","title":"Go snippet (raw)","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"net\"\n)\n\nfunc main() {\n    conn, _ := net.Dial(\"tcp\", \"localhost:3242\")\n    defer conn.Close()\n    fmt.Fprintln(conn, \"bus/create\")\n    r := bufio.NewReader(conn)\n    line, _ := r.ReadString('\\n')\n    fmt.Println(line) // {\"busId\":1}\n}\n</code></pre> <p>For a higher-level experience, see the Go client in <code>pkg/apiclient/</code>.</p>"},{"location":"api/overview/#how-this-relates-to-usbip","title":"How this relates to USBIP","text":"<p>The API controls which virtual devices exist and exposes a device stream for live input/feedback. Separately, the USBIP server (default <code>:3241</code>) makes these devices attachable from clients. Typical flow:</p> <p>1) Create a bus \u279c 2) Add a device \u279c 3) Connect the device stream \u279c 4) From a client, attach using USBIP by <code>busid</code> (see the Server command page for exact <code>usbip</code> syntax).</p>"},{"location":"changelog/0.0.2/","title":"Changelog for Version 0.0.2","text":"<p>Release Date: 2025-11-16</p> <p>Changes since v0.0.1:</p>"},{"location":"changelog/0.0.2/#miscellaneous","title":"\ud83d\udd27 Miscellaneous","text":"<ul> <li>Mkdocs to GH-Pages</li> </ul>"},{"location":"cli/configuration/","title":"Configuration","text":"<p>VIIPER can be configured via command-line flags or environment variables.</p>"},{"location":"cli/configuration/#environment-variables","title":"Environment Variables","text":"<p>All command-line flags have corresponding environment variables for easier deployment and configuration management.</p>"},{"location":"cli/configuration/#global-configuration","title":"Global Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_LOG_LEVEL</code> <code>--log.level</code> <code>info</code> Logging level: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> <code>VIIPER_LOG_FILE</code> <code>--log.file</code> (none) Log file path (logs only to console if not set) <code>VIIPER_LOG_RAW_FILE</code> <code>--log.raw-file</code> (none) Raw packet log file path"},{"location":"cli/configuration/#server-configuration","title":"Server Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_USB_ADDR</code> <code>--usb.addr</code> <code>:3241</code> USBIP server listen address <code>VIIPER_API_ADDR</code> <code>--api.addr</code> <code>:3242</code> API server listen address (empty = disabled) <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code> <code>--api.device-handler-timeout</code> <code>5s</code> Device handler auto-cleanup timeout <code>VIIPER_CONNECTION_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection operation timeout"},{"location":"cli/configuration/#proxy-configuration","title":"Proxy Configuration","text":"Environment Variable CLI Flag Default Description <code>VIIPER_PROXY_ADDR</code> <code>--listen-addr</code> <code>:3241</code> Proxy listen address <code>VIIPER_PROXY_UPSTREAM</code> <code>--upstream</code> (required) Upstream USBIP server address <code>VIIPER_PROXY_TIMEOUT</code> <code>--connection-timeout</code> <code>30s</code> Connection timeout"},{"location":"cli/configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"cli/configuration/#using-environment-variables","title":"Using Environment Variables","text":"<p>Create a <code>.env</code> file or export variables:</p> <pre><code>export VIIPER_LOG_LEVEL=debug\nexport VIIPER_USB_ADDR=:3241\nexport VIIPER_API_ADDR=:3242\nexport VIIPER_LOG_FILE=/var/log/viiper.log\n</code></pre> <p>Then run:</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/configuration/#systemd-service","title":"Systemd Service","text":"<p>Example systemd service file for running VIIPER as a service:</p> <pre><code>[Unit]\nDescription=VIIPER USBIP Server\nAfter=network.target\n\n[Service]\nType=simple\nUser=viiper\nGroup=viiper\nEnvironment=\"VIIPER_LOG_LEVEL=info\"\nEnvironment=\"VIIPER_LOG_FILE=/var/log/viiper/viiper.log\"\nEnvironment=\"VIIPER_USB_ADDR=:3241\"\nEnvironment=\"VIIPER_API_ADDR=:3242\"\nExecStart=/usr/local/bin/viiper server\nRestart=on-failure\nRestartSec=5s\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"cli/configuration/#configuration-priority","title":"Configuration Priority","text":"<p>When both CLI flags and environment variables are set, CLI flags take precedence:</p> <ol> <li>CLI flags (highest priority)</li> <li>Environment variables</li> <li>Default values (lowest priority)</li> </ol>"},{"location":"cli/configuration/#see-also","title":"See Also","text":"<ul> <li>Server Command</li> <li>Proxy Command</li> </ul>"},{"location":"cli/overview/","title":"CLI Overview","text":"<p>VIIPER provides a command-line interface for running the USBIP server and proxy.</p>"},{"location":"cli/overview/#commands","title":"Commands","text":"<ul> <li><code>server</code> - Start the VIIPER USBIP server</li> <li><code>proxy</code> - Start the VIIPER USBIP proxy</li> </ul>"},{"location":"cli/overview/#global-options","title":"Global Options","text":""},{"location":"cli/overview/#logging","title":"Logging","text":"<p>VIIPER supports flexible logging configuration via global flags or environment variables.</p>"},{"location":"cli/overview/#-loglevel","title":"<code>--log.level</code>","text":"<p>Set the logging level.</p> <p>Values: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> Default: <code>info</code> Environment Variable: <code>VIIPER_LOG_LEVEL</code></p> <p>Example:</p> <pre><code>viiper server --log.level=debug\n</code></pre>"},{"location":"cli/overview/#-logfile","title":"<code>--log.file</code>","text":"<p>Log to a file in addition to console output.</p> <p>Default: (none - logs only to console) Environment Variable: <code>VIIPER_LOG_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/overview/#-lograw-file","title":"<code>--log.raw-file</code>","text":"<p>Log raw USB packet data to a file for debugging and reverse engineering.</p> <p>Default: (none) Environment Variable: <code>VIIPER_LOG_RAW_FILE</code></p> <p>Example:</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre> <p>Automatic Raw Logging</p> <p>When <code>--log.level=trace</code> is set without <code>--log.raw-file</code>, raw packets are logged to stdout.</p>"},{"location":"cli/overview/#getting-help","title":"Getting Help","text":"<p>Display help for any command:</p> <pre><code>viiper --help\nviiper server --help\nviiper proxy --help\n</code></pre>"},{"location":"cli/proxy/","title":"Proxy Command","text":"<p>Start the VIIPER USBIP proxy for traffic inspection and logging.</p>"},{"location":"cli/proxy/#usage","title":"Usage","text":"<pre><code>viiper proxy --upstream=&lt;address&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/proxy/#description","title":"Description","text":"<p>The <code>proxy</code> command starts VIIPER in proxy mode, sitting between a USBIP client and a USBIP server. VIIPER intercepts and logs all USB traffic passing through, without handling the devices directly.</p> <p>This is useful for reverse engineering USB protocols and understanding how devices communicate.</p>"},{"location":"cli/proxy/#options","title":"Options","text":""},{"location":"cli/proxy/#-listen-addr","title":"<code>--listen-addr</code>","text":"<p>Proxy listen address (where clients connect).</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_PROXY_ADDR</code></p> <p>Example:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3241\n</code></pre>"},{"location":"cli/proxy/#-upstream","title":"<code>--upstream</code>","text":"<p>Required. Upstream USBIP server address (where real devices are).</p> <p>Environment Variable: <code>VIIPER_PROXY_UPSTREAM</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241\n</code></pre>"},{"location":"cli/proxy/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection timeout for proxy operations.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_PROXY_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241 --connection-timeout=60s\n</code></pre>"},{"location":"cli/proxy/#examples","title":"Examples","text":""},{"location":"cli/proxy/#basic-proxy","title":"Basic Proxy","text":"<p>Start proxy between local clients and remote USBIP server:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241\n</code></pre> <p>Clients connect to <code>localhost:3241</code>, traffic is proxied to <code>192.168.1.100:3241</code>.</p>"},{"location":"cli/proxy/#custom-listen-address","title":"Custom Listen Address","text":"<p>Start proxy on a different port:</p> <pre><code>viiper proxy --listen-addr=:9000 --upstream=192.168.1.100:3241\n</code></pre> <p>Clients connect to <code>localhost:9000</code>, traffic is proxied to <code>192.168.1.100:3241</code>.</p>"},{"location":"cli/proxy/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Capture all USB traffic for reverse engineering:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241 --log.raw-file=usb-capture.log\n</code></pre> <p>All USB packets will be logged to <code>usb-capture.log</code>.</p>"},{"location":"cli/proxy/#with-debug-logging","title":"With Debug Logging","text":"<p>Enable debug logging to see proxy operations:</p> <pre><code>viiper proxy --upstream=192.168.1.100:3241 --log.level=debug\n</code></pre>"},{"location":"cli/proxy/#use-cases","title":"Use Cases","text":""},{"location":"cli/proxy/#reverse-engineering","title":"Reverse Engineering","text":"<p>Intercept USB traffic between a client and server to understand device protocols:</p> <pre><code>viiper proxy --upstream=real-server:3241 --log.raw-file=device-capture.log\n</code></pre>"},{"location":"cli/proxy/#traffic-analysis","title":"Traffic Analysis","text":"<p>Monitor USB communication for debugging:</p> <pre><code>viiper proxy --upstream=real-server:3241 --log.level=trace\n</code></pre>"},{"location":"cli/proxy/#network-inspection","title":"Network Inspection","text":"<p>Route USB traffic through VIIPER to inspect and log all operations:</p> <pre><code>viiper proxy --upstream=real-server:3241 --log.level=debug --log.raw-file=traffic.log\n</code></pre>"},{"location":"cli/proxy/#proxy-architecture","title":"Proxy Architecture","text":"<pre><code>USBIP Client  \u2192  VIIPER Proxy  \u2192  USBIP Server (real devices)\n                      \u2193\n              Logs/Captures Traffic\n</code></pre> <p>VIIPER sits in the middle, forwarding all traffic while logging packets for inspection.</p>"},{"location":"cli/proxy/#see-also","title":"See Also","text":"<ul> <li>Server Command - Run VIIPER as a USBIP server</li> <li>Configuration - Environment variables and configuration files</li> </ul>"},{"location":"cli/server/","title":"Server Command","text":"<p>Start the VIIPER USBIP server to expose virtual devices.</p>"},{"location":"cli/server/#usage","title":"Usage","text":"<pre><code>viiper server [OPTIONS]\n</code></pre>"},{"location":"cli/server/#description","title":"Description","text":"<p>The <code>server</code> command starts the VIIPER USBIP server, which allows you to create and manage virtual USB devices that appear as real hardware to USBIP clients.</p> <p>The server exposes two interfaces:</p> <ol> <li>USBIP Server - Standard USBIP protocol for device attachment</li> <li>API Server (optional) - Management API for device/bus control</li> </ol>"},{"location":"cli/server/#options","title":"Options","text":""},{"location":"cli/server/#-usbaddr","title":"<code>--usb.addr</code>","text":"<p>USBIP server listen address.</p> <p>Default: <code>:3241</code> Environment Variable: <code>VIIPER_USB_ADDR</code></p> <p>Example:</p> <pre><code>viiper server --usb.addr=0.0.0.0:3241\n</code></pre>"},{"location":"cli/server/#-apiaddr","title":"<code>--api.addr</code>","text":"<p>API server listen address. If empty, the API server is disabled.</p> <p>Default: <code>:3242</code> Environment Variable: <code>VIIPER_API_ADDR</code></p> <p>Example:</p> <pre><code># Enable API on custom port\nviiper server --api.addr=:8080\n\n# Disable API server\nviiper server --api.addr=\n</code></pre>"},{"location":"cli/server/#-apidevice-handler-timeout","title":"<code>--api.device-handler-timeout</code>","text":"<p>Time before auto-cleanup occurs when a device handler has no active connection.</p> <p>Default: <code>5s</code> Environment Variable: <code>VIIPER_API_DEVICE_HANDLER_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --api.device-handler-timeout=10s\n</code></pre>"},{"location":"cli/server/#-connection-timeout","title":"<code>--connection-timeout</code>","text":"<p>Connection operation timeout for both USBIP and API servers.</p> <p>Default: <code>30s</code> Environment Variable: <code>VIIPER_CONNECTION_TIMEOUT</code></p> <p>Example:</p> <pre><code>viiper server --connection-timeout=60s\n</code></pre>"},{"location":"cli/server/#examples","title":"Examples","text":""},{"location":"cli/server/#basic-server","title":"Basic Server","text":"<p>Start server with default settings (USBIP on :3241, API on :3242):</p> <pre><code>viiper server\n</code></pre>"},{"location":"cli/server/#server-without-api","title":"Server Without API","text":"<p>Start only the USBIP server (no API):</p> <pre><code>viiper server --api.addr=\n</code></pre>"},{"location":"cli/server/#custom-addresses","title":"Custom Addresses","text":"<p>Start server on custom ports:</p> <pre><code>viiper server --usb.addr=:9000 --api.addr=:9001\n</code></pre>"},{"location":"cli/server/#with-logging","title":"With Logging","text":"<p>Start server with debug logging to file:</p> <pre><code>viiper server --log.level=debug --log.file=/var/log/viiper.log\n</code></pre>"},{"location":"cli/server/#with-raw-packet-logging","title":"With Raw Packet Logging","text":"<p>Start server with raw USB packet logging (useful for reverse engineering):</p> <pre><code>viiper server --log.raw-file=/var/log/viiper-raw.log\n</code></pre>"},{"location":"cli/server/#connect-from-a-client-usbip","title":"Connect from a client (USBIP)","text":"<p>After the server is running and a virtual device has been added to a bus (via the API), attach it from a client using USBIP.</p> <p>Notes: - VIIPER's USBIP server listens on <code>:3241</code> by default (configurable via <code>--usb.addr</code>). - The BUSID-DEVICEID you need (e.g. <code>1-1</code>) is returned by the API on device add and also visible via <code>usbip list</code>.</p>"},{"location":"cli/server/#linux","title":"Linux","text":"<pre><code># Load the virtual host controller (only needed once per boot)\nsudo modprobe vhci-hcd\n\n# List exportable devices on the VIIPER host\nusbip list --remote=VIIPER_HOST --tcp-port=3241\n\n# Attach a device by busid (long flags)\nsudo usbip attach --remote=VIIPER_HOST --tcp-port=3241 --busid=BUSID-DEVICEID\n\n# Equivalent short-form flags\nsudo usbip --tcp-port 3241 -r VIIPER_HOST -b BUSID-DEVICEID\n</code></pre> <p>Replace <code>VIIPER_HOST</code> with the server's hostname/IP. If you changed the USBIP port, use that port instead of <code>3241</code>.</p>"},{"location":"cli/server/#windows","title":"Windows","text":"<p>On Windows, use usbip-win2:</p> <ul> <li>GUI: use the client to add a remote host and attach by busid.</li> <li>CLI (similar flags):</li> </ul> <pre><code>usbip.exe list --remote VIIPER_HOST --tcp-port 3241\nusbip.exe attach --remote VIIPER_HOST --tcp-port 3241 --busid BUSID-DEVICEID\n</code></pre> <p>Once attached, the device will appear to the OS/applications as a local USB device.</p>"},{"location":"cli/server/#see-also","title":"See Also","text":"<ul> <li>Configuration - Environment variables and configuration files</li> <li>API Reference - API server documentation</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>VIIPER relies on USBIP. You must have USBIP installed on your system.</p>"},{"location":"getting-started/installation/#linux","title":"Linux","text":""},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt install linux-tools-generic\n</code></pre> <p>Ubuntu USBIP Manual</p>"},{"location":"getting-started/installation/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S usbip\n</code></pre> <p>Arch Wiki: USBIP</p>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>usbip-win2 is by far the most complete implementation of USBIP for Windows (comes with a SIGNED kernel mode driver).</p>"},{"location":"getting-started/installation/#installing-viiper","title":"Installing VIIPER","text":""},{"location":"getting-started/installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download the latest release from the GitHub Releases page.</p>"},{"location":"getting-started/installation/#building-from-source","title":"Building from Source","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or newer</li> <li>USBIP installed</li> <li>(Optional) Make<ul> <li>Linux/macOS: Usually pre-installed</li> <li>Windows: <code>winget install ezwinports.make</code></li> </ul> </li> </ul>"},{"location":"getting-started/installation/#build-steps","title":"Build Steps","text":"<pre><code>git clone https://github.com/Alia5/VIIPER.git\ncd VIIPER\nmake build\n</code></pre> <p>The compiled binary will be in <code>dist/viiper</code> (or <code>dist/viiper.exe</code> on Windows).</p> <p>Additional build targets:</p> <pre><code>make help          # Show all available make targets\nmake test          # Run tests\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>\ud83d\udea7 Documentation in progress \ud83d\udea7</p> <p>This section will cover basic usage examples for getting started with VIIPER.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<p>Check the CLI Reference for detailed command documentation.</p>"}]}